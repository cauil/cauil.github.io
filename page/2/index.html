<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Cauil&#39;s Blog">
<meta property="og:url" content="http://cauil.github.io/page/2/index.html">
<meta property="og:site_name" content="Cauil&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cauil&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://cauil.github.io/page/2/"/>





  <title>Cauil's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cauil's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">陌上花开，可缓缓归矣</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/15/2017-11-15-ES6之let与const 字符串和正则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/15/2017-11-15-ES6之let与const 字符串和正则/" itemprop="url">ES6之let与const 字符串和正则</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-15T00:00:00+08:00">
                2017-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="let-const"><a href="#let-const" class="headerlink" title="let const"></a>let const</h2><p>let与const其实没什么特别的，主要就是提供的块级作用域，存在于函数内部和块中（字符{和}之间的区域），没有var的变量提升；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num = 1 + num1; // throw error</div><div class="line">let num1 = 5;</div></pre></td></tr></table></figure></p>
<p>需要注意的点：</p>
<h4 id="禁止重声明"><a href="#禁止重声明" class="headerlink" title="禁止重声明"></a>禁止重声明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var msg = &apos;hi&apos;;</div><div class="line">let msg = &apos;test&apos;; // Uncaught SyntaxError: Identifier &apos;msg&apos; has already been declared</div></pre></td></tr></table></figure>
<h4 id="临时死区TDZ（Temporal-Dead-Zone）"><a href="#临时死区TDZ（Temporal-Dead-Zone）" class="headerlink" title="临时死区TDZ（Temporal Dead Zone）"></a>临时死区TDZ（Temporal Dead Zone）</h4><p>使用let和const定义的变量在定义处到块级作用域开始之间是不能使用定义的变量的，使用会报错；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var msg = &apos;hi&apos;;</div><div class="line">if(true) &#123;</div><div class="line">  typeof msg; // Uncaught ReferenceError: msg is not defined</div><div class="line">  let msg = &apos;hello&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>由于词法作用域的缘故，执行<code>console.log(i)</code>指向的都市同一个i，最后值是10<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var funcs = [];</div><div class="line">for (var i = 0; i &lt; 10; i++) &#123;</div><div class="line">    funcs.push(function() &#123;</div><div class="line">        console.log(i);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">funcs.forEach(function(func) &#123;</div><div class="line">    func();     // outputs the number &quot;10&quot; ten times</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>let声明每次迭代循环会创建一个新变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var funcs = [];</div><div class="line">for (var i = 0; i &lt; 10; i++) &#123;</div><div class="line">    funcs.push((function(value) &#123;</div><div class="line">        return function() &#123;</div><div class="line">            console.log(value);</div><div class="line">&#125; &#125;(i)));</div><div class="line">&#125;</div><div class="line">funcs.forEach(function(func) &#123;</div><div class="line">    func();     // outputs 0, then 1, then 2, up to 9</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="全局作用域行为"><a href="#全局作用域行为" class="headerlink" title="全局作用域行为"></a>全局作用域行为</h4><p>var在全局作用域定义的是window的一个属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var msg = &quot;Hello!&quot;;</div><div class="line">console.log(window.msg); // &apos;Hello!&apos;</div><div class="line">console.log(window.msg === msg); // true</div></pre></td></tr></table></figure></p>
<p>而let和const创建了一个绑定并遮蔽了全局的msg变量；let和const比较安全；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let msg1 = &quot;Hello!&quot;;</div><div class="line">console.log(window.msg1); // undefined</div><div class="line">console.log(window.msg1 === msg1); // false</div></pre></td></tr></table></figure>
<h4 id="const绑定的是引用"><a href="#const绑定的是引用" class="headerlink" title="const绑定的是引用"></a>const绑定的是引用</h4><p>const绑定是引用，只要引用不变，不报错；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const obj = &#123;msg: 1&#125;;</div><div class="line">obj.msg = 2;</div><div class="line">console.log(obj); // &#123;msg: 2&#125;</div><div class="line">obj = &#123;msg: 2&#125; // Uncaught TypeError: Assignment to constant variable.</div></pre></td></tr></table></figure></p>
<p>块级绑定最佳实践是尽量用const，只有确实需要改变变量的值时用let。</p>
<h2 id="字符串变动"><a href="#字符串变动" class="headerlink" title="字符串变动"></a>字符串变动</h2><h4 id="Unicode支持"><a href="#Unicode支持" class="headerlink" title="Unicode支持"></a>Unicode支持</h4><p>ES6出现之前，JS字符一直基于16位字符编码(UTF-16)进行构建。每16位的序列是一个编码单元，代表一个字符。length\chatAt等属性与方法都是基于这种编码单元构成的。</p>
<p>UTF-16编码中：</p>
<ul>
<li>前2**16个码位均以16位的编码单元表示，这个范围被称作BMP</li>
<li>但是如果超出16位编码范围之外的码位，就无法仅用16位来表示，UTF-16引入了<strong>代理对</strong>，用两个16位编码单元来表示；</li>
</ul>
<p>“𠮷”这个字符就是超出16位表示范围的，使用了代理对来表示的，在ES5中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let text = &quot;𠮷&quot;; </div><div class="line">console.log(text.length); // 2</div><div class="line">console.log(/^.$/.test(text)); // false</div><div class="line">console.log(text.charAt(0)); // &quot;&quot;</div><div class="line">console.log(text.charAt(1)); // &quot;&quot;</div><div class="line">console.log(text.charCodeAt(0)); // 55362</div><div class="line">console.log(text.charCodeAt(1)); // 57271</div></pre></td></tr></table></figure>
<h4 id="codePointAt-fromCodePoint"><a href="#codePointAt-fromCodePoint" class="headerlink" title="codePointAt / fromCodePoint"></a>codePointAt / fromCodePoint</h4><p>ES6引入了codePointAt与fromcodePoint来支持超出16位码元，这两个方法接受编码单元的位置而非字符位置作为参数；如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let text = &quot;𠮷a&quot;;</div><div class="line">console.log(text.charCodeAt(0)); // 55362</div><div class="line">console.log(text.charCodeAt(1));  // 57271</div><div class="line">console.log(text.charCodeAt(2)); // 97</div><div class="line">console.log(text.codePointAt(0)); // 134071 超出0xffff</div><div class="line">console.log(text.codePointAt(1)); // 57271</div><div class="line">console.log(text.codePointAt(2)); // 97</div><div class="line">console.log(String.fromCodePoint(134071)); // &apos;𠮷&apos;</div></pre></td></tr></table></figure>
<p>注意charCodeAt与codePointAt的区别，如上面的text.codePointAt(0)计算了’𠮷’的完整码位-两个编码单元，超出0xffff；</p>
<h4 id="新增字符串方法includes-startWith-endWith-repeat"><a href="#新增字符串方法includes-startWith-endWith-repeat" class="headerlink" title="新增字符串方法includes / startWith / endWith / repeat"></a>新增字符串方法includes / startWith / endWith / repeat</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let msg = &quot;Hello world!&quot;;</div><div class="line">console.log(msg.startsWith(&quot;Hello&quot;)); // true</div><div class="line">console.log(msg.endsWith(&quot;!&quot;)); // true</div><div class="line">console.log(msg.includes(&quot;o&quot;)); // true</div><div class="line">console.log(msg.startsWith(&quot;o&quot;)); // false</div><div class="line">console.log(msg.endsWith(&quot;world!&quot;)); // true</div><div class="line">console.log(msg.includes(&quot;x&quot;)); // false</div><div class="line">console.log(msg.startsWith(&quot;o&quot;, 4)); // true</div><div class="line">console.log(msg.endsWith(&quot;o&quot;, 8)); // true</div><div class="line">console.log(msg.includes(&quot;o&quot;, 8));  // false</div></pre></td></tr></table></figure>
<p>这里需要注意的是endsWith是从用第二个参数减去搜索字符的长度得到的数字位置开始搜索的；如<code>msg.endsWith(&quot;o&quot;, 8)</code>是从<code>8-len(&#39;o&#39;)=7</code>开始搜索的；以此类推如果是<code>msg.endsWith(&quot;orl&quot;, 8)</code>则是从<code>8-len(&#39;orl&#39;)=5</code>开始搜索返回false；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;hello&apos;.repeat(2)); // hellohello</div><div class="line">console.log(&apos;a&apos;.repeat(2)); // aa</div><div class="line">console.log(&apos;bc&apos;.repeat(3)); // bcbcbc</div></pre></td></tr></table></figure>
<h4 id="模版字面量"><a href="#模版字面量" class="headerlink" title="模版字面量"></a>模版字面量</h4><p>ES6引入了模版字面量语法支持更丰富的字符串功能：</p>
<ul>
<li>多行字符串</li>
<li>基本的字符串格式化，支持嵌套</li>
<li>HTLM转义</li>
</ul>
<p>看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let message = `hello world!`</div><div class="line">console.log(message) // &apos;hello world&apos;</div><div class="line">console.log(typeof message) // 12</div><div class="line"></div><div class="line">// 多行字符串</div><div class="line">var msg = `Multiline</div><div class="line">string`;</div><div class="line">console.log(msg); // &apos;Multiline</div><div class="line">                  // string&apos;</div><div class="line">console.log(message.length); // 16</div><div class="line"></div><div class="line">// 字符串占位</div><div class="line">let name = &apos;world&apos;,</div><div class="line">    msg1 = `Hello, $&#123;name&#125;`;</div><div class="line">console.log(message); // &quot;Hello, world!&quot;</div></pre></td></tr></table></figure>
<p>除了上面的功能之外，还有一个标签模版的功能；标签可以是一个函数，第一个参数是一个数组，包含JS解释过后的字面量字符串，之后的所有参数都是每一个占位符的解释值；如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function tag(literals, ...substitutions) &#123;</div><div class="line">	console.log(literals);</div><div class="line">	console.log(literals.raw)</div><div class="line">	console.log(substitutions);</div><div class="line">	return &apos;hello world!&apos;;</div><div class="line">&#125;</div><div class="line">var name1 = &apos;lili&apos;;</div><div class="line">var name2 = &apos;lucy&apos;;</div><div class="line">var msg = tag`abc$&#123;name1&#125;def$&#123;name2&#125;\n`;</div><div class="line">//  [&quot;abc&quot;, &quot;def&quot;, &quot;↵&quot;, raw: Array(3)]</div><div class="line">//  [&quot;abc&quot;, &quot;def&quot;, &quot;\n&quot;]</div><div class="line">//  [&quot;lili&quot;, &quot;lucy&quot;]</div><div class="line">console.log(msg); // &apos;hello world!&apos;</div></pre></td></tr></table></figure>
<p>特别要说明的是literals.raw是对应literals的原生字符串信息；如<code>\n</code>为<code>\\n</code>;</p>
<h2 id="正则变动"><a href="#正则变动" class="headerlink" title="正则变动"></a>正则变动</h2><h4 id="u修饰符"><a href="#u修饰符" class="headerlink" title="u修饰符"></a>u修饰符</h4><p>上面我们看到”𠮷”匹配不到/^.$/正则表达式；这是因为正则是通过编码单元来匹配字符串的，而”𠮷”是由两个编码单元组成的，所以/^.$/是匹配不成功的；</p>
<p>为了解决这种问题，ES6引入了一个支持Unicode的u修饰符；当使用了修饰符u，正则表达式就从编码单元模式切换为字符模式，如此一来正则表达式就不会视代理对为两个字符，从而安全按照我们预期正常运行；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let text = &quot;𠮷&quot;;</div><div class="line">console.log(text.length); // 2</div><div class="line">console.log(/^.$/.test(text)); // false</div><div class="line">console.log(/^.$/u.test(text)); // true</div></pre></td></tr></table></figure>
<p>检测是否支持修饰符u：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function hasRegExpU() &#123;</div><div class="line">    try &#123;</div><div class="line">        var pattern = new RegExp(&quot;.&quot;, &quot;u&quot;);</div><div class="line">        return true;</div><div class="line">    &#125; catch (ex) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="修饰符y"><a href="#修饰符y" class="headerlink" title="修饰符y"></a>修饰符y</h4><p>ES6新增了一个正则表达式扩展：修饰符y，主要是影响正则表达式搜索过程中的sticky属性；当在字符串开始匹配时，会通知搜索从正则表达式的lastIndex属性开始进行，如果在指定位置没能匹配成功，则停止继续匹配；看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">let text = &quot;hello1 hello2 hello3&quot;,</div><div class="line">    pattern = /hello\d\s?/,</div><div class="line">    result = pattern.exec(text),</div><div class="line">    globalPattern = /hello\d\s?/g,</div><div class="line">    globalResult = globalPattern.exec(text),</div><div class="line">    stickyPattern = /hello\d\s?/y,</div><div class="line">    stickyResult = stickyPattern.exec(text);</div><div class="line">console.log(result[0]);// &quot;hello1 &quot;</div><div class="line">console.log(globalResult[0]);// &quot;hello1 &quot;</div><div class="line">console.log(stickyResult[0]);// &quot;hello1 &quot;</div><div class="line">pattern.lastIndex = 1;</div><div class="line">globalPattern.lastIndex = 1;</div><div class="line">stickyPattern.lastIndex = 1;</div><div class="line"></div><div class="line">result = pattern.exec(text);</div><div class="line">globalResult = globalPattern.exec(text);</div><div class="line">stickyResult = stickyPattern.exec(text);</div><div class="line">console.log(result[0]); // &quot;hello1 &quot;</div><div class="line">console.log(globalResult[0]);// &quot;hello2 &quot;</div><div class="line">console.log(stickyResult[0]);// throws an error!</div></pre></td></tr></table></figure>
<p>当指定lastIndex设置为1的时候，stickyPattern没有匹配成功，stickyResult返回null，<code>console.log(stickyResult[0])</code>就报错；</p>
<p>需要注意以下几点：</p>
<ol>
<li>y和g修饰符如果匹配失败，lastIndex会被重置为0；</li>
<li>y是<strong>严格</strong>从lastIndex开始匹配，而g从lastIndex匹配失败可以继续往后匹配；</li>
<li>只有调用exec和test这些正则表达式对象的方法时才会涉及lastIndex属性；调用字符串的方法是不会有效果的；</li>
</ol>
<p>检测是否支持y修饰符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function hasRegExpY() &#123;</div><div class="line">    try &#123;</div><div class="line">        var pattern = new RegExp(&quot;.&quot;, &quot;y&quot;);</div><div class="line">        return true;</div><div class="line">    &#125; catch (ex) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="正则表达式复制"><a href="#正则表达式复制" class="headerlink" title="正则表达式复制"></a>正则表达式复制</h4><p>ES5可以通过给RegExp构造函数传递正则表达式作为参数来复制这个表达式, 但是如果第二个参数传递修饰符参数则会报错；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var re1 = /ab/i</div><div class="line">var re2 = new RegExp(re1) //</div><div class="line">var re3 = new RegExp(re1, &apos;g&apos;) //报错</div></pre></td></tr></table></figure></p>
<p>ES6修改了这个行为，可以传递修饰符<code>var re4 = new RegExp(re1, &#39;g&#39;)</code>;但是会把之前的修饰符替换掉，re4变成了<code>/ab/g</code>.</p>
<h4 id="正则表达式flags属性"><a href="#正则表达式flags属性" class="headerlink" title="正则表达式flags属性"></a>正则表达式flags属性</h4><p>ES6在正则表达式中新增了flags属性，会输出正则的修饰符；如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let reg = /ab/igu;</div><div class="line">console.log(reg.flags); // &apos;igu&apos;</div><div class="line">console.log(reg.source); // &apos;ab&apos;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/11/2017-11-11-递归/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/11/2017-11-11-递归/" itemprop="url">递归</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-11T00:00:00+08:00">
                2017-11-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>// 留个坑 </p>
<p>减而治之 通过不断蚕食不断削减问题有效规模的策略</p>
<p>为求解一个大规模的问题，可以将其划分为若干（通常两个）子问题，规模大体相当，分别求解子问题，由子问题的解，得到原问题的解。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/06/2017-11-06-mediaSource/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/06/2017-11-06-mediaSource/" itemprop="url">MSE</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T00:00:00+08:00">
                2017-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/html5/" itemprop="url" rel="index">
                    <span itemprop="name">html5</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是MSE"><a href="#什么是MSE" class="headerlink" title="什么是MSE"></a>什么是MSE</h2><p>MSE是一个允许在支持html5-video的浏览器中发送字节流的w3c标准, 全称是Media Souce Extensions. </p>
<p><img src="/images/media_pipleline.svg" alt=""></p>
<h2 id="MSE来由"><a href="#MSE来由" class="headerlink" title="MSE来由"></a>MSE来由</h2><p>要先知道MSE的来由，先要知道没有MSE之前浏览器对video的支持情况。</p>
<p>Html5发布后浏览器支持video标签, 但是只是基本支持了播放一个完整单轨道，无法支持视频arraybuffer的分隔与组合；由于现在社会多媒体技术的发展，<br>人们对视频观看方式的需求日益剧增，如视频点播, 代表为国内的youku/souhu/iqiyi等视频网站，国外的youtube netflix hulu等；到现在的各种直播网站，<br>国内的斗鱼国外的twitch等；之前浏览器的video功能已经不能支持，所以MSE标准应运而生。</p>
<h2 id="MSE特点"><a href="#MSE特点" class="headerlink" title="MSE特点"></a>MSE特点</h2><p>MSE首先提供了MediaSource对象，作为一个容器，内部包含了一系列视频信息，如要被播放的media资源的状态, 指向组成播放流的多个轨道的SouceBuffer对象，<br>除此之外，MSE还提供了对视频内容获取的多少与速度的把控，以及一些内存的管理；</p>
<p>但是，MSE也有一些不足之处，因为浏览器处理视频解码转码方面性能消耗很大，这些功能只能放在浏览器之外处理，所以浏览器只接受主流的一些媒体格式，如<br>H.264 video codec, AAC audio codec, and MP4 container format; 还有一点就是各浏览器对MSE的支持程度不太一致，实现也有一些差别，导致现在html5播放器<br>在浏览器使用上没有普及开来，需要各方的协作.</p>
<h2 id="主要对象"><a href="#主要对象" class="headerlink" title="主要对象"></a>主要对象</h2><h4 id="1-MediaSouce"><a href="#1-MediaSouce" class="headerlink" title="1.MediaSouce"></a>1.MediaSouce</h4><p><strong>构造函数</strong></p>
<p>MediaSource() // 构造并且返回一个新的MediaSource的空对象</p>
<p><strong>属性</strong></p>
<p>MediaSource.sourceBuffers / MediaSource.activeSourceBuffers / MediaSource.readyState /MediaSource.duration</p>
<p><strong>方法</strong></p>
<p>MediaSource.addSourceBuffer() / MediaSource.removeSourceBuffer() / MediaSource.endOfStream() / MediaSource.isTypeSupported()</p>
<h4 id="2-SouceBuffer"><a href="#2-SouceBuffer" class="headerlink" title="2.SouceBuffer"></a>2.SouceBuffer</h4><p><strong>构造</strong></p>
<p>可以通过MediaSource.addSourceBuffer()来构造</p>
<p><strong>属性</strong></p>
<p>mode / updating / buffered / timestampOffset / audioTracks / videoTracks / textTracks / appendWindowStart / trackDefaults</p>
<p><strong>方法</strong></p>
<p>appendBuffer() / appendStream() / abort() / remove()</p>
<p><strong>事件</strong></p>
<p>onabort / onerror / onupdate / onupdateend / onupdatestart</p>
<h4 id="3-URL-Object-Extensions"><a href="#3-URL-Object-Extensions" class="headerlink" title="3.URL Object Extensions"></a>3.URL Object Extensions</h4><p><strong>构造方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var video = document.querySelector(&apos;#video&apos;)</div><div class="line">var m = new MediaSource</div><div class="line">var l = URL.createObjectURL(m)</div><div class="line">video.src = l</div></pre></td></tr></table></figure>
<h4 id="4-HTMLMediaElement-Extensions"><a href="#4-HTMLMediaElement-Extensions" class="headerlink" title="4.HTMLMediaElement Extensions"></a>4.HTMLMediaElement Extensions</h4><p>HTMLMediaElement.seekable -&gt;  normalized TimeRanges object</p>
<p>HTMLMediaElement.buffered -&gt;  normalized TimeRanges objec</p>
<h2 id="一个简单例子"><a href="#一个简单例子" class="headerlink" title="一个简单例子"></a>一个简单例子</h2><p>下面是从MDN上摘录下来的一个栗子, 这个栗子可以在<a href="https://github.com/nickdesaulniers/netfix/tree/gh-pages/demo" target="_blank" rel="external">这里</a>下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">var video = document.querySelector(&apos;video&apos;);</div><div class="line"></div><div class="line">var assetURL = &apos;frag_bunny.mp4&apos;;</div><div class="line">// Need to be specific for Blink regarding codecs</div><div class="line">// ./mp4info frag_bunny.mp4 | grep Codec</div><div class="line">var mimeCodec = &apos;video/mp4; codecs=&quot;avc1.42E01E, mp4a.40.2&quot;&apos;;</div><div class="line"></div><div class="line">if (&apos;MediaSource&apos; in window &amp;&amp; MediaSource.isTypeSupported(mimeCodec)) &#123;</div><div class="line">  var mediaSource = new MediaSource();</div><div class="line">  //console.log(mediaSource.readyState); // closed</div><div class="line">  video.src = URL.createObjectURL(mediaSource);</div><div class="line">  mediaSource.addEventListener(&apos;sourceopen&apos;, sourceOpen);</div><div class="line">&#125; else &#123;</div><div class="line">  console.error(&apos;Unsupported MIME type or codec: &apos;, mimeCodec);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function sourceOpen (_) &#123;</div><div class="line">  //console.log(this.readyState); // open</div><div class="line">  var mediaSource = this;</div><div class="line">  var sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);</div><div class="line">  fetchAB(assetURL, function (buf) &#123;</div><div class="line">    sourceBuffer.addEventListener(&apos;updateend&apos;, function (_) &#123;</div><div class="line">      mediaSource.endOfStream();</div><div class="line">      video.play();</div><div class="line">      //console.log(mediaSource.readyState); // ended</div><div class="line">    &#125;);</div><div class="line">    sourceBuffer.appendBuffer(buf);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function fetchAB (url, cb) &#123;</div><div class="line">  console.log(url);</div><div class="line">  var xhr = new XMLHttpRequest;</div><div class="line">  xhr.open(&apos;get&apos;, url);</div><div class="line">  xhr.responseType = &apos;arraybuffer&apos;;</div><div class="line">  xhr.onload = function () &#123;</div><div class="line">    cb(xhr.response);</div><div class="line">  &#125;;</div><div class="line">  xhr.send();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="相关库"><a href="#相关库" class="headerlink" title="相关库"></a>相关库</h2><ul>
<li><p><a href="https://github.com/Dash-Industry-Forum/dash.js" target="_blank" rel="external">dash.js</a></p>
</li>
<li><p><a href="https://github.com/video-dev/hls.js/" target="_blank" rel="external">hls.js</a></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/10/29/2017-10-19-JS之异步1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/29/2017-10-19-JS之异步1/" itemprop="url">JS之异步1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-29T00:00:00+08:00">
                2017-10-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h2><p>异步：一种通讯方式， 一个可以无需等待被调用函数的返回值就让操作继续进行的方法.</p>
<p>在操作系统中对设备的处理，很多就是利用异步来处理的；比如中断，计算机的网卡接受从网络中发过来的数据，如果让cpu一直轮询等待数据的传输完成，这个很费时间, 浪费cpu的效率，<br>在网卡接受网络数据的时候，可以让cpu自己先忙其他的，等网络数据接受完毕之后才让网卡发起一个中断请求让cpu介入进行处理；这就是异步。</p>
<h2 id="JS中的异步"><a href="#JS中的异步" class="headerlink" title="JS中的异步"></a>JS中的异步</h2><p>谈起JS的异步，就不得不说JS引擎是基于单线程事件循环的概念构建的。跟上面举的例子一样，为了让JS更有效率，响应更及时，JS中加入了异步。</p>
<p>JS引擎同一时刻只能执行一个代码块,所以需要跟踪即将运行的代码，那些代码被放在一个任务队列中，每当一段代码准备执行是，都会被添加到任务队列中。每当JS引擎中的一段代码执行结束时，<br>事件循环会执行队列中的下一个任务。如下图可示：</p>
<p><img src="/images/eventqueue.jpg" alt=""></p>
<p>JS中有哪些异步呢？</p>
<p>setTimeout(), setInterval(), ajax请求，dom事件这些都是JS中比较常见的异步.</p>
<h2 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h2><p>用户点击按钮或按下键盘上的按钮会触发类似onclick这样的事件，它会向任务队列添加一个新任务来响应用户的操作。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let button = document.getElementById(&quot;my-btn&quot;);</div><div class="line">button.onclick = function(event) &#123;</div><div class="line">    console.log(&quot;clicked&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这段代码中当按钮被点击的时候，会触发onclick事件，执行函数(clickFn)会被添加到任务队列中，当任务队列执行到clickFn的时候打印出clicked;</p>
<p>如下图:</p>
<p><img src="/images/eventstack.png" alt=""></p>
<p>事件模型适用于响应用户交互和完成类似的低频功能，但其对于更复杂的需求来说却不是很灵活。</p>
<h2 id="setTimeout与setInterval"><a href="#setTimeout与setInterval" class="headerlink" title="setTimeout与setInterval"></a>setTimeout与setInterval</h2><p>这两个区别不大，我们看一段代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">setTimeout(function() &#123;</div><div class="line">    console.log(&apos;settimeout&apos;);</div><div class="line">&#125;, 1000)</div><div class="line">var sTime = new Date().getTime();</div><div class="line">console.log(new Date());</div><div class="line">console.log(&apos;test1&apos;);</div><div class="line">while(new Date().getTime() - sTime &lt; 2000) &#123;</div><div class="line">&#125;</div><div class="line">console.log(new Date())</div></pre></td></tr></table></figure>
<p>执行结果显示打印出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Sun Oct 29 2017 20:24:29 GMT+0800 (CST)</div><div class="line">// test1</div><div class="line">// Sun Oct 29 2017 20:24:31 GMT+0800 (CST)</div><div class="line">// settimeout</div></pre></td></tr></table></figure>
<p>从中可以看出：</p>
<ol>
<li>先打印test1，setTimeout的确是异步过程，会在1秒后加入任务队列;</li>
<li>只有在任务队列中的前面任务执行完，才会执行加入的任务(这段代码是过了两秒);</li>
</ol>
<p>setTimeout也是一种异步的方式，但是不能很好的把控。</p>
<h2 id="回调模式"><a href="#回调模式" class="headerlink" title="回调模式"></a>回调模式</h2><p>回调模式与事件模式类似，只不过回调模式中被调用的函数是作为参数传入的，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fs.readFile(&apos;example.txt&apos;, function(err, contents) &#123;</div><div class="line">    if(err) &#123;</div><div class="line">        throw err;</div><div class="line">    &#125;</div><div class="line">    console.log(contents)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>文件example.txt读取完毕后会把回调加入任务队列中，如果此时任务队列为空，直接执行回调，如果不为空，等前面的任务执行完再执行回调；</p>
<p>但是这有一个问题，当我们的需求是，先读取文件1，然后需要把读出的文件1作为内容进行网络转发；那就会：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">fs.readFile(&apos;example.txt&apos;, function(err, contents) &#123;</div><div class="line">    if(err) &#123;</div><div class="line">        throw err;</div><div class="line">    &#125;;</div><div class="line">    console.log(contents);</div><div class="line">    ajax(&#123;</div><div class="line">        url: &apos;xxx.json&apos;</div><div class="line">        data: contents,</div><div class="line">        success: function() &#123;</div><div class="line">            doSomething()</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这样看起来还是，当时如果这样的需求是叠加的，那就可能会形成传说中的回调地狱了。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">fn1(function(err, result) &#123;</div><div class="line">    if(err) &#123;throw err;&#125;</div><div class="line"></div><div class="line">    fn2(function(err, result) &#123;</div><div class="line">        if(err) &#123;throw err;&#125;</div><div class="line"></div><div class="line">        fn3(function(err, result) &#123;</div><div class="line">            if(err) &#123;throw err;&#125;</div><div class="line"></div><div class="line">            fn4(function(err, result) &#123;</div><div class="line">                if(err) &#123;throw err;&#125;</div><div class="line">            &#125;)</div><div class="line">            ...</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>像上面这样嵌套多个方法调用，会创建出一堆难于理解和调试的代码。</p>
<h2 id="异步之生成器"><a href="#异步之生成器" class="headerlink" title="异步之生成器"></a>异步之生成器</h2><h4 id="生成器简单介绍"><a href="#生成器简单介绍" class="headerlink" title="生成器简单介绍"></a>生成器简单介绍</h4><p>有时间会深入讲述一下生成器，这里只是简单说一下生成器的概念。下面就是一个生成器函数的栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function *test() &#123; // 生成器函数</div><div class="line">    yield 1;</div><div class="line">    yield 2;</div><div class="line">&#125;</div><div class="line">var iter = test() // 迭代器</div></pre></td></tr></table></figure>
<p>上面就是一个简单的生成器函数，当执行会生成一个迭代器，迭代器可参考之前写过的一片文章谈谈遍历与迭代协议.</p>
<p>迭代器每次调用next方法会执行生成器函数，并且每次执行完yield关键词就停止，只在当下一次调用next的时候才回到之前执行停止的地方继续执行；</p>
<p>如若需要回调或者系列化一序列的异步操作，生成器和yield语句就派上用场了。</p>
<h4 id="生成器处理异步操作"><a href="#生成器处理异步操作" class="headerlink" title="生成器处理异步操作"></a>生成器处理异步操作</h4><p>任务处理器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">function run(taskDef) &#123;</div><div class="line">    let task = taskDef();      // 1.外层生成器函数执行  创建一个无使用限制的迭代器</div><div class="line"></div><div class="line">    let result = task.next(); // 2. 开始任务，执行到第一个yield</div><div class="line"></div><div class="line">    // 循环调用next</div><div class="line">    function step() &#123;</div><div class="line">        if(!result.done) &#123; // 3.判断是否迭代完毕（没有yield或者return）</div><div class="line">            if(typeof result.value === &apos;function&apos;) &#123; // 4.下面包裹函数return的函数</div><div class="line">                result.value(function(err, data) &#123; // 5.调用return的函数, 传入回调函数到callback</div><div class="line">                    if(err) &#123;</div><div class="line">                        result = task.throw(err);</div><div class="line">                        return;</div><div class="line">                    &#125;</div><div class="line">                    result = task.next(data); // 6.异步回调完，继续执行到下一个yield</div><div class="line">                    step(); // 7. 循环执行 </div><div class="line">                &#125;)</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            result = task.next(result.value);</div><div class="line">            step(); // 循环执行</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    step(); // 启动</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后把异步操作包裹起来，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let fs = require(&apos;sf&apos;);</div><div class="line"></div><div class="line">function readFile(filename) &#123;</div><div class="line">    return function(callback) &#123;</div><div class="line">        fs.readFile(filename, callback)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是最终的调用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">run(function *() &#123;</div><div class="line">    let contents = yield readFile(&apos;config.json&apos;);</div><div class="line">    doSomethingWith(contents);</div><div class="line">    yield readMoreFile(&apos;xxx.json&apos;);</div><div class="line">    console.log(&apos;Done&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这样就可以很好的解决回调地狱的问题了，并且把异步操作通过同步的形式来调用。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面谈了JS的异步，并分别讲了事件模型／setTimeout／回调模型，最后讲述了怎么用生成器来处理回调地狱，并可以用同步的操作方式.</p>
<p>上面这种处理形式还是比较麻烦，需要把异步函数包裹起来，并且无法区分用作任务执行器回调函数的返回值和一个不是回调函数的返回值。</p>
<p>这种方式在场景使用中还是有局限性，如果需求需要并行执行两个异步操作或者同时进行两个异步操作并且只取优先完成的操作；这种就不太好处理了，会在下一篇中讲述解决的办法.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/10/19/2017-10-19-mongo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/19/2017-10-19-mongo/" itemprop="url">mongo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-19T00:00:00+08:00">
                2017-10-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/sql/" itemprop="url" rel="index">
                    <span itemprop="name">sql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="what-is-mongo"><a href="#what-is-mongo" class="headerlink" title="what is mongo"></a>what is mongo</h2><p>MongoDB is  NoSQL database, NoSQL = not only sql.</p>
<p>And from wikipedia:</p>
<p><code>The term NoSQL was used by Carlo Strozzi in 1998 to name his lightweight, Strozzi NoSQL open-source relational database that did not expose the standard Structured Query Language (SQL) interface, but was still relational.[16] His NoSQL RDBMS is distinct from the circa-2009 general concept of NoSQL databases. Strozzi suggests that, because the current NoSQL movement &quot;departs from the relational model altogether, it should therefore have been called more appropriately &#39;NoREL&#39;,[17] referring to &#39;No Relational&#39;.</code></p>
<p>MongoDB is document database:</p>
<ul>
<li>not .PDF or .DOC/.DOCX</li>
<li>is a associative array</li>
<li>document == json object</li>
<li>document == php array</li>
<li>document == python dict</li>
<li>document == ruby hash</li>
</ul>
<h2 id="Why-mongo"><a href="#Why-mongo" class="headerlink" title="Why mongo"></a>Why mongo</h2><ul>
<li>flexible schema</li>
<li>oriented toward programmers</li>
<li>flexible deployment</li>
<li>designed for big data</li>
</ul>
<h2 id="Install-mongo"><a href="#Install-mongo" class="headerlink" title="Install mongo"></a>Install mongo</h2><p>mac: <code>brew intall mongo</code></p>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>We can use PyMongo to communicate with mongo in python.</p>
<p>Use <code>pip install PyMongo</code> command to install PyMongo.</p>
<p>And:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from pymongo import MongoClient</div><div class="line">client = MongoClient(&apos;localhost:27017&apos;)</div><div class="line">db = client[db_name]</div></pre></td></tr></table></figure>
<p>So now we can use db to read/create/update/delete the data.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/10/10/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/10/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-10T23:04:28+08:00">
                2017-10-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/10/01/2017-10-01-从尺寸单位到移动端适配方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/01/2017-10-01-从尺寸单位到移动端适配方案/" itemprop="url">从尺寸单位到移动端适配方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-01T00:00:00+08:00">
                2017-10-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/css/" itemprop="url" rel="index">
                    <span itemprop="name">css</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="css尺寸单位"><a href="#css尺寸单位" class="headerlink" title="css尺寸单位"></a>css尺寸单位</h2><h4 id="绝对单位"><a href="#绝对单位" class="headerlink" title="绝对单位"></a>绝对单位</h4><p>在平常的前端开发中，在很多地方写css的时候，你都会用到长度尺寸单位，可能最典型的代表就是px；<br>其实这些单位主要分两类，绝对单位和相对单位；px就属于绝对单位，除了px之外，其他的你可能都很<br>少使用,如下：</p>
<ul>
<li>mm, cm, in: 毫米（Millimeters），厘米（centimeters），英寸（inches）</li>
<li>pt, pc: 点（Points (1/72 of an inch)）， 十二点活字（ picas (12 points.)）</li>
</ul>
<h4 id="相对单位"><a href="#相对单位" class="headerlink" title="相对单位"></a>相对单位</h4><p>上面列举的主要是绝对单位，那相对单位是啥呢，顾名思义，相对单位就是基于某些参考物的单位；主要有：</p>
<ul>
<li>ex, ch: 分别是小写x的高度和数字0的宽度；</li>
<li>em, rem: em和rem都是基于<code>font-size</code>的单位，但又有所不同，em是基于当前元素的<code>font-size</code>为参考物<br>的(如果当前font-size没有设置，就基于父元素，以此类推); rem是基于根元素为参考物，如果根元素没有设置，<br>大多数浏览器默认为16px；假如参考物的<code>font-size: 20px</code>, 那么<code>1em=20px</code>, <code>1.5rem=30px</code>;</li>
<li>vw, vh, vmin, vmax: 这组单位都是基于视口为参考物，vw基于视口的宽度，vh基于视口的高度，vmin=min(vw, vh),<br>vmax=max(vw,vh)</li>
</ul>
<h2 id="在移动端的使用"><a href="#在移动端的使用" class="headerlink" title="在移动端的使用"></a>在移动端的使用</h2><p>目前市面的手机品类繁多，屏幕分辨率也各有不同，导致移动端开发难度加大，我们怎么开发来适配不同的手机？</p>
<h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p>以iphone三种尺寸手机为例: iphone4(320px),iphone6(375px),iphone6 plus(414px);</p>
<p>普通的做法是根据不同比例的尺寸来等比例<br>缩放，例如iphone4文本大小是12px，那么iphone6就是<code>（375/320*12px=14px）</code>,iphone6 plus就是<code>（414/320*12px=15.5px）</code>;</p>
<p>最开始的方法： 以一款尺寸做一版样式，然后用js去控制viewpoint的intial-scale(网页缩放比例); 天猫最初站点就是用这种<br>方法来进行移动端的开发的，这样有些不好的地方，如手机为大屏幕的时候图片文字会拉伸，导致页面模糊,在某些布局在不同<br>尺寸的屏幕也有可能导致布局错乱；</p>
<p>为了最好的适配不同的手机尺寸，目前最普遍的做法就是应用到上一节说到的相对单位rem; </p>
<h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>先来看看rem的兼容性：</p>
<p><img src="/images/caniuse.png" alt="caniuse"></p>
<p>从图中可以看出兼容性还是很不错的，大部分市面上主流浏览器都支持,我们可以比较放心的使用；</p>
<p>rem官方文档上<a href="https://www.w3.org/TR/css3-values/#rem的解释是：" target="_blank" rel="external">https://www.w3.org/TR/css3-values/#rem的解释是：</a></p>
<p><i>rem unit</i></p>
<p><code>rem unit
Equal to the computed value of font-size on the root element. When specified on the font-size property of the root element, the rem units refer to the property’s initial value.</code></p>
<p>实际就是根据根元素来设置字体大小，然后其他设置了rem单位的就是利用这个来进行同等的变换；</p>
<h2 id="适配实现方案"><a href="#适配实现方案" class="headerlink" title="适配实现方案"></a>适配实现方案</h2><h4 id="方案1-动态添加html样式"><a href="#方案1-动态添加html样式" class="headerlink" title="方案1 - 动态添加html样式"></a>方案1 - 动态添加html样式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">   var b = document.documentElement;</div><div class="line">   var a = document.createElement(&quot;style&quot;);</div><div class="line">   a.innerHTML = &quot;html &#123; font-size: &quot; + ((b.clientWidth &gt; 640 ? 640 : b.clientWidth) / 18.75) + &quot;px !important; &#125;&quot;;</div><div class="line">   b.firstElementChild.appendChild(a)</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h4 id="方案2-利用media-query来设置"><a href="#方案2-利用media-query来设置" class="headerlink" title="方案2 - 利用media query来设置"></a>方案2 - 利用media query来设置</h4><p>利用css的media query也是可以来实现font-size的设置，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@media (min-device-width : 375px) and (max-device-width : 667px) and (-webkit-min-device-pixel-ratio : 2)&#123;</div><div class="line">      html&#123;font-size: 37.5px;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="方案3-js动态设置"><a href="#方案3-js动态设置" class="headerlink" title="方案3 - js动态设置"></a>方案3 - js动态设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.getElementsByTagName(&apos;html&apos;)[0].style.fontSize = window.innerWidth / 10 + &apos;px&apos;;</div></pre></td></tr></table></figure>
<h2 id="rem解决方案升级"><a href="#rem解决方案升级" class="headerlink" title="rem解决方案升级"></a>rem解决方案升级</h2><p>上面几个方案我们就实现了动态设置font-size并根据rem实现移动端不同尺寸的适配；</p>
<p>但适用rem的方案还是有不足的地方的：</p>
<ol>
<li><p>大屏幕伸缩之后可能导致页面模糊</p>
</li>
<li><p>设计稿里面的px都要转换成rem</p>
</li>
</ol>
<p>如何解决这些问题呢？</p>
<p>提供高分辨率设计稿，一般采用的是宽度为750px的设计稿，刚好是375的两倍，并利用sass实现一个函数功能<br>为提供直接px到rem的转换;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@function px2rem($px)&#123;</div><div class="line">    $rem : 75px;</div><div class="line">    @return ($px/$rem) + rem;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>设置基准font-size为75，传入参数px大小直接计算出rem的大小；</p>
<p>这样我们就可以完全按照视觉稿上的尺寸来了, 不用除于2了，就解决了图片高清问题，并且不用手动转换单位；</p>
<p>不过rem不是万能的，也还是具有不足之处的,如：</p>
<ol>
<li><p>一个App里native界面和Web界面混合使用时，rem在不同尺寸屏幕上的适配与native界面适配不一致;</p>
</li>
<li><p>rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致, 有些并不是理想的按照不同大小进行等比例缩放；</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文我们一开始先讲了css尺寸单位，包括绝对单位与相对单位，并详细讲述了em和rem；接下来讲述了rem在现代<br>移动端开发的应用，最后讲述了rem的几种应用方案与不足之处；</p>
<p>最后祝大家双节快乐，祖国越来越强大！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/09/07/2017-09-07-谈谈遍历与迭代协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/07/2017-09-07-谈谈遍历与迭代协议/" itemprop="url">谈谈遍历与迭代协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-07T00:00:00+08:00">
                2017-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="谈谈遍历与迭代"><a href="#谈谈遍历与迭代" class="headerlink" title="谈谈遍历与迭代"></a>谈谈遍历与迭代</h1><p>其实遍历与迭代是意义很近的一组词，但为啥要要把它们都列出来呢？先要从遍历说起：</p>
<h2 id="遍历在js中的形式"><a href="#遍历在js中的形式" class="headerlink" title="遍历在js中的形式"></a>遍历在js中的形式</h2><h4 id="The-for-loop"><a href="#The-for-loop" class="headerlink" title="The for loop"></a>The for loop</h4><p><code>for</code>循环是最普遍的遍历方式, 下面是一个简单的栗子；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];</div><div class="line"></div><div class="line">for (let i = 0; i &lt; digits.length; i++) &#123;</div><div class="line">  console.log(digits[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>for循环的不足之处就是必须维护计数器i与退出条件<code>digits.length</code>, 对刚学习编程的人来说，<br>这可能有点困惑，不能一眼看出这是在做啥；</p>
<p>还有一点是<code>for</code>循环很适合数组类型，但是<code>js</code>不只是只有数组类型，因此<code>for</code>循环不是一个所有类型的解决方案.</p>
<h4 id="The-for…in-loop"><a href="#The-for…in-loop" class="headerlink" title="The for…in loop"></a>The for…in loop</h4><p><code>for...in</code>循环优化了for循环的不足之处-需要维护计数器的变化与退出条件；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];</div><div class="line"></div><div class="line">for (const index in digits) &#123;</div><div class="line">  console.log(digits[index]);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>并且这对对象也是适用的，但是这个遍历方式也有一些问题:</p>
<p>正如上面<code>code</code>中，遍历的是计数器，当需要每个<code>value</code>值的时候，需要重新取值<code>digits[index]</code>;</p>
<p>并且for…in会把所有的可枚举属性遍历出来，如增加到原型链上的方法，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Array.prototype.decimalfy = function() &#123;</div><div class="line">  for (let i = 0; i &lt; this.length; i++) &#123;</div><div class="line">    this[i] = this[i].toFixed(2);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];</div><div class="line"></div><div class="line">for (const index in digits) &#123;</div><div class="line">  console.log(digits[index]);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 输出</div><div class="line">// 0 1 2 3 4 5 6 7 8 9 </div><div class="line">/*</div><div class="line">function() &#123;</div><div class="line"> for (let i = 0; i &lt; this.length; i++) &#123;</div><div class="line">  this[i] = this[i].toFixed(2);</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>这也是for…in没有在js程序员中普遍流行的原因;</p>
<blockquote>
<p>注意：forEach方法也是js遍历数组的一种方法，forEach实际上是一个数组方法，因而一般<br>适用在数组上，并且没有方法跳出循环；</p>
</blockquote>
<h4 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h4><p>直接看一个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(let v of &apos;hello&apos;)&#123;</div><div class="line">    console.log(v);</div><div class="line">&#125;</div><div class="line">// h e l l o</div></pre></td></tr></table></figure></p>
<p>for…of是针对<em>集合</em>(注意:非set而是collections)，而不是所有的对象，适用范围是iterable对象；</p>
<p>什么是iterable对象？</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>程序员是一群不停折腾的物种，为了更加方便的遍历，在ES6引入了迭代协议；迭代协议有两种：</p>
<ul>
<li>iterable协议</li>
<li>iterator协议</li>
</ul>
<p>由于这次主题是讲遍历与迭代，所以只涉及第一种协议; </p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>什么是iterable, ECMA官方文档是如下定义的：</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>[Symbol.iterator]</td>
<td>A zero arguments function that returns an object, conforming to the iterator protocol.</td>
<td></td>
</tr>
</tbody>
</table>
<p>也就是说只要具有[Symbol.iterator]属性，并且其值是一个0参数函数，这个函数执行返回的是一个符合iterator协议的对象,<br>符合上述条件的对象就是一个可迭代对象；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = []</div><div class="line">typeof a[Symbol.iterator] // function</div><div class="line">a[Symbol.iterator]() // Array Iterator &#123;&#125;</div></pre></td></tr></table></figure>
<h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h4><p>目前JS内置的可迭代对象有String, Array, Map, Set, TypedArray, arguments等；需要注意的是普通的obj是不能迭代的；</p>
<h4 id="几个用法"><a href="#几个用法" class="headerlink" title="几个用法"></a>几个用法</h4><p>遍历：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var someString = &apos;hi&apos;;</div><div class="line">for(let v of something) &#123;</div><div class="line">    console.log(v);</div><div class="line">&#125;</div><div class="line">// h i</div></pre></td></tr></table></figure>
<p>适用于元素展开:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var set1 = new Set([0, 1, 2]);</div><div class="line">var set2 = new Set([2, 3, 4, 5]);</div><div class="line">var arr = [...set1, ...set2]; // [0, 1, 2, 2, 3, 4, 5]</div></pre></td></tr></table></figure></p>
<p>转换数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Array.from(new Set([&apos;a&apos;, 1, &apos;b&apos;, 2]))</div></pre></td></tr></table></figure></p>
<p>转换成生成器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3];</div><div class="line">var iter = arr[Symbol.iterator]();</div><div class="line">iter.next(); // &#123;value: 1, done: false&#125;</div><div class="line">iter.next(); // &#123;value: 2, done: false&#125;</div><div class="line">iter.next(); // &#123;value: 3, done: false&#125;</div><div class="line">iter.next(); // &#123;value: undefined, done: true&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2016/02/21/linkedList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/21/linkedList/" itemprop="url">leetcode之linked list</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-21T00:00:00+08:00">
                2016-02-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="链表javascript实现"><a href="#链表javascript实现" class="headerlink" title="链表javascript实现"></a>链表javascript实现</h2><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺<br>序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度<br>分别是O(logn)和O(1)。</p>
<p>javascript实现可以通过下面的方法：</p>
<pre><code>function ListNode(val) {
    this.val = val;
    this.next = null;
}
</code></pre><p>下面我们看看链表题目的基本类型:</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除的题目有19, 83, 203, 237, 82</p>
<p>删除其实就是找到要删除元素的前一个元素pre;</p>
<pre><code>pre.next = pre.next.next;
</code></pre><p>不过还有一种是假删除，找前一个元素比较麻烦，我们可以直接把要删除元素的下一个元素的值赋给当前删除，然后删除下一个元素；</p>
<pre><code>cur.val = cur.next.val;
cur.next = cur.next.next;
</code></pre><p>看一个典型例题<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="external">19. Remove Nth Node From End of List</a>:</p>
<p>Given a linked list, remove the nth node from the end of list and return its head.<br>For example,</p>
<pre><code>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.
After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.
</code></pre><p>这个题目我们可以通过设置两个变量，fast变量先走n步，然后fast和slow变量同时走，直到fast为null; 此时slow就是到达了倒数第n个元素，执行删除即可；代码如下：</p>
<pre><code>var removeNthFromEnd = function(head, n) {
    var left, before, right = head;
    left = before = {next: head}; 
    while (n--) right = right.next;
    while (right) {
        right = right.next;
        left = left.next;
    }
    left.next = left.next.next;
    return before.next;
};
</code></pre><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找题目有：160, 141, 142</p>
<p>我们来看看<a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="external">141. Linked List Cycle</a>，判断是否🈶️环，我们可以通过设置两个指针fast和slow，slow一次走一步，fast一次走两部，如果🈶️环，fast必定在环内追上slow；于是：</p>
<pre><code>var hasCycle = function(head) {
    var slow = head;
    var fast = head;

    while(fast &amp;&amp; fast.next) {
        fast = fast.next.next;
        slow = slow.next;
        if(fast === slow) {
            return true;
        }
    }
    return false;
};
</code></pre><h2 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h2><p>翻转题目有234，206，24，92，61</p>
<p><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="external">234. Palindrome Linked List</a>其实是一个判断是否是回文的题目，但是我们可以利用翻转来判断；</p>
<p>首先利用两个变量来找到中间点，然后分为两个链表，把后面的链表翻转过来，并同时遍历两个链表比较：</p>
<pre><code>var isPalindrome = function(head) {
    function reverse(curr) {
        var prev = null;
        var next;
        while(curr) {
            next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
    var fast = head;
    var slow = head;
    while(fast &amp;&amp; fast.next) {
        fast = fast.next.next;
        slow = slow.next;
    }
    if(fast) slow = slow.next;

    slow = reverse(slow);
    while(slow &amp;&amp; head.val === slow.val) {
        head = head.next;
        slow = slow.next;
    }
    return slow === null;
};
</code></pre><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>合并的题目有：21，328，86，148，2，92，143</p>
<p><a href="https://leetcode.com/problems/partition-list/" target="_blank" rel="external">86. Partition List</a>这个题目是让我们把指定元素后面的都小于它的元素放到指定元素前面去；</p>
<p>我们可以设置两个表头，遍历链表，把小于指定元素的链接到第一个表，反之，链接到第二个表，最后把第二个链表链接到第一个链表后面；</p>
<pre><code>var partition = function(head, x) {
    var hd1 = new ListNode(0);
    var hd2 = new ListNode(0);
    var p1 = hd1;
    var p2 = hd2;
    while(head) {
        if(head.val &lt; x) {
            p1.next = head;
            p1 = p1.next;
        } else {
            p2.next = head;
            p2 = p2.next;
        }
        head = head.next;
    }
    p2.next = null;
    p1.next = hd2.next;
    return hd1.next;
};
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实链表的操作就是那几种：删除／查找／翻转／合并, 只要掌握链表的基本操作并配合标记或者特定题目的一些特性，基本都可以解决；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/12/27/DiveIntoJs_core/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/27/DiveIntoJs_core/" itemprop="url">深入理解Javascript： JavaScript核心</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-27T00:00:00+08:00">
                2015-12-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近本来准备把JS的对象、类、原型继承、作用域链、闭包以及this都写一下的，发现一篇文章写的太好了，就直接转载过来。</p>
<p>作者: JeremyWei | 可以转载, 但必须以超链接形式标明文章原始出处和作者信息及版权声明</p>
<p>网址: <a href="http://weizhifeng.net/javascript-the-core.html" target="_blank" rel="external">http://weizhifeng.net/javascript-the-core.html</a></p>
<p>最原始地址：<a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/" target="_blank" rel="external">http://dmitrysoshnikov.com/ecmascript/javascript-the-core/</a></p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><p>这篇文章是「深入ECMA-262-3」系列的一个概览和摘要。每个部分都包含了对应章节的链接，所以你可以阅读它们以便对其有更深的理解。</p>
<p>面向读者：经验丰富的程序员，专家。</p>
<p>我们以思考对象的概念做为开始，这是ECMAScript的基础。</p>
<h2 id="1-对象"><a href="#1-对象" class="headerlink" title="1.对象"></a>1.对象</h2><p>ECMAScript做为一个高度抽象的面向对象语言，是通过对象来交互的。即使ECMAScript里边也有基本类型，但是，当需要的时候，它们也会被转换成对象。</p>
<pre><code>一个对象就是一个属性集合，并拥有一个独立的prototype（原型）对象。这个prototype可以是一个对象或者null。
</code></pre><p>让我们看一个关于对象的基本例子。一个对象的prototype是以内部的[[Prototype]]属性来引用的。但是，在示意图里边我们将会使用<code>__&lt;internal-property&gt;__</code>下划线标记来替代两个括号，对于prototype对象来说是：<code>__proto__</code>。</p>
<p>对于以下代码：</p>
<pre><code>var foo = {
  x: 10,
  y: 20
};
</code></pre><p>我们拥有一个这样的结构，两个明显的自身属性和一个隐含的<code>__proto__</code>属性，这个属性是对foo原型对象的引用：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/basic-object.png" alt="基本对象"></p>
<p>这些prototype有什么用？让我们以<em>原型链</em>（prototype chain）的概念来回答这个问题。</p>
<h2 id="2-原型链"><a href="#2-原型链" class="headerlink" title="2.原型链"></a>2.原型链</h2><p>原型对象也是简单的对象并且可以拥有它们自己的原型。如果一个原型对象的原型是一个非null的引用，那么以此类推，这就叫作<em>原型链</em>。</p>
<pre><code>原型链是一个用来实现继承和共享属性的有限对象链。
</code></pre><p>考虑这么一个情况，我们拥有两个对象，它们之间只有一小部分不同，其他部分都相同。显然，对于一个设计良好的系统，我们将会重用相似的功能/代码，而不是在每个单独的对象中重复它。在基于类的系统中，这个代码重用风格叫作类继承－你把相似的功能放入类 A中，然后类 B和类 C继承类 A，并且拥有它们自己的一些小的额外变动。</p>
<p>ECMAScript中没有类的概念。但是，代码重用的风格并没有太多不同（尽管从某些方面来说比基于类（class-based）的方式要更加灵活）并且通过<em>原型链</em>来实现。这种继承方式叫作<em>委托继承</em>(delegation based inheritance)（或者，更贴近ECMAScript一些，叫作<em>原型继承</em>(prototype based inheritance)）。</p>
<p>跟例子中的类A，B，C相似，在ECMAScript中你创建对象：a，b，c。于是，对象a中存储对象b和c中通用的部分。然后b和c只存储它们自身的额外属性或者方法。</p>
<pre><code>var a = {
  x: 10,
  calculate: function (z) {
    return this.x + this.y + z
  }
};

var b = {
  y: 20,
  __proto__: a
};

var c = {
  y: 30,
  __proto__: a
};

// call the inherited method
b.calculate(30); // 60
c.calculate(40); // 80
</code></pre><p>足够简单，是不是？我们看到b和c访问到了在对象a中定义的<code>calculate</code>方法。这是通过原型链实现的。</p>
<p>规则很简单：如果一个属性或者一个方法在对象<em>自身</em>中无法找到（也就是对象自身没有一个那样的属性），然后它会尝试在原型链中寻找这个属性/方法。如果这个属性在原型中没有查找到，那么将会查找这个原型的原型，以此类推，遍历整个原型链（当然这在类继承中也是一样的，当解析一个继承的方法的时候－我们遍历<em>class链</em>（ class chain））。第一个被查找到的同名属性/方法会被使用。因此，一个被查找到的属性叫作<em>继承</em>属性。如果在遍历了整个原型链之后还是没有查找到这个属性的话，返回<code>undefined</code>值。</p>
<p>注意，继承方法中所使用的this的值被设置为<em>原始对象</em>，而并不是在其中查找到这个方法的（原型）对象。也就是，在上面的例子中<code>this.y</code>取的是b和c中的值，而不是a中的值。但是，<code>this.x</code>是取的是a中的值，并且又一次通过<em>原型链</em>机制完成。</p>
<p>如果没有明确为一个对象指定原型，那么它将会使用<strong>proto</strong>的默认值－<code>Object.prototype。Object.prototype</code>对象自身也有一个<code>__proto__</code>属性，这是原型链的<em>终点</em>并且值为null。</p>
<p>下一张图展示了对象a，b，c之间的继承层级：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/prototype-chain.png" alt="原型链"></p>
<p>注意： ES5标准化了一个实现原型继承的可选方法，即使用<code>Object.create</code>函数：</p>
<pre><code>var b = Object.create(a, {y: {value: 20}});
var c = Object.create(a, {y: {value: 30}});
</code></pre><p>你可以在对应的章节获取到更多关于ES5新API的信息。 ES6标准化了 <code>__proto__</code>属性，并且可以在对象初始化的时候使用它。</p>
<p>通常情况下需要对象拥有<em>相同或者相似的状态结构</em>（也就是相同的属性集合），赋以不同的状态值。在这个情况下我们可能需要使用<em>构造函数</em>(constructor function)，其以<em>指定的模式</em>来创造对象。</p>
<h2 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3.构造函数"></a>3.构造函数</h2><p>除了以指定模式创建对象之外，<em>构造函数</em>也做了另一个有用的事情－<em>它自动地为新创建的对象设置一个原型对象</em>。这个原型对象存储在<code>ConstructorFunction.prototype</code>属性中。</p>
<p>换句话说，我们可以使用构造函数来重写上一个拥有对象b和对象c的例子。因此，对象a（一个原型对象）的角色由<code>Foo.prototype</code>来扮演：</p>
<pre><code>// a constructor function
function Foo(y) {
  // which may create objects
  // by specified pattern: they have after
  // creation own &quot;y&quot; property
  this.y = y;
}

// also &quot;Foo.prototype&quot; stores reference
// to the prototype of newly created objects,
// so we may use it to define shared/inherited
// properties or methods, so the same as in
// previous example we have:

// inherited property &quot;x&quot;
Foo.prototype.x = 10;

// and inherited method &quot;calculate&quot;
Foo.prototype.calculate = function (z) {
  return this.x + this.y + z;
};

// now create our &quot;b&quot; and &quot;c&quot;
// objects using &quot;pattern&quot; Foo
var b = new Foo(20);
var c = new Foo(30);

// call the inherited method
b.calculate(30); // 60
c.calculate(40); // 80

// let&apos;s show that we reference
// properties we expect

console.log(

  b.__proto__ === Foo.prototype, // true
  c.__proto__ === Foo.prototype, // true

  // also &quot;Foo.prototype&quot; automatically creates
  // a special property &quot;constructor&quot;, which is a
  // reference to the constructor function itself;
  // instances &quot;b&quot; and &quot;c&quot; may found it via
  // delegation and use to check their constructor

  b.constructor === Foo, // true
  c.constructor === Foo, // true
  Foo.prototype.constructor === Foo // true

  b.calculate === b.__proto__.calculate, // true
  b.__proto__.calculate === Foo.prototype.calculate // true

);
</code></pre><p>这个代码可以表示为如下关系：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/constructor-proto-chain.png" alt="constructor-proto-chain"></p>
<p>这张图又一次说明了每个对象都有一个原型。构造函数Foo也有自己的<code>__proto__</code>，值为<code>Function.prototype</code>，<code>Function.prototype</code>也通过其<code>__proto__</code>属性关联到<code>Object.prototype</code>。因此，重申一下，<code>Foo.prototype</code>就是Foo的一个明确的属性，指向对象b和对象c的原型。</p>
<p>正式来说，如果思考一下<em>分类</em>的概念（并且我们已经对Foo进行了<em>分类</em>），那么构造函数和原型对象合在一起可以叫作「类」。实际上，举个例子，Python的第一级（first-class）动态类（dynamic classes）显然是以同样的属性/方法处理方案来实现的。从这个角度来说，Python中的类就是ECMAScript使用的委托继承的一个语法糖。</p>
<p>注意: 在ES6中「类」的概念被标准化了，并且实际上以一种构建在构造函数上面的语法糖来实现，就像上面描述的一样。从这个角度来看原型链成为了类继承的一种具体实现方式：</p>
<pre><code>// ES6
class Foo {
  constructor(name) {
    this._name = name;
  }

  getName() {
    return this._name;
  }
}

class Bar extends Foo {
  getName() {
    return super.getName() + &apos; Doe&apos;;
  }
}

var bar = new Bar(&apos;John&apos;);
console.log(bar.getName()); // John Doe
</code></pre><p>有关这个主题的完整、详细的解释可以在ES3系列的第七章找到。分为两个部分：<a href="http://dmitrysoshnikov.com/ecmascript/chapter-7-1-oop-general-theory/" target="_blank" rel="external">7.1 面向对象.基本理论</a>，在那里你将会找到对各种面向对象范例、风格的描述以及它们和ECMAScript之间的对比，然后在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-7-2-oop-ecmascript-implementation/" target="_blank" rel="external">7.2 面向对象.ECMAScript实现</a>，是对ECMAScript中面向对象的介绍。</p>
<p>现在，在我们知道了对象的基础之后，让我们看看<em>运行时程序的执行</em>（runtime program execution）在ECMAScript中是如何实现的。这叫作<em>执行上下文栈</em>（execution context stack），其中的每个元素也可以抽象成为一个对象。是的，ECMAScript几乎在任何地方都和对象的概念打交道;)</p>
<h2 id="4-执行上下文堆栈"><a href="#4-执行上下文堆栈" class="headerlink" title="4.执行上下文堆栈"></a>4.执行上下文堆栈</h2><p>这里有三种类型的ECMAScript代码：<em>全局代码</em>、<em>函数代码</em>和<em>eval代码</em>。每个代码是在其<em>执行上下文</em>（execution context）中被求值的。这里只有一个全局上下文，可能有多个函数执行上下文以及<em>eval</em>执行上下文。对一个函数的每次调用，会进入到函数执行上下文中，并对函数代码类型进行求值。每次对<code>eval</code>函数进行调用，会进入<em>eval</em>执行上下文并对其代码进行求值。</p>
<p>注意，一个函数可能会创建无数的上下文，因为对函数的每次调用（即使这个函数递归的调用自己）都会生成一个具有新状态的上下文：</p>
<pre><code>function foo(bar) {}

// call the same function,
// generate three different
// contexts in each call, with
// different context state (e.g. value
// of the &quot;bar&quot; argument)

foo(10);
foo(20);
foo(30);
</code></pre><p>一个执行上下文可能会触发另一个上下文，比如，一个函数调用另一个函数（或者在全局上下文中调用一个全局函数），等等。从逻辑上来说，这是以栈的形式实现的，它叫作<em>执行上下文栈</em>。</p>
<p>一个触发其他上下文的上下文叫作<em>caller</em>。被触发的上下文叫作<em>callee</em>。callee在同一时间可能是一些其他callee的caller（比如，一个在全局上下文中被调用的函数，之后调用了一些内部函数）。</p>
<p>当一个caller触发（调用）了一个callee，这个caller会暂缓自身的执行，然后把控制权传递给callee。这个callee被push到栈中，并成为一个运行中（活动的）执行上下文。在callee的上下文结束后，它会把控制权返回给caller，然后caller的上下文继续执行（它可能触发其他上下文）直到它结束，以此类推。callee可能简单的返回或者由于异常而退出。一个抛出的但是没有被捕获的异常可能退出（从栈中pop）一个或者多个上下文。</p>
<p>换句话说，所有ECMAScript<em>程序的运行时</em>可以用<em>执行上下文（EC）栈</em>来表示，<em>栈顶</em>是当前<em>活跃</em>(active)上下文：</p>
<p>当程序开始的时候它会进入<em>全局执行上下文</em>，此上下文位于<em>栈底</em>并且是栈中的<em>第一个元素</em>。然后全局代码进行一些初始化，创建需要的对象和函数。在全局上下文的执行过程中，它的代码可能触发其他（已经创建完成的）函数，这些函数将会进入它们自己的执行上下文，向栈中push新的元素，以此类推。当初始化完成之后，运行时系统（runtime system）就会等待一些<em>事件</em>（比如，用户鼠标点击），这些事件将会触发一些函数，从而进入新的执行上下文中。</p>
<p>在下个图中，拥有一些函数上下文<code>EC1</code>和全局上下文<code>Global EC</code>，当EC1进入和退出全局上下文的时候下面的栈将会发生变化：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/ec-stack-changes.png" alt="ec-stack-changes"></p>
<p>这就是ECMAScript的运行时系统如何真正地管理代码执行的。</p>
<p>更多有关ECMAScript中执行上下文的信息可以在对应的<a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/" target="_blank" rel="external">第一章 执行上下文</a>中获取。</p>
<p>像我们所说的，栈中的每个执行上下文都可以用一个对象来表示。让我们来看看它的结构以及一个上下文到底需要什么<em>状态</em>（什么属性）来执行它的代码。</p>
<h2 id="5-执行上下文"><a href="#5-执行上下文" class="headerlink" title="5.执行上下文"></a>5.执行上下文</h2><p>一个执行上下文可以抽象的表示为一个简单的对象。每一个执行上下文拥有一些属性（可以叫作<em>上下文状态</em>）用来跟踪和它相关的代码的执行过程。在下图中展示了一个上下文的结构：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/execution-context.png" alt="execution-context"></p>
<p>除了这三个必需的属性（一个<em>变量对象</em>（variable objec），一个<em>this</em>值以及一个<em>作用域链</em>（scope chain））之外，执行上下文可以拥有任何附加的状态，这取决于实现。</p>
<p>让我们详细看看上下文中的这些重要的属性。</p>
<h2 id="6-变量对象"><a href="#6-变量对象" class="headerlink" title="6.变量对象"></a>6.变量对象</h2><pre><code>变量对象是与执行上下文相关的数据作用域。它是一个与上下文相关的特殊对象，其中存储了在上下文中定义的变量和函数声明。
</code></pre><p>注意，<em>函数表达式</em>（与<em>函数声明</em>相对）不包含在变量对象之中。</p>
<p>变量对象是一个抽象概念。对于不同的上下文类型，在物理上，是使用不同的对象。比如，在全局上下文中变量对象就是<em>全局对象本身</em>（这就是为什么我们可以通过全局对象的属性名来关联全局变量）。</p>
<p>让我们在全局执行上下文中考虑下面这个例子：</p>
<pre><code>var foo = 10;

function bar() {} // function declaration, FD
(function baz() {}); // function expression, FE

console.log(
  this.foo == foo, // true
  window.bar == bar // true
);

console.log(baz); // ReferenceError, &quot;baz&quot; is not defined
</code></pre><p>之后，全局上下文的变量对象（variable objec，简称VO）将会拥有如下属性：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/variable-object.png" alt="variable-object"></p>
<p>再看一遍，函数<code>baz</code>是一个<em>函数表达式</em>，没有被包含在变量对象之中。这就是为什么当我们想要在函数自身之外访问它的时候会出现<code>ReferenceError</code>。</p>
<p>注意，与其他语言（比如C/C++）相比，在ECMAScript中只有函数可以创建一个新的作用域。在函数作用域中所定义的变量和内部函数在函数外边是不能直接访问到的，而且并不会污染全局变量对象。</p>
<p>使用<code>eval</code>我们也会进入一个新的（eval类型）执行上下文。无论如何，<code>eval</code>使用全局的变量对象或者使用caller（比如<code>eval</code>被调用时所在的函数）的变量对象。</p>
<p>那么函数和它的变量对象是怎么样的？在函数上下文中，变量对象是以<em>活动对象</em>（activation object）来表示的。</p>
<h2 id="7-活动对象"><a href="#7-活动对象" class="headerlink" title="7.活动对象"></a>7.活动对象</h2><p>当一个函数被caller所<em>触发</em>（被调用），一个特殊的对象，叫作<em>活动对象</em>（activation object）将会被创建。这个对象中包含<em>形参</em>和那个特殊的<code>arguments对象</code>（是对形参的一个映射，但是值是通过索引来获取）。<em>活动对象</em>之后会做为函数上下文的<em>变量对象</em>来使用。</p>
<p>换句话说，函数的变量对象也是一个同样简单的变量对象，但是除了变量和函数声明之外，它还存储了形参和<code>arguments对象</code>，并叫作<em>活动对象</em>。</p>
<p>考虑如下例子：</p>
<pre><code>function foo(x, y) {
  var z = 30;
  function bar() {} // FD
  (function baz() {}); // FE
}

foo(10, 20);
</code></pre><p>我们看下函数foo的上下文中的活动对象（activation object，简称AO）：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/activation-object.png" alt="activation-object"></p>
<p>并且<em>函数表达式</em><code>baz</code>还是没有被包含在变量/活动对象中。</p>
<p>关于这个主题所有细节方面（像变量和函数声明的<em>提升问题</em>（hoisting））的完整描述可以在同名的章节<a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/" target="_blank" rel="external">第二章 变量对象</a>中找到。</p>
<p>注意，在ES5中<em>变量对象</em>和<em>活动对象</em>被并入了<em>词法环境</em>模型（lexical environments model），详细的描述可以在<a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/" target="_blank" rel="external">对应的章节</a>找到。</p>
<p>然后我们向下一个部分前进。众所周知，在ECMAScript中我们可以使用<em>内部函数</em>，然后在这些内部函数我们可以引用父函数的变量或者全局上下文中的变量。当我们把变量对象命名为上下文的<em>作用域对象</em>，与上面讨论的原型链相似，这里有一个叫作<em>作用域链</em>的东西。</p>
<h2 id="8-作用域链"><a href="#8-作用域链" class="headerlink" title="8.作用域链"></a>8.作用域链</h2><pre><code>作用域链是一个对象列表，上下文代码中出现的标识符在这个列表中进行查找。
</code></pre><p>这个规则还是与原型链同样简单以及相似：如果一个变量在函数自身的作用域（在自身的变量/活动对象）中没有找到，那么将会查找它父函数（外层函数）的变量对象，以此类推。</p>
<p>就上下文而言，标识符指的是：<em>变量名称，函数声明，形参</em>，等等。当一个函数在其代码中引用一个不是局部变量（或者局部函数或者一个形参）的标识符，那么这个标识符就叫作<em>自由变量</em>。<em>搜索这些自由变量</em>(free variables)正好就要用到<em>作用域链</em>。</p>
<p>在通常情况下，<em>作用域链</em>是一个包含所有<em>父（函数）变量对象</em>__加上（在作用域链头部的）函数<em>自身变量/活动对象</em>的一个列表。但是，这个作用域链也可以包含任何其他对象，比如，在上下文执行过程中动态加入到作用域链中的对象－像<em>with对象</em>或者特殊的<em>catch从句</em>（catch-clauses）对象。</p>
<p>当<em>解析</em>（查找）一个标识符的时候，会从作用域链中的活动对象开始查找，然后（如果这个标识符在函数自身的活动对象中没有被查找到）向作用域链的上一层查找－重复这个过程，就和原型链一样。</p>
<pre><code>var x = 10;

(function foo() {
  var y = 20;
  (function bar() {
    var z = 30;
    // &quot;x&quot; and &quot;y&quot; are &quot;free variables&quot;
    // and are found in the next (after
    // bar&apos;s activation object) object
    // of the bar&apos;s scope chain
    console.log(x + y + z);
  })();
})();
</code></pre><p>我们可以假设通过隐式的<code>__parent__</code>属性来和作用域链对象进行关联，这个属性指向作用域链中的下一个对象。这个方案可能在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/#feature-of-implementations-property-__parent__" target="_blank" rel="external">真实的Rhino代码</a>中经过了测试，并且这个技术很明确得被用于ES5的词法环境中（在那里被叫作<code>outer</code>连接）。作用域链的另一个表现方式可以是一个简单的数组。利用<em><strong>parent</strong></em>概念，我们可以用下面的图来表现上面的例子（并且父变量对象存储在函数的[[Scope]]属性中）：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/scope-chain.png" alt="scope-chain"></p>
<p>在代码执行过程中，作用域链可以通过使用<code>with</code>语句和<code>catch</code>从句对象来增强。并且由于这些对象是简单的对象，它们可以拥有原型（和原型链）。这个事实导致作用域链查找变为<em>两个维度</em>：（1）首先是作用域链连接，然后（2）在每个作用域链连接上－深入作用域链连接的原型链（如果此连接拥有原型）。</p>
<p>对于这个例子：</p>
<pre><code>Object.prototype.x = 10;

var w = 20;
var y = 30;

// in SpiderMonkey global object
// i.e. variable object of the global
// context inherits from &quot;Object.prototype&quot;,
// so we may refer &quot;not defined global
// variable x&quot;, which is found in
// the prototype chain

console.log(x); // 10

(function foo() {

  // &quot;foo&quot; local variables
  var w = 40;
  var x = 100;

  // &quot;x&quot; is found in the
  // &quot;Object.prototype&quot;, because
  // {z: 50} inherits from it

  with ({z: 50}) {
    console.log(w, x, y , z); // 40, 10, 30, 50
  }

  // after &quot;with&quot; object is removed
  // from the scope chain, &quot;x&quot; is
  // again found in the AO of &quot;foo&quot; context;
  // variable &quot;w&quot; is also local
  console.log(x, w); // 100, 40

  // and that&apos;s how we may refer
  // shadowed global &quot;w&quot; variable in
  // the browser host environment
  console.log(window.w); // 20

})();
</code></pre><p>我们可以给出如下的结构（确切的说，在我们查找<code>__parent__</code>连接之前，首先查找<code>__proto__</code>链）：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/scope-chain-with.png" alt="scope-chain-with"></p>
<p>注意，不是在所有的实现中全局对象都是继承自<code>Object.prototype</code>。上图中描述的行为（从全局上下文中引用「未定义」的变量x）可以在诸如SpiderMonkey引擎中进行测试。</p>
<p>由于所有父变量对象都存在，所以在内部函数中获取父函数中的数据没有什么特别－我们就是遍历作用域链去解析（搜寻）需要的变量。就像我们上边提及的，在一个上下文结束之后，它所有的状态和它自身都会被销毁。在同一时间父函数可能会<em>返回</em>一个<em>内部函数</em>。而且，这个返回的函数之后可能在另一个上下文中被调用。如果自由变量的上下文已经「消失」了，那么这样的调用将会发生什么？通常来说，有一个概念可以帮助我们解决这个问题，叫作<em>（词法）闭包</em>，其在ECMAScript中就是和<em>作用域链</em>的概念紧密相关的。</p>
<h2 id="9-闭包"><a href="#9-闭包" class="headerlink" title="9.闭包"></a>9.闭包</h2><p>在ECMAScript中，函数是<em>第一级</em>（first-class）对象。这个术语意味着函数可以做为参数传递给其他函数（在那种情况下，这些参数叫作「函数类型参数」（funargs，是”functional arguments”的简称））。接收「函数类型参数」的函数叫作<em>高阶函数</em>或者，贴近数学一些，叫作高阶<em>操作符</em>。同样函数也可以从其他函数中返回。返回其他函数的函数叫作<em>以函数为值</em>（function valued）的函数（或者叫作拥有函数类<em>值的函数</em>（functions with functional value））。</p>
<p>这有两个在概念上与「函数类型参数（funargs）」和「函数类型值（functional　values）」相关的问题。并且这两个子问题在”<em>Funarg problem</em>“（或者叫作”functional argument”问题）中很普遍。为了解决<em>整个”funarg problem”</em>，<em>闭包</em>（closure）的概念被创造了出来。我们详细的描述一下这两个子问题（我们将会看到这两个问题在ECMAScript中都是使用图中所提到的函数的[[Scope]]属性来解决的）。</p>
<p>「funarg问题」的第一个子问题是<em>「向上funarg问题」</em>（upward funarg problem）。它会在当一个函数从另一个函数向上返回（到外层）并且使用上面所提到的<em>自由变量的</em>时候出现。为了在<em>即使父函数上下文结束</em>的情况下也能访问其中的变量，内部函数在<em>被创建的时候</em>会在它的[[Scope]]属性中保存父函数的<em>作用域链</em>。所以当函数被<em>调用</em>的时候，它上下文的作用域链会被格式化成活动对象与[[Scope]]属性的和（实际上就是我们刚刚在上图中所看到的）：</p>
<pre><code>Scope chain = Activation object + [[Scope]]
</code></pre><p>再次注意这个关键点－确切的说在<em>创建时刻</em>－函数会保存<em>父函数的</em>作用域链，因为确切的说这个<em>保存下来的作用域链</em>将会在未来的函数调用时用来查找变量。</p>
<pre><code>function foo() {
  var x = 10;
  return function bar() {
    console.log(x);
  };
}

// &quot;foo&quot; returns also a function
// and this returned function uses
// free variable &quot;x&quot;

var returnedFunction = foo();

// global variable &quot;x&quot;
var x = 20;

// execution of the returned function

returnedFunction(); // 10, but not 20
</code></pre><p>这个类型的作用域叫作<em>静态（或者词法）作用域</em>。我们看到变量x在返回的<code>bar</code>函数的[[Scope]]属性中被找到。通常来说，也存在<em>动态作用域</em>，那么上面例子中的变量x将会被解析成20，而不是10。但是，动态作用域在ECMAScript中没有被使用。</p>
<p>「funarg问题」的第二个部分是<em>「向下funarg问题」</em>。这种情况下可能会存在一个父上下文，但是在解析标识符的时候可能会模糊不清。问题是：标识符该使用<em>哪个作用域</em>的值－以静态的方式存储在函数创建时刻的还是在执行过程中以动态方式生成的（比如<em>caller</em>的作用域）？为了避免这种模棱两可的情况并形成闭包，<em>静态作用域</em>被采用：</p>
<pre><code>// global &quot;x&quot;
var x = 10;

// global function
function foo() {
  console.log(x);
}

(function (funArg) {

  // local &quot;x&quot;
  var x = 20;

  // there is no ambiguity,
  // because we use global &quot;x&quot;,
  // which was statically saved in
  // [[Scope]] of the &quot;foo&quot; function,
  // but not the &quot;x&quot; of the caller&apos;s scope,
  // which activates the &quot;funArg&quot;

  funArg(); // 10, but not 20

})(foo); // pass &quot;down&quot; foo as a &quot;funarg&quot;
</code></pre><p>我们可以断定<em>静态作用域</em>是一门语言拥有<em>闭包的必需条件</em>。但是，一些语言可能会同时提供动态和静态作用域，允许程序员做选择－什么应该包含（closure）在内和什么不应包含在内。由于在ECMAScript中只使用了静态作用域（比如我们对于<code>funarg问题</code>的两个子问题都有解决方案），所以结论是：<em>ECMAScript完全支持闭包</em>，技术上是通过函数的[[Scope]]属性实现的。现在我们可以给闭包下一个准确的定义：</p>
<pre><code>闭包是一个代码块（在ECMAScript是一个函数）和以静态方式/词法方式进行存储的所有父作用域的一个集合体。所以，通过这些存储的作用域，函数可以很容易的找到自由变量。
</code></pre><p>注意，由于<em>每个</em>（标准的）函数都在创建的时候保存了[[Scope]]，所以理论上来讲，ECMAScript中的<em>所有函数</em>都是<em>闭包</em>。</p>
<p>另一个需要注意的重要事情是，多个函数可能拥有<em>相同的父作用域</em>（这是很常见的情况，比如当我们拥有两个内部/全局函数的时候）。在这种情况下，<code>[[Scope]]</code>属性中存储的变量是在拥有相同父作用域链的<em>所有函数之间共享</em>的。一个闭包对变量进行的修改会<em>体现</em>在另一个闭包对这些变量的读取上：</p>
<pre><code>function baz() {
  var x = 1;
  return {
    foo: function foo() { return ++x; },
    bar: function bar() { return --x; }
  };
}

var closures = baz();

console.log(
  closures.foo(), // 2
  closures.bar()  // 1
);
</code></pre><p>以上代码可以通过下图进行说明：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/shared-scope.png" alt="shared-scope"></p>
<p>确切来说这个特性在循环中创建多个函数的时候会使人非常困惑。在创建的函数中使用循环计数器的时候，一些程序员经常会得到非预期的结果，所有函数中的计数器都是<em>同样</em>的值。现在是到了该揭开谜底的时候了－因为所有这些函数拥有同一个<code>[[Scope]]</code>，这个属性中的循环计数器的值是最后一次所赋的值。</p>
<pre><code>var data = [];

for (var k = 0; k &lt; 3; k++) {
  data[k] = function () {
    alert(k);
  };
}

data[0](); // 3, but not 0
data[1](); // 3, but not 1
data[2](); // 3, but not 2
</code></pre><p>这里有几种技术可以解决这个问题。其中一种是在作用域链中提供一个额外的对象－比如，使用额外函数：</p>
<pre><code>var data = [];

for (var k = 0; k &lt; 3; k++) {
  data[k] = (function (x) {
    return function () {
      alert(x);
    };
  })(k); // pass &quot;k&quot; value
}

// now it is correct
data[0](); // 0
data[1](); // 1
data[2](); // 2
</code></pre><p>对闭包理论和它们的实际应用感兴趣的同学可以在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/" target="_blank" rel="external">第六章 闭包</a>中找到额外的信息。如果想获取更多关于作用域链的信息，可以看一下同名的<a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/" target="_blank" rel="external">第四章 作用域链</a>。</p>
<p>然后我们移动到下个部分，考虑一下执行上下文的最后一个属性。这就是关于<code>this</code>值的概念。</p>
<h2 id="10-This"><a href="#10-This" class="headerlink" title="10.This"></a>10.This</h2><pre><code>this是一个与执行上下文相关的特殊对象。因此，它可以叫作上下文对象（也就是用来指明执行上下文是在哪个上下文中被触发的对象）。
</code></pre><p><em>任何对象</em>都可以做为上下文中的<code>this</code>的值。我想再一次澄清，在一些对ECMAScript执行上下文和部分<code>this</code>的描述中的所产生误解。this经常被错误的描述成是变量对象的一个属性。这类错误存在于比如像这本书中（即使如此，这本书的相关章节还是十分不错的）。再重复一次：</p>
<pre><code>this是执行上下文的一个属性，而不是变量对象的一个属性
</code></pre><p>这个特性非常重要，因为<em>与变量相反，<code>this</code>从不会参与到标识符解析过程</em>。换句话说，在代码中当访问<code>this</code>的时候，它的值是<em>直接</em>从执行上下文中获取的，并<em>不需要任何作用域链查找</em>。<code>this</code>的值只在<em>进入上下文</em>的时候进行<em>一次</em>确定。</p>
<p>顺便说一下，与ECMAScript相反，比如，Python的方法都会拥有一个被当作简单变量的<code>self</code>参数，这个变量的值在各个方法中是相同的的并且在执行过程中可以被更改成其他值。在ECMAScript中，给<code>this</code>赋一个新值<em>是不可能的</em>，因为，再重复一遍，它不是一个变量并且不存在于变量对象中。</p>
<p>在全局上下文中，<code>this</code>就等于<em>全局对象本身</em>（这意味着，这里的this等于<em>变量对象</em>）：</p>
<pre><code>var x = 10;

console.log(
  x, // 10
  this.x, // 10
  window.x // 10
);
</code></pre><p>在函数上下文的情况下，对<em>函数的每次调用</em>，其中的<code>this</code>值可能是<em>不同的</em>。这个<code>this</code>值是通过<em>函数调用表达式</em>（也就是函数被调用的方式）的形式由<em>caller</em>所提供的。举个例子，下面的函数<code>foo</code>是一个<em>callee</em>，在全局上下文中被调用，此上下文为caller。让我们通过例子看一下，对于一个代码相同的函数，<code>this</code>值是如何在不同的调用中（函数触发的不同方式），由caller给出<em>不同的</em>结果的：</p>
<pre><code>// the code of the &quot;foo&quot; function
// never changes, but the &quot;this&quot; value
// differs in every activation

function foo() {
  alert(this);
}

// caller activates &quot;foo&quot; (callee) and
// provides &quot;this&quot; for the callee

foo(); // global object
foo.prototype.constructor(); // foo.prototype

var bar = {
  baz: foo
};

bar.baz(); // bar

(bar.baz)(); // also bar
(bar.baz = bar.baz)(); // but here is global object
(bar.baz, bar.baz)(); // also global object
(false || bar.baz)(); // also global object

var otherFoo = bar.baz;
otherFoo(); // again global object
</code></pre><p>为了深入理解<code>this</code>为什么（并且更本质一些－<em>如何</em>）在每个函数调用中可能会发生变化，你可以阅读<a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/" target="_blank" rel="external">第三章 This</a>。在那里，上面所提到的情况都会有详细的讨论。</p>
<p>总结</p>
<p>通过本文我们完成了对概要的综述。尽管，它看起来并不像是「概要」;)。对所有这些主题进行完全的解释需要一本完整的书。我们只是没有涉及到两个大的主题：<em>函数</em>（和不同函数之间的区别，比如，<em>函数声明</em>和<em>函数表达式</em>）和ECMAScript中所使用的<em>求值策略</em>(evaluation strategy )。这两个主题是可以ES3系列的在对应章节找到：<a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/" target="_blank" rel="external">第五章 函数</a>和<a href="http://dmitrysoshnikov.com/ecmascript/chapter-8-evaluation-strategy/" target="_blank" rel="external">第八章 求值策略</a>。</p>
<p>如果你有留言，问题或者补充，我将会很乐意地在评论中讨论它们。</p>
<p>祝学习ECMAScript好运！</p>
<p>作者：Dmitry A. Soshnikov<br>发布于：2010-09-02</p>
<p>(完)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/abu.jpg"
                alt="cauil" />
            
              <p class="site-author-name" itemprop="name">cauil</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/cauil" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/cauil" target="_blank" title="Weibo">
                    
                      <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://douban.com/people/cauil" target="_blank" title="DouBan">
                    
                      <i class="fa fa-fw fa-douban"></i>DouBan</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cauil</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
