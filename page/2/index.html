<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Cauil&#39;s Blog">
<meta property="og:url" content="http://cauil.github.io/page/2/index.html">
<meta property="og:site_name" content="Cauil&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cauil&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://cauil.github.io/page/2/"/>





  <title>Cauil's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cauil's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">陌上花开，可缓缓归矣</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/09/22/css_notes_3-overflow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/22/css_notes_3-overflow/" itemprop="url">CSS：overflow</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-22T00:00:00+08:00">
                2015-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/css/" itemprop="url" rel="index">
                    <span itemprop="name">css</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-overflow基本属性"><a href="#1-overflow基本属性" class="headerlink" title="1.overflow基本属性"></a>1.overflow基本属性</h2><p>值：<code>visible、hidden、scroll、auto、inherit</code></p>
<p>初始值：<code>visible</code></p>
<p>应用于：块级元素和替换元素</p>
<p>继承值：无</p>
<p>计算值：根据指定确定</p>
<h3 id="overflow-x和overflow-y"><a href="#overflow-x和overflow-y" class="headerlink" title="overflow-x和overflow-y"></a>overflow-x和overflow-y</h3><p>当容器高宽都不足以容下图片时，<code>overflow-x:hidden</code>会把x方向的隐藏掉、y方向出现滚动条；为什么会出现这种情况呢？</p>
<p>如果<code>overflow-x</code>和<code>overflow-y</code>值相同，则等同于<code>overflow</code>；</p>
<p>如果<code>overflow-x</code>和<code>overflow-y</code>值不同，且其中一个值为<code>visible</code>，另一个值为<code>hidden、scroll、auto</code>，则<code>visible</code>会被重置为<code>auto</code>；这就是为什么上面的y方向出现滚动条；</p>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>不同浏览器滚动条的表现不一样；</p>
<p>宽度设定机制，见下面一个例子：</p>
<pre><code>&lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;content&quot;&gt;&lt;/div&gt;&lt;/div&gt;

.box { width: 400px; height: 100px; overflow: auto; }
.content { width: 100%; height: 200px; background-color: #beceeb; }
</code></pre><p>在IE7中，垂直和水平方向都出现了滚动条；这是宽度设定机制差异导致的，IE7浏览器把100%宽度算成了外部容器的400px，而垂直方向出现滚动条后，会占用宽度的，从而外部容器水平方向没有400px，从而水平方向出现了滚动条。</p>
<p>如何避免这种情况呢，直接去掉<code>width: 100%</code>就好了。</p>
<p>IE8没有这种情况；</p>
<h3 id="如何使overflow属性有效"><a href="#如何使overflow属性有效" class="headerlink" title="如何使overflow属性有效"></a>如何使overflow属性有效</h3><ul>
<li><p>非<code>display： inline</code>水平</p>
</li>
<li><p>对应方位的尺寸限制；<code>width/height/max-width/max-height/absolute</code>拉伸；</p>
</li>
<li><p>对于单元格td等，还需要table为<code>table-layout：fixed</code>状态才行；</p>
</li>
</ul>
<p>两个IE7的bug：</p>
<p>(1)IE7浏览器下，按钮里的文字越多，按钮两侧的padding留白就越大！</p>
<p>解决方案：给所有按钮添加css样式<code>overflow:visible</code></p>
<p>(2)</p>
<pre><code>.size{ max-width: 200px; max-height: 300px; overflow: auto; }
&lt;div class=&apos;size&apos;&gt;&lt;img src=&quot;mm1.jpg&quot; width=&quot;256&quot; height=&quot;191&quot;&gt;&lt;/div&gt;
</code></pre><p>按理论只有水平出现滚动条，结果垂直方向也出现了；</p>
<h2 id="2-overflow与滚动条"><a href="#2-overflow与滚动条" class="headerlink" title="2.overflow与滚动条"></a>2.overflow与滚动条</h2><h3 id="滚动条出现的条件"><a href="#滚动条出现的条件" class="headerlink" title="滚动条出现的条件"></a>滚动条出现的条件</h3><p>1.<code>overflow:auto/overflow:scroll  //&lt;html&gt;、&lt;textarea&gt;</code></p>
<p>2.当子元素的水平或者垂直方向超过容器对应方向的最大限度；</p>
<h3 id="body-html与滚动条"><a href="#body-html与滚动条" class="headerlink" title="body/html与滚动条"></a>body/html与滚动条</h3><p>无论什么浏览器，<strong>默认滚动条均来自<code>&lt;html&gt;</code></strong>而不是<code>&lt;body&gt;</code>标签；</p>
<p>原因：新建一个空白HTML页面，<code>&lt;body&gt;</code>默认<code>.5em margin</code>值，如果滚动条来自<code>&lt;body&gt;</code>，则应该滚动条与浏览器边框有边距；而事实是滚动条是紧贴着浏览器边框的；</p>
<p>IE7-浏览器默认类似： <code>html { overflow-y: scroll; }</code><br>IE8+等浏览器默认：<code>html { overflow: hidden; }</code></p>
<p>所以，如果我们想要去除页面默认滚动条，只需要：</p>
<pre><code>html { overflow: hidden; }
</code></pre><p>而没必要把<body>也拉下水：</body></p>
<pre><code>html, body { overflow: hidden; } //不需要body标签
</code></pre><h3 id="JS与滚动高度"><a href="#JS与滚动高度" class="headerlink" title="JS与滚动高度"></a>JS与滚动高度</h3><p>chrome浏览器是：<code>document.body.scrollTop</code>;</p>
<p>其他浏览器是：<code>document.documentElement.scrollTop</code>;</p>
<p>目前，两者不会同时存在，因此，有人会写成：</p>
<pre><code>var st = document.body.scrollTop +　document.documentElement.scrollTop
</code></pre><p>建议使用：</p>
<pre><code>var st = document.body.scrollTop ||　document.documentElement.scrollTop
</code></pre><h3 id="overflow的padding-bottom缺失现象"><a href="#overflow的padding-bottom缺失现象" class="headerlink" title="overflow的padding-bottom缺失现象"></a>overflow的padding-bottom缺失现象</h3><pre><code>.box { width: 400px; height: 100px; padding: 100px 0; overflow: auto; }
</code></pre><p>在chrome浏览器下面的padding-bottom可以滚动出来；而其他浏览器都不存在；</p>
<p>可能导致的： 不一样的scrollHeight(元素内容高度)</p>
<h3 id="滚动条的宽度机制"><a href="#滚动条的宽度机制" class="headerlink" title="滚动条的宽度机制"></a>滚动条的宽度机制</h3><p>滚动条会占用容器的可用宽度和高度；</p>
<p>下面这种方法可以计算滚动条的宽度：</p>
<pre><code>.box {width: 400px; overflow: scroll; }
.in {*zoom: 1; /* for IE7 */}

&lt;div class=&quot;box&quot;&gt;
    &lt;div id=&quot;in&quot; class=&quot;in&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

console.log(400 - document.getElementById(&quot;in&quot;).clientWidth);
</code></pre><p>测得的结果：IE7+/Chrome/FireFox(win7)-均是17像素；</p>
<h3 id="overflow-auto的潜在布局隐患"><a href="#overflow-auto的潜在布局隐患" class="headerlink" title="overflow:auto的潜在布局隐患"></a>overflow:auto的潜在布局隐患</h3><p>滚动条会占用容器尺寸，原本和谐的布局，滚动条出现后可能挂掉；</p>
<h3 id="水平居中跳动问题"><a href="#水平居中跳动问题" class="headerlink" title="水平居中跳动问题"></a>水平居中跳动问题</h3><pre><code>.container { width: 1150px; margin: 0 auto; }
</code></pre><p>问题的修复：</p>
<p>1.<code>html { overflow-y: scroll; }</code> // 太丑</p>
<p>2.<code>.container { padding-left: calc(100vw - 100%);}</code></p>
<h2 id="3-overflow与BFC"><a href="#3-overflow与BFC" class="headerlink" title="3.overflow与BFC"></a>3.overflow与BFC</h2><p>BFC(block formatting context) - ‘块级格式化上下面’</p>
<p>BFC有一个特点：页面之结界，内部元素再怎么翻云覆雨都不会影响外部；</p>
<h3 id="overflow与BFC"><a href="#overflow与BFC" class="headerlink" title="overflow与BFC"></a>overflow与BFC</h3><p>overflow有三种属性会触发BFC：<code>auto、scroll、hidden</code></p>
<p>有三种常用用途：</p>
<p>清楚浮动影响、避免margin穿透问题、两栏自适应布局</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/08/21/css_notes_2-float/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/21/css_notes_2-float/" itemprop="url">CSS：浮动</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-21T00:00:00+08:00">
                2015-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/css/" itemprop="url" rel="index">
                    <span itemprop="name">css</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>什么是浮动，浮动有什么作用？</p>
<h2 id="1-浮动的前世今生"><a href="#1-浮动的前世今生" class="headerlink" title="1.浮动的前世今生"></a>1.浮动的前世今生</h2><p>从Netscape1以来，就可以通过声明让图像浮动，如：</p>
<pre><code>&lt;img src=&quot;b5.gif&quot; align=&quot;right&quot;&gt;
</code></pre><p>这会导致一个图像浮动到右边，而允许其他内容如文本“围绕”该图像。</p>
<p>可见浮动的初衷是为了实现文字环绕效果；</p>
<p>过去只可能浮动图像。但CSS允许浮动任何元素，从图像到段落再到列表，所有元素都可以浮动。在CSS中，这种行为是用属性float实现。</p>
<h2 id="2-float取值"><a href="#2-float取值" class="headerlink" title="2.float取值"></a>2.float取值</h2><p>值：left、right、none、inherit</p>
<p>初始值：none</p>
<p>应用于：所有元素</p>
<p>继承值：无</p>
<p>计算值：根据指定确定</p>
<h2 id="3-浮动的特性：包裹与破坏"><a href="#3-浮动的特性：包裹与破坏" class="headerlink" title="3.浮动的特性：包裹与破坏"></a>3.浮动的特性：包裹与破坏</h2><p>什么是包裹（对本身而言）：包裹是收缩、坚挺（有高度了）、隔绝（内部内容与外界不相关）</p>
<p>具有包裹的其他小伙伴：</p>
<ul>
<li><p>display: inline-block/table-cell/…</p>
</li>
<li><p>position: absolute/fixed/sticky</p>
</li>
<li><p>overflow: hidden/scroll</p>
</li>
</ul>
<p>什么是破坏（对父元素而言）：容器被破坏，父元素的高度塌陷</p>
<p>具有破坏的其他小伙伴：</p>
<ul>
<li><p>display: none</p>
</li>
<li><p>position: absolute/fixed/sticky</p>
</li>
</ul>
<p>对于浮动元素有几点要记住。</p>
<p>首先，会以某种方式将浮动元素从文档的正常流中删除，不过它还是会影响布局。</p>
<p>采用CSS的特有方式，浮动元素几乎自成一派，不过它们还是对文档的其他元素有影响。</p>
<h2 id="4-清除浮动"><a href="#4-清除浮动" class="headerlink" title="4.清除浮动"></a>4.清除浮动</h2><p>由于浮动具有破坏性，那我们怎么清楚浮动带来的影响；有以下三种方式：</p>
<p>(1)浮动元素脚底插入clear：both</p>
<p><strong>注意：脚底插入的标签是要为block元素；</strong></p>
<p>直接把<code>&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;</code>放到当作最后一个子标签放到父标签那儿，此方法兼容性强，使用方便，但是浪费了一个标签，而且只能使用一次，而且有时候如果不注意中间多了个空格会产生一段空白高度。</p>
<p>优点：通俗易懂，容易掌握；</p>
<p>缺点：可以想象通过此方法，会添加多少无意义的空标签，有违结构与表现的分离，在后期维护中将是噩梦；<strong>只是解决了浮动，但新添加的标签会与父元素外面的元素发生margin重叠；</strong></p>
<p>(2)使用after伪对象清除浮动（与第一种方法原理相同）</p>
<p>该方法只适用于非IE浏览器，因为IE6/IE7不认识伪元素,具体写法可参照下面例;</p>
<pre><code>.fix{zoom:1;}
.fix:after{
    display:block;
    content:&apos;.&apos;;
    clear:both;
    line-height:0;
    visibility:hidden;
}
</code></pre><p>对于伪元素可以使用下面的方案，不用写太多东西：</p>
<pre><code>.clearfix:after { content: &apos;&apos;; **display: table**; clear: both; }
.clearfix { *zoom: 1; }
</code></pre><p>使用中需注意以下几点：</p>
<p>a.该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；</p>
<p>b.content属性是必须的，但其值可以为空，蓝色理想讨论该方法的时候content属性的值 设为”.”，但我发现为空亦是可以的。</p>
<p>c.line-height:0写成height:0也是可以的。不会影响任何其他样式，通用性强，覆盖面广;</p>
<p>(3)BFC/haslayout解决</p>
<p>例如给包含浮动元素的<strong>父标签</strong>添加css属性<code>.clearfix{overflow:hidden; zoom:1;}</code></p>
<p>其中<code>zoom:1</code>用于让IE6/IE7haslayout又不影响形体的神器。</p>
<p>此方法优点在于代码简洁，涵盖所有浏览器，可是对于overflow:hidden;要是里面的元素要是想来个margin负值定位或是负的绝对定位，岂不是直接被裁掉了，所以此方法是有不小的局限性的。</p>
<p>优点：不存在结构和语义化问题，代码量极少；<strong>父元素把子元素都包裹起来了，子元素不会与外层的元素发生margin重叠；</strong></p>
<p>缺点：内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。</p>
<p>BFC/haslayout通常有以下声明：</p>
<ul>
<li>float:left/right</li>
<li>position:absolute/fixed</li>
<li>overflow:hidden/scroll(IE7+)</li>
<li>display:inline-block/table-cell(IE8+)</li>
<li>width/height/zoom:1/…(IE6/IE7)</li>
</ul>
<p>(4)总结：</p>
<p>此三种方法各有利弊，使用时应择优选择，比较之下第二种方法更为可取；</p>
<p>可以使用兼容性的解决方案：</p>
<pre><code>.clearfix:after { // 解决IE8+
content: &apos;&apos;; 
display: block; 
height: 0; 
overflow: hidden; 
clear: both
}
.clearfix {*zoom: 1;} // 解决IE6/IE7
</code></pre><h2 id="5-浮动的滥用"><a href="#5-浮动的滥用" class="headerlink" title="5.浮动的滥用"></a>5.浮动的滥用</h2><p>浮动的两大特性：元素block块状化（砌砖头）、破坏造成的紧密排列特性（去空格化）</p>
<p>block化即当元素增加浮动属性，其display属性转化为block;</p>
<p>去空格化是指当元素增加浮动属性，后面的空格&amp;nbsp或者换行符\n都被移到后面了，实现了文字环绕效果；而换行符在标签的末尾没有任何表现，&amp;nbsp可以选中；</p>
<p>砌砖布局的问题：</p>
<pre><code>妙脆角-嘎吱脆； // 容错性比较糟糕，容易出问题

吝啬鬼-重用废； // 尺寸限定，模块到另外一个尺寸容器中，不配对，要重新整，完全没有重用性；

洋葱头-IE7飙泪； // 在低版本的IE有很多问题
</code></pre><h2 id="6-float与流体布局"><a href="#6-float与流体布局" class="headerlink" title="6.float与流体布局"></a>6.float与流体布局</h2><p>单侧固定（有两种方式）：</p>
<pre><code>width+float // 这一种是设置紧跟元素的width并设置为右浮动
padding-left/margin-left // 这一种是不设置width，只设置margin-left\
或者padding-left，让其自然适应
</code></pre><p>DOM与显示位置匹配的单侧固定布局：</p>
<pre><code>width:100% + float // 外层
    padding-left/margin-left //设置margin-right，以防父元素的后面元素margin-left进父元素后，内容被父元素内容覆盖
width + float + margin负值 // 设置width和margin-left负值，使其进入上面元素内
</code></pre><p>高级进化 – 智能自适应尺寸（推荐）：</p>
<pre><code>float
display: table-cell; width: 2000px;          IE8+
*display: inline-block; *width: auto;       IE7-
</code></pre><h2 id="7-浮动与兼容型"><a href="#7-浮动与兼容型" class="headerlink" title="7.浮动与兼容型"></a>7.浮动与兼容型</h2><p>IE7的浮动问题：</p>
<ul>
<li><p>含clear的浮动元素包裹不正确的问题</p>
</li>
<li><p>浮动元素倒数两个莫名垂直间距问题</p>
</li>
<li><p>浮动元素最后一个字符重复问题</p>
</li>
<li><p>浮动元素楼梯排列问题</p>
</li>
<li><p>浮动元素和文本不在同一行的问题</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/08/13/css_notes_1-layout/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/13/css_notes_1-layout/" itemprop="url">CSS：网页布局</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-13T00:00:00+08:00">
                2015-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/css/" itemprop="url" rel="index">
                    <span itemprop="name">css</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>三大布局：标准文档流、浮动布局、定位布局</p>
<h3 id="标准文档流（flow）"><a href="#标准文档流（flow）" class="headerlink" title="标准文档流（flow）"></a>标准文档流（flow）</h3><ul>
<li><p>块级元素（block）：从左到右撑满页面，独占行，从上到下</p>
</li>
<li><p>内联元素、或行级元素（inline）：行内显示，从左到右</p>
</li>
<li><p>块级内联元素（inline-block）：行内，但可以像块级元素一样编辑高度、宽度、行高以及顶和底边距</p>
</li>
</ul>
<p><em>注：块级元素和行级元素都是盒子模型</em></p>
<h3 id="浮动布局（float）"><a href="#浮动布局（float）" class="headerlink" title="浮动布局（float）"></a>浮动布局（float）</h3><ul>
<li><p>设置了浮动的元素，仍旧处于标准文档流中</p>
</li>
<li><p>左浮动、右浮动，对紧邻后面的元素有影响</p>
</li>
<li><p>清除浮动：</p>
<ol>
<li>clear：both(left、right）  </li>
<li>同时设置：width:100%（或固定宽度）+ overflow：hidden</li>
</ol>
</li>
</ul>
<h3 id="定位布局（position）"><a href="#定位布局（position）" class="headerlink" title="定位布局（position）"></a>定位布局（position）</h3><p>三种定位方式：静态定位、相对定位、绝对定位</p>
<p>四个属性值：static、relative、absolute、fixed</p>
<ul>
<li><p>相对定位(relative)</p>
<p>  相对于自身位置进行偏移(<strong>原先位置仍然存在，对兄弟模块有影响，占了位置</strong>)、<strong>仍处于标准文档流中</strong>、随即拥有偏移属性和<strong>Z-index属性</strong></p>
</li>
<li><p>绝对定位（absolute）</p>
<p>  （1）建立了以包含块为基准的定位、<strong>完全脱离了标准文档流（对兄弟模块无影响）</strong>、随即拥有偏移属性和<strong>Z-index属性</strong></p>
<p>  （2）未设置偏移量：无论是否存在已定位祖先元素，都保持在元素初始位置。</p>
<p>  （3）设置了偏移量：a.无已定位祖先元素，以<html>为偏移参考基准；b.有已定位祖先元素，以距其最近的已定位祖先元素为偏移参考基准。</html></p>
</li>
<li><p>绝对定位（fixed） </p>
<p>  (1) 与absolute定位类型类似，完全脱离了标准文档流（对兄弟模块无影响），但它的<strong>相对移动的坐标是视图（屏幕内的网页窗口）本身</strong></p>
<p>  (2) 未设置偏移量时，有已定位祖先元素，以祖先元素为基准定位；无已定位元素，以浏览器窗口为基准定位；</p>
<p>  (3)    设置偏移量时，有、无已定位祖先元素，都以浏览器可视窗口为基准偏移；</p>
<p>  <strong>注意：上面设置偏移量的时候，可以根据需求设置，只设置top，只有top方向才会跟已定位的祖先元素偏移，left是不会相对已定位的祖先偏移的</strong></p>
<p>  不过遇到一个问题一直想不明白，两个盒子box1、box2，box1在box2之前，并列关系，box1设置fixed之后，box2设置margin-top为50px，结果box1也跟着下来50px了？？？？</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/06/12/life_shanqiu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/06/12/life_shanqiu/" itemprop="url">山丘</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-06-12T00:00:00+08:00">
                2015-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/life/" itemprop="url" rel="index">
                    <span itemprop="name">life</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>《山丘》</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/shanqiu.jpg" alt="山丘"></p>
<p>想说却还没说的 还很多</p>
<p>攒着是因为想写成歌</p>
<p>让人轻轻地唱着 淡淡地记着</p>
<p>就算终于忘了 也值了</p>
<p>说不定我一生涓滴意念</p>
<p>侥幸汇成河</p>
<p>然后我俩各自一端</p>
<p>望着大河弯弯 终于敢放胆</p>
<p>嘻皮笑脸 面对 人生的难</p>
<p>也许我们从未成熟</p>
<p>还没能晓得 就快要老了</p>
<p>尽管心里活着的还是那个</p>
<p>年轻人</p>
<p>因为不安而频频回首</p>
<p>无知地索求 羞耻于求救</p>
<p>不知疲倦地翻越 每一个山丘</p>
<p>越过山丘 虽然已白了头</p>
<p>喋喋不休 时不我予的哀愁</p>
<p>还未如愿见着不朽</p>
<p>就把自己先搞丢</p>
<p>越过山丘 才发现无人等候</p>
<p>喋喋不休 再也唤不回温柔</p>
<p>为何记不得上一次是谁给的拥抱</p>
<p>在什么时候</p>
<p>我没有刻意隐藏 也无意让你感伤</p>
<p>多少次我们无醉不欢</p>
<p>咒骂人生太短 唏嘘相见恨晚</p>
<p>让女人把妆哭花了 也不管</p>
<p>遗憾我们从未成熟</p>
<p>还没能晓得 就已经老了</p>
<p>尽力却仍不明白</p>
<p>身边的年轻人</p>
<p>给自己随便找个理由</p>
<p>向情爱的挑逗 命运的左右</p>
<p>不自量力地还手 直至死方休</p>
<p>越过山丘 虽然已白了头</p>
<p>喋喋不休 时不我予的哀愁</p>
<p>还未如愿见着不朽</p>
<p>就把自己先搞丢</p>
<p>越过山丘 才发现无人等候</p>
<p>喋喋不休 再也唤不回了温柔</p>
<p>为何记不得上一次是谁给的拥抱</p>
<p>在什么时候</p>
<p>越过山丘 虽然已白了头</p>
<p>喋喋不休 时不我予的哀愁</p>
<p>还未如愿见着不朽</p>
<p>就把自己先搞丢</p>
<p>越过山丘 才发现无人等候</p>
<p>喋喋不休 再也唤不回了温柔</p>
<p>为何记不得上一次是谁给的拥抱</p>
<p>在什么时候</p>
<p>喋喋不休 时不我予的哀愁</p>
<p>向情爱的挑逗 命运的左右</p>
<p>不自量力地还手 直至死方休</p>
<p>为何记不得上一次是谁给的拥抱</p>
<p>在什么时候</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/05/24/js_journey_0105-Objects/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/24/js_journey_0105-Objects/" itemprop="url">JS之旅（启程）：对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-24T00:00:00+08:00">
                2015-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>下面代码都在node.js测试</strong></p>
<p>这一次我们来谈谈对象。</p>
<h2 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h2><p>对象是一种复合值。</p>
<p>对象是属性的无序集合，每个属性都是一个名/值对。</p>
<p>对象不仅仅是字符串到值的映射，除了可以保持自有的属性，还可以从原型对象继承属性。这种原型式继承是JS的核心特征。</p>
<p>对象是动态的，可以新增属性也可以删除属性。对象是可变，我们通过引用而非值来操作对象，如：</p>
<pre><code>var x = {a:1, b:2};
var y = x;
y; // {a:1, b:2}
y.b = 3;
y; // {a:1, b:3}
x; // {a:1, b:3}
</code></pre><p>对象常见方法有：创建、设置、查找、删除、检测和枚举它的属性，接下来一一解析这些方法。</p>
<p>对象属性特性（property attribute）：可写、可枚举、可配置。</p>
<p>对象自身还拥有三个相关的对象特性（attribute）：原型、类、扩展标记。</p>
<p>对象分类：内置对象、宿主对象、自定义对象。</p>
<p>对象属性分类：自有属性、继承属性。</p>
<h3 id="对象的KEY"><a href="#对象的KEY" class="headerlink" title="对象的KEY"></a>对象的KEY</h3><p>对象的key为字符串，即使不为字符串，也会转换为字符串类型。如：</p>
<pre><code>var obj = {};
obj[1] = 1;
obj[&apos;1&apos;] = 2;
obj; // Object {1: 2}

obj[{}] = true; // {}会转换为字符串&apos;[object Object]&apos;
obj[{x : 1}] = true; // {x: 1}会转换为字符串&apos;[object Object]&apos;
obj; // Object {1: 2, [object Object]: true}
</code></pre><p>对象中不能存在两个同名的属性，如：</p>
<pre><code>var obj = {a: 1, a: 2};
obj; // {a:2}
</code></pre><h3 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h3><p>对象的属性有五个特征：</p>
<p>writable、enumerable、configurable、value、get/set</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>可以通过对象直接量、关键字new和Object.create()函数来创建。</p>
<h3 id="字面量创建"><a href="#字面量创建" class="headerlink" title="字面量创建"></a>字面量创建</h3><pre><code>var obj1 = {x: 1, y: 2};
</code></pre><p>在ES5中，保留字可以用作不带引号的属性名；而ES3使用保留字作为属性名必须使用引号引起来。</p>
<p>在ES5中，对象直接量最后一个属性后的逗号将忽略；且在ES3的大部分实现中也可以忽略这个逗号，而在IE中则报错。</p>
<p><strong>注意</strong>：所有通过对象直接量创建的对象都具有同一个原型，原型指向<code>Object.prototype</code></p>
<h3 id="new以及原型链"><a href="#new以及原型链" class="headerlink" title="new以及原型链"></a>new以及原型链</h3><p>通过关键字new和构造函数调用创建的对象的原型就是构造函数的prototype属性的值。通过new Array()创建的对象的原型就是Array.prototype,通过new Date()创建的对象原型就是Date.prototype。</p>
<p>所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自Object.prototype的原型。因此由new Date()创建的对象同时继承Array.prototype和Object.prototype。这一系列链接的原型对象就是所谓的原型链。</p>
<h3 id="Object-create-ES5定义"><a href="#Object-create-ES5定义" class="headerlink" title="Object.create() ES5定义"></a>Object.create() ES5定义</h3><p>直接在花括号里传入所需的原型对象即可：</p>
<pre><code>var obj = Object.create({x : 1});
obj.x // 1
typeof obj.toString // &quot;function&quot;
obj.hasOwnProperty(&apos;x&apos;);// false
</code></pre><p>可以通过传入参数null来创建一个没有原型的新对象，但通过这种方法创建的对象不会继承任何东西，甚至包括基础方法，如：</p>
<pre><code>var obj = Object.create(null);
obj.toString // undefined，注意与上面例子的比较
</code></pre><p><strong>注意</strong>：obj原型为{x:1}，而{x:1}原型为Object.prototype，所以obj可以访问到toString方法</p>
<p>如果想通过Object.create()来创建一个空对象，可以通过下面方法来创建：（也可以通过{}和new Object()来创建）</p>
<pre><code>Object.create(Object.prototype)
</code></pre><p>ES3模拟原型继承，不过inherit不能完全替代Object.create()，因为前者不能传入null来创建对象，也不能接受可选的第二个参数，下面为inherit的实现：</p>
<pre><code>function inherit(p){
    if(p == null){
        throw TypeError();
    }
    if(Object.create){
        return Object.create(p);
    }
    var t = typeof p;
    if (t !== &quot;object&quot; &amp;&amp; t !== &quot;function&quot;){
        throw TypeError();
    }
    function f(){};
    f.prototype = p;
    return new f();
}
</code></pre><h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h2><h3 id="属性的查询和设置"><a href="#属性的查询和设置" class="headerlink" title="属性的查询和设置"></a>属性的查询和设置</h3><p>可以通过.运算符或者方括号[]访问属性。对于.运算符来说，右侧必须是一个以属性名称命名的简单标识符；对于方括号来说，方括号内必须是一个计算结果为字符串的表达式（严格地讲，表达式必须返回字符串或返回一个可以转换为字符串的值），如：</p>
<pre><code>var obj = {&apos;5&apos;: &quot;abc&quot;, &apos;7&apos;: &quot;cdf&quot;, c: 100};
obj.c; // 100
obj[&apos;c&apos;]; // 100
obj[c]; // Error：c is not defined
obj[1]; //  undefined,因为1会转换为字符串&apos;1&apos;
obj[&apos;5&apos;]; // &apos;abc&apos;
obj[1+4]; // &apos;abc&apos;
</code></pre><p>在ES3中，点.后面的标识符不能是保留字，ES5放宽了，可以直接在.运算符后面直接使用保留字。</p>
<h4 id="关联数组的对象"><a href="#关联数组的对象" class="headerlink" title="关联数组的对象"></a>关联数组的对象</h4><p>使用.运算符来访问对象的属性时，属性名用一个标识符来表示，由于标识符不是数据类型，因此程序无法修改它们。</p>
<p>而通过[]来访问时，属性名通过字符串来表示，在程序运行时，可以修改和创建他们，如：</p>
<pre><code>var addr = &quot;&quot;
for(i=0; i&lt;4; i++){
    addr += customer[&quot;address&quot; + i] + &apos;\n&apos;;
}
</code></pre><p>可以看见关联数组的方式来实现更强大、更灵活，推荐。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>属性访问细节：</p>
<p>假如要查询对象o的属性x，如果o中不存在x，那么将会继续在o的原型对象中查询属性x。如果原型对象中也没有x，但这个原型也有原型，那么继续在这个原型对象的原型上执行查询，直到找到x或者查找到一个原型是null的对象为止。如：</p>
<pre><code>var o = {};
o.x = 1;
var p = Object.create(o);
p.y = 2;
var q = Object.create(p);
q.z = 3;
q.x + q.y //3 ，x和y分别继承自o和p
</code></pre><p>属性赋值细节：</p>
<p>1.假如对象o已经有属性x（这个属性不是继承来的），那么这个赋值操作只改变这个已有属性x的值。</p>
<p>2.如果o不存在x，接着判断：</p>
<p>(1)现在如果原型上有属性x且为可写，则会为o创建一个x属性；</p>
<p>(2)如果原型上有属性x且不可写，则赋值失败；</p>
<p>如：</p>
<pre><code>var obj1 = {};
Object.defineProperty(obj1, &apos;z&apos;, {value:1, writable:false, enumerable: true, configurable:true});
obj1.z; // 1
Object.keys(obj1); // [&apos;z&apos;]
obj2 = Object.create(obj1);
obj2.z; // 1
obj2.z=2; // 赋值失败，则有下面的结果
obj2.z; // 1
obj2.hasOwnProperty(&apos;z&apos;); // false
Object.defineProperty(obj1, &apos;z&apos;, {value:1, writable:true, enumerable: true, configurable:true});
obj2.z=2; // 赋值成功，则有下面的结果
obj2.z; // 2
obj2.hasOwnProperty(&apos;z&apos;); // true
</code></pre><p><strong>注意</strong>：如果原型上有属性x，而这个属性是一个具有setter方法的accessor属性，那么这时将调用setter方法而不是给o创建一个属性x。且setter是对象o调用的，因此setter方法的操作只是针对o本身，并不会修改原型链。（此处例子见下面set/get介绍）</p>
<p><strong>注意</strong>：只有在查询属性时才会体会到继承的存在，而设置属性则和继承无关。</p>
<h4 id="属性访问错误"><a href="#属性访问错误" class="headerlink" title="属性访问错误"></a>属性访问错误</h4><p>查询一个不存在的属性并不会报错，如：</p>
<pre><code>var obj = {x : 1};
obj.y; // undefined
</code></pre><p>但是，如果对象不存在，那么试图查询这个不存在的对象的属性就会报错，如：</p>
<pre><code>var yz = obj.y.z; // TypeError: Cannot read property &apos;z&apos; of undefined
obj.y.z = 2; // TypeError: Cannot set property &apos;z&apos; of undefined
</code></pre><p>处理方式：</p>
<pre><code>var yz;
    if (obj.y) {
    yz = obj.y.z;
}
</code></pre><p>更简练的方式，可以使用&amp;&amp;的短路行为：</p>
<pre><code>var yz = obj &amp;&amp; obj.y &amp;&amp; obj.y.z
</code></pre><p>给null和undefined设置属性也会报类型错误。设置属性的失败操作都会抛出一个类型错误异常，除了一些对象例外，如：</p>
<pre><code>Object.prototype = 1; 
Object.prototype // {},赋值失败，但上面没有报错
</code></pre><p>这是一个历史遗留bug，在严格模式下，任何设置属性的失败操作都会抛出一个类型错误异常。</p>
<h3 id="属性的删除"><a href="#属性的删除" class="headerlink" title="属性的删除"></a>属性的删除</h3><p>delete可以删除对象的属性，如</p>
<pre><code>var person = {age : 28, title : &apos;fe&apos;};
delete person.age; // true
delete person[&apos;title&apos;]; // true
person.age; // undefined
delete person.age; // true
</code></pre><p>需要注意，delete只是断开属性和宿主对象的联系，而不会去操作属性中的属性，由于已经删除的属性的引用依然存在，可能因为这种不严谨的代码而造成内存泄露，如</p>
<pre><code>var a = {p: {x:1}};
var b = a.p;
b; // {x:1}
delete a.p;
b; // {x:1}
</code></pre><p>delete只能删除自有属性，而不能删除继承属性。</p>
<p>delete不能删除那些可配置性为false的属性，在严格模式下，删除一个不可配置属性会报一类型错误，在非严格模式下，这些情况下的delete操作会返回一个false：</p>
<pre><code>delete Object.prototype; // false,

var descriptor = Object.getOwnPropertyDescriptor(Object, &apos;prototype&apos;);
descriptor.configurable; // false
</code></pre><p>另外，用var定义的全局变量或者局部变量也不能删除，全局函数或者局部函数也不能删除，如：</p>
<pre><code>var globalVal = 1;
delete globalVal; // false

(function() {
       var localVal = 1;
    return delete localVal;
}()); // false


function fd() {}
delete fd; // false

(function() {
    function fd() {};
    return delete fd;
}()); // false
</code></pre><p>隐式定义的全局变量可以删除，如</p>
<pre><code>ohNo = 1;
ohNo; // 1
delete ohNo; // true
</code></pre><p><strong>注意</strong>：属性的删除由属性的特性configurable值来控制。</p>
<h3 id="属性的检测"><a href="#属性的检测" class="headerlink" title="属性的检测"></a>属性的检测</h3><p>三种方法：in运算符、hasOwnProperty(是否是自有属性)、propertyIsEnumerable(检测是否为自有属性且可枚举)，如：</p>
<pre><code>var cat = new Object;
cat.legs = 4; // leg属性自有且可枚举
Object.defineProperty(cat, &apos;age&apos;, {value:1, writable:true, enumerable: false, configurable:true}); // age属性为自有但不可枚举

&apos;legs&apos; in cat; // true
&apos;age&apos; in cat; // true
&apos;abc&apos; in cat; // false
&quot;toString&quot; in cat; // true, inherited property!!!

cat.hasOwnProperty(&apos;legs&apos;); // true
cat.hasOwnProperty(&apos;age&apos;); // true
cat.hasOwnProperty(&apos;toString&apos;); // false

cat.propertyIsEnumerable(&apos;legs&apos;); // true
cat.propertyIsEnumerable(&apos;age&apos;); // false
cat.propertyIsEnumerable(&apos;toString&apos;); // false

Object.keys(cat); //legs
</code></pre><p>属性设置方法（用defineProperty设置的属性默认是不可枚举）：</p>
<pre><code>Object.defineProperty(cat, &apos;price&apos;, {value : 1000});
Object.getOwnPropertyDescriptor(cat, &apos;price&apos;); // {value: 1000, writable: false, enumerable: false, configurable: false}
cat.propertyIsEnumerable(&apos;price&apos;); // false
cat.hasOwnProperty(&apos;price&apos;); // true
</code></pre><p>除了使用in运算符外，另一种更简单的方法是使用“!==”判断一个属性是否是undefined，但当一个属性值刚好为undefined时无效，这时用in运算符才准确，如：</p>
<pre><code>var o = {x:1}
o.x !== undefined; // true
o.y !== undefined; // false

var o = {x: undefined}
o.x !== undefined; // false
o.y !== undefined; // false
&quot;x&quot; in o; // true
&quot;y&quot; in o; // false
</code></pre><p><strong>注意</strong>：!=不是严格等于，undefined与null相等，所以有下面的：</p>
<pre><code>if (cat.legs != undefined) {
    // !== undefined, or, !== null
}
</code></pre><h3 id="属性的枚举"><a href="#属性的枚举" class="headerlink" title="属性的枚举"></a>属性的枚举</h3><p>对象继承的内置方法不可枚举，但在代码中给对象添加的属性都是可枚举的（除了defineProperty这类情况），见例子：</p>
<pre><code>var o = {x : 1, y : 2, z : 3};
&apos;toString&apos; in o; // true
o.propertyIsEnumerable(&apos;toString&apos;); // false
var key;
for (key in o) {
    console.log(key); // x, y, z
}
</code></pre><p>for..in..会去原型链上枚举所有特征Enumerable为true的属性，如：</p>
<pre><code>var obj = Object.create(o);
obj.a = 4;
var key;
for (key in obj) {
    console.log(key); // a, x, y, z
}
</code></pre><p>只枚举出是自己属性的：</p>
<pre><code>var obj = Object.create(o);
obj.a = 4;
var key;
for (key in obj) {
    if (obj.hasOwnProperty(key)) {
        console.log(key); // a
    }
}
</code></pre><p>ES5增加了两个用于枚举属性名称的函数，Object.keys()和Object.getOwnPropertyNames(),如：</p>
<pre><code>Object.defineProperty(obj, &apos;b&apos;, {value:1}) // 属性b不可枚举
Object.keys(obj); // [&apos;a&apos;],枚举出特性为可枚举的自有属性
Object.getOwnPropertyNames(obj); // [&apos;a&apos;, &apos;b&apos;]，所有自有属性，不管特性是否可枚举
</code></pre><h3 id="get、set方法"><a href="#get、set方法" class="headerlink" title="get、set方法"></a>get、set方法</h3><p>对象的属性分为数据属性和存取器属性，存取器属性就是属性值可以用一个或两个方法替代，这两个方法就是setter、getter</p>
<p>读取存取器属性的值是，调用getter方法（无参数），这个方法的返回值就是存取器属性的值；当程序设置一个存取器属性的值时，JS调用setter方法，将赋值表达式右侧的值当做参数传入setter，可以忽略setter的返回值。</p>
<p>读取只写属性总是返回undefined，如：</p>
<pre><code>var o = { set a(value){}};
o.a; // undefined
</code></pre><p>先看一个例子：</p>
<pre><code>var man = {
    name : &apos;cauil&apos;,
    weibo : &apos;@cauil&apos;,
    get age() {
        return new Date().getFullYear() - 1989;
    },
    set age(val) {
        console.log(&apos;Age can\&apos;t be set to &apos; + val);
    }
}

console.log(man.age); // 
man.age = 100; // Age can&apos;t be set to 100
console.log(man.age); // still 27
</code></pre><p>再来看一个例子：</p>
<pre><code>var man = {
    weibo : &apos;@cauil&apos;,
    $age : null,
    get age() {
        if (this.$age == undefined) {
            return new Date().getFullYear() - 1989;
        } else {
            return this.$age;
        }
    },
    set age(val) {
        val = +val;
        if (!isNaN(val) &amp;&amp; val &gt; 0 &amp;&amp; val &lt; 150) {
            this.$age = val;
        } else {
            throw new Error(&apos;Incorrect val = &apos; + val);
        }
    }
}

console.log(man.age); // 27
man.age = 100;
console.log(man.age); // 100;
man.age = &apos;abc&apos;; // error:Incorrect val = NaN
</code></pre><p>get/set与原型链, 本身对象属性不存在时，会去原型上查找，尝试赋值时，会去读取原型链上的set方法，是原型调用：</p>
<pre><code>function foo(){};

Object.defineProperty(foo.prototype, &apos;z&apos;, 
    {get: function(){return 1;}});
var obj = new foo();

obj.z; // 1
obj.z = 10;
obj.z; // still 1

Object.defineProperty(obj, &apos;z&apos;, 
{value : 100, configurable: true});
obj.z; // 100;
delete obj.z;
obj.z; //back to 1
</code></pre><p>如果o继承自一个只读属性x，那么赋值操作是不允许的，如果允许属性赋值，它也只是在原始对象上创建属性或对已有的属性赋值，而不会去修改原型链，如：</p>
<pre><code>var o = {};
Object.defineProperty(o, &apos;x&apos;, {value : 1}); // writable=false, configurable=false
var obj = Object.create(o);
obj.x; // 1
obj.x = 200;
obj.x; // still 1, can&apos;t change it

Object.defineProperty(obj, &apos;x&apos;, {writable:true, configurable:true, value : 100});
obj.x; // 100
obj.x = 500;
obj.x; // 500
</code></pre><h2 id="属性特性"><a href="#属性特性" class="headerlink" title="属性特性"></a>属性特性</h2><p>数据属性具有四个特性：value、writable、enumerable、configurable</p>
<p>存取器属性具有四个特性：set、get、enumerable、configurable</p>
<h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h3><p>可以获取某个对象特定属性的属性描述符,如：</p>
<pre><code>var o = {x:1, get y(){}, set y(value){}}
// { value: 1, writable: true, enumerable: true, configurable: true }
Object.getOwnPropertyDescriptor(o, &quot;x&quot;); 

// { get: [Function: y], set: [Function: y], enumerable: true, configurable: true } 
Object.getOwnPropertyDescriptor(o, &quot;y&quot;);
</code></pre><p>对于不存在和继承的属性，返回undefined，如：</p>
<pre><code>Object.getOwnPropertyDescriptor(o, &quot;z&quot;); // undefined
Object.getOwnPropertyDescriptor(o, &quot;toString&quot;); // undefined
</code></pre><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><p>此方法是设置属性的特性，或者让新建对象具有某种特性，使用这种方法设置的属性，如果没有定义的特性，则默认为false，先看一个例子：</p>
<pre><code>Object.getOwnPropertyDescriptor({pro : true}, &apos;pro&apos;);
// Object {value: true, writable: true, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor({pro : true}, &apos;a&apos;); // undefined
</code></pre><p>再看一个例子：</p>
<pre><code>var person = {};
Object.defineProperty(person, &apos;name&apos;, {
    configurable : false,
    writable : false,
    enumerable : true,
    value : &quot;Bosn Ma&quot;
});

person.name; // Bosn Ma
person.name = 1;
person.name; // still Bosn Ma
delete person.name; // false，因为name特性为不可配置
</code></pre><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>Object.keys(person)获取person的所有可枚举自有属性，如：</p>
<pre><code>Object.defineProperty(person, &apos;type&apos;, {
    configurable : true,
    writable : true,
    enumerable : false,
    value : &quot;Object&quot;
});

Object.keys(person); // 只有[&quot;name&quot;]
</code></pre><h3 id="Object-defineProperties-定义多个对象"><a href="#Object-defineProperties-定义多个对象" class="headerlink" title="Object.defineProperties()定义多个对象"></a>Object.defineProperties()定义多个对象</h3><pre><code>Object.defineProperties(person, {
    title : {value : &apos;fe&apos;, enumerable : true},
    corp : {value : &apos;BABA&apos;, enumerable : true},
    salary : {value : 50000, enumerable : true, writable : true}
});

Object.getOwnPropertyDescriptor(person, &apos;salary&apos;);
// Object {value: 50000, writable: true, enumerable: true, configurable: false}
</code></pre><h3 id="特征定义"><a href="#特征定义" class="headerlink" title="特征定义"></a>特征定义</h3><p>configurable主要控制是否可以delete、是否可以修改get/set方法，是否可以修改特征值（如writable和configurable）的属性。</p>
<p>writable主要控制属性值是否可以修改值。</p>
<p><strong>注意</strong>：有一个特例，当configurable为false时，writable可以从true修改为false，其他情况都不能配置特征的值。</p>
<h2 id="对象本身特征与序列化（待整理修改）"><a href="#对象本身特征与序列化（待整理修改）" class="headerlink" title="对象本身特征与序列化（待整理修改）"></a>对象本身特征与序列化（待整理修改）</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>获取对象的原型，使用Object.getPrototypeOf(),只会返回原型，不会返回原型链，如</p>
<pre><code>var o = { x:1, y:2};
var p = new Array();
var q = Object.create(o);

Object.getPrototypeOf(o); // {}
Object.getPrototypeOf(p); // []
Object.getPrototypeOf(q); // {x:1, y:2}
</code></pre><p>判断x是否为y的原型，使用x.isPrototypeof(y)</p>
<pre><code>var o = {x:1}
var p = Object.create(o);

o.isPrototypeOf(p); // true
Object.prototype.isPrototypeOf(p); // true
</code></pre><h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>对象的类属性是一个字符串，用以表示对象的类型信息，如：</p>
<pre><code>var toString = Object.prototype.toString;
function getType(o){return toString.call(o).slice(8,-1);};


toString.call(null); // &quot;[object Null]&quot;
getType(null); // &quot;Null&quot;
getType(undefined); // &quot;Undefined&quot;
getType(1); // &quot;Number&quot;
getType(new Number(1)); // &quot;Number&quot;
typeof new Number(1); // &quot;object&quot;
getType(true); // &quot;Boolean&quot;
getType(new Boolean(true)); // &quot;Boolean&quot;
</code></pre><p>其中new Number(1)为Object Number</p>
<h3 id="extensible"><a href="#extensible" class="headerlink" title="extensible"></a>extensible</h3><p>Object.preventExtensions会设置对象是否不可扩展，如：</p>
<pre><code>var obj = {x : 1, y : 2};
Object.isExtensible(obj); // true
Object.preventExtensions(obj);
Object.isExtensible(obj); // false
obj.z = 1;
obj.z; // undefined, add new property failed
Object.getOwnPropertyDescriptor(obj, &apos;x&apos;);
// Object {value: 1, writable: true, enumerable: true, configurable: true}
</code></pre><p><code>Object.seal</code>会在<code>preventExtensions</code>基础上添加<code>configurable:false</code>特征，如：</p>
<pre><code>Object.seal(obj);
Object.getOwnPropertyDescriptor(obj, &apos;x&apos;);
// Object {value: 1, writable: true, enumerable: true, configurable: false}
Object.isSealed(obj); // true
</code></pre><p><code>Object.freeze</code>会在<code>preventExtensions</code>基础上添加<code>configurable:false，writable:false</code>特征，如：</p>
<pre><code>Object.freeze(obj);
Object.getOwnPropertyDescriptor(obj, &apos;x&apos;);
// Object {value: 1, writable: false, enumerable: true, configurable: false}
Object.isFrozen(obj); // true
</code></pre><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>对象系列化可以使用<code>JSON.stringfy(obj)</code>,如：</p>
<pre><code>var obj = {x : 1, y : true, z : [1, 2, 3], nullVal : null};
JSON.stringify(obj); // &quot;{&quot;x&quot;:1,&quot;y&quot;:true,&quot;z&quot;:[1,2,3],&quot;nullVal&quot;:null}&quot;
</code></pre><p>序列化的一个属性值为<code>undefined</code>时，会忽略；时间对象会转化为UTC格式；<code>NaN/infinity</code>会转化为<code>null</code>，如：</p>
<pre><code>obj = {val : undefined, a : NaN, b : Infinity, c : new Date()};
JSON.stringify(obj); // &quot;{&quot;a&quot;:null,&quot;b&quot;:null,&quot;c&quot;:&quot;2015-01-20T14:15:43.910Z&quot;}&quot;
</code></pre><p>JSON转化为javascipt对象，需要用引号引起来，如：</p>
<pre><code>obj = JSON.parse(&apos;{&quot;x&quot; : 1}&apos;);
obj.x; // 1
</code></pre><p>自定义：</p>
<pre><code>var obj = {
    x : 1,
    y : 2,
    o : {
        o1 : 1,
        o2 : 2,
        toJSON : function () {
            return this.o1 + this.o2;
        }
    }
};
JSON.stringify(obj); // &quot;{&quot;x&quot;:1,&quot;y&quot;:2,&quot;o&quot;:3}&quot;
</code></pre><p>定义自己对象上的toString方法和valueOf方法，如：</p>
<pre><code>var obj = {x : 1, y : 2};
obj.toString(); // &quot;[object Object]&quot;
obj.toString = function() {return this.x + this.y};
&quot;Result &quot; + obj; // &quot;Result 3&quot;, by toString

+obj; // 3, from toString

obj.valueOf = function() {return this.x + this.y + 100;};
+obj; // 103, from valueOf

&quot;Result &quot; + obj; // still &quot;Result 3&quot;
</code></pre><p>如果运算的对象的<code>valueof</code>和<code>toString</code>都存在，当进行一元‘+’和二元‘+’运算的时候，会进行转换字符串的操作；</p>
<p>如果<code>valueOf</code>方法存在返回的是基本类型的值，以<code>valueOf</code>的值为结果，反之，valueOf不存在或者返回的是对象，则会去找<code>toString</code>方法，如果两者都不存在或者返回对象，就会报错。</p>
<p>不过一般都会继承<code>Object.prototype.toString</code>的方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/04/16/life_Epitaph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/16/life_Epitaph/" itemprop="url">伦敦威斯敏斯特教堂一墓志铭</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-16T00:00:00+08:00">
                2015-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书/" itemprop="url" rel="index">
                    <span itemprop="name">读书</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在伦敦威斯敏斯特教堂旁，矗立着一块墓碑上书：</p>
<p>“当我年轻时，我梦想改变这个世界；<br>当我成熟后，我发现我不能改变这个世界，我决定只改变我的国家；<br>当我进入暮年，我发现我不能改变我们的国家，我的最后愿望仅仅是改变一下我的家庭，但是，这也不可能。</p>
<p>当我现在躺在床上，行将就木，我突然意识到：如果一开始我仅仅去改变我自己，然后，我可能改变我的家庭；<br>在家人的帮助和鼓励下，我可能为国家做一些事情；<br>然后，谁知道呢？我甚至可能改变这个世界。” </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/abu.jpg"
                alt="cauil" />
            
              <p class="site-author-name" itemprop="name">cauil</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/cauil" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/cauil" target="_blank" title="Weibo">
                    
                      <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://douban.com/people/cauil" target="_blank" title="DouBan">
                    
                      <i class="fa fa-fw fa-douban"></i>DouBan</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cauil</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
