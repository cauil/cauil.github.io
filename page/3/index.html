<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Cauil&#39;s Blog">
<meta property="og:url" content="http://cauil.github.io/page/3/index.html">
<meta property="og:site_name" content="Cauil&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cauil&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://cauil.github.io/page/3/"/>





  <title>Cauil's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cauil's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">陌上花开，可缓缓归矣</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/09/07/2017-09-07-谈谈遍历与迭代协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/07/2017-09-07-谈谈遍历与迭代协议/" itemprop="url">谈谈遍历与迭代协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-07T00:00:00+08:00">
                2017-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="谈谈遍历与迭代"><a href="#谈谈遍历与迭代" class="headerlink" title="谈谈遍历与迭代"></a>谈谈遍历与迭代</h1><p>其实遍历与迭代是意义很近的一组词，但为啥要要把它们都列出来呢？先要从遍历说起：</p>
<h2 id="遍历在js中的形式"><a href="#遍历在js中的形式" class="headerlink" title="遍历在js中的形式"></a>遍历在js中的形式</h2><h4 id="The-for-loop"><a href="#The-for-loop" class="headerlink" title="The for loop"></a>The for loop</h4><p><code>for</code>循环是最普遍的遍历方式, 下面是一个简单的栗子；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];</div><div class="line"></div><div class="line">for (let i = 0; i &lt; digits.length; i++) &#123;</div><div class="line">  console.log(digits[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>for循环的不足之处就是必须维护计数器i与退出条件<code>digits.length</code>, 对刚学习编程的人来说，<br>这可能有点困惑，不能一眼看出这是在做啥；</p>
<p>还有一点是<code>for</code>循环很适合数组类型，但是<code>js</code>不只是只有数组类型，因此<code>for</code>循环不是一个所有类型的解决方案.</p>
<h4 id="The-for…in-loop"><a href="#The-for…in-loop" class="headerlink" title="The for…in loop"></a>The for…in loop</h4><p><code>for...in</code>循环优化了for循环的不足之处-需要维护计数器的变化与退出条件；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];</div><div class="line"></div><div class="line">for (const index in digits) &#123;</div><div class="line">  console.log(digits[index]);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>并且这对对象也是适用的，但是这个遍历方式也有一些问题:</p>
<p>正如上面<code>code</code>中，遍历的是计数器，当需要每个<code>value</code>值的时候，需要重新取值<code>digits[index]</code>;</p>
<p>并且for…in会把所有的可枚举属性遍历出来，如增加到原型链上的方法，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Array.prototype.decimalfy = function() &#123;</div><div class="line">  for (let i = 0; i &lt; this.length; i++) &#123;</div><div class="line">    this[i] = this[i].toFixed(2);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];</div><div class="line"></div><div class="line">for (const index in digits) &#123;</div><div class="line">  console.log(digits[index]);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 输出</div><div class="line">// 0 1 2 3 4 5 6 7 8 9 </div><div class="line">/*</div><div class="line">function() &#123;</div><div class="line"> for (let i = 0; i &lt; this.length; i++) &#123;</div><div class="line">  this[i] = this[i].toFixed(2);</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>这也是for…in没有在js程序员中普遍流行的原因;</p>
<blockquote>
<p>注意：forEach方法也是js遍历数组的一种方法，forEach实际上是一个数组方法，因而一般<br>适用在数组上，并且没有方法跳出循环；</p>
</blockquote>
<h4 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h4><p>直接看一个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(let v of &apos;hello&apos;)&#123;</div><div class="line">    console.log(v);</div><div class="line">&#125;</div><div class="line">// h e l l o</div></pre></td></tr></table></figure></p>
<p>for…of是针对<em>集合</em>(注意:非set而是collections)，而不是所有的对象，适用范围是iterable对象；</p>
<p>什么是iterable对象？</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>程序员是一群不停折腾的物种，为了更加方便的遍历，在ES6引入了迭代协议；迭代协议有两种：</p>
<ul>
<li>iterable协议</li>
<li>iterator协议</li>
</ul>
<p>由于这次主题是讲遍历与迭代，所以只涉及第一种协议; </p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>什么是iterable, ECMA官方文档是如下定义的：</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>[Symbol.iterator]</td>
<td>A zero arguments function that returns an object, conforming to the iterator protocol.</td>
<td></td>
</tr>
</tbody>
</table>
<p>也就是说只要具有[Symbol.iterator]属性，并且其值是一个0参数函数，这个函数执行返回的是一个符合iterator协议的对象,<br>符合上述条件的对象就是一个可迭代对象；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = []</div><div class="line">typeof a[Symbol.iterator] // function</div><div class="line">a[Symbol.iterator]() // Array Iterator &#123;&#125;</div></pre></td></tr></table></figure>
<h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h4><p>目前JS内置的可迭代对象有String, Array, Map, Set, TypedArray, arguments等；需要注意的是普通的obj是不能迭代的；</p>
<h4 id="几个用法"><a href="#几个用法" class="headerlink" title="几个用法"></a>几个用法</h4><p>遍历：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var someString = &apos;hi&apos;;</div><div class="line">for(let v of something) &#123;</div><div class="line">    console.log(v);</div><div class="line">&#125;</div><div class="line">// h i</div></pre></td></tr></table></figure>
<p>适用于元素展开:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var set1 = new Set([0, 1, 2]);</div><div class="line">var set2 = new Set([2, 3, 4, 5]);</div><div class="line">var arr = [...set1, ...set2]; // [0, 1, 2, 2, 3, 4, 5]</div></pre></td></tr></table></figure></p>
<p>转换数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Array.from(new Set([&apos;a&apos;, 1, &apos;b&apos;, 2]))</div></pre></td></tr></table></figure></p>
<p>转换成生成器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3];</div><div class="line">var iter = arr[Symbol.iterator]();</div><div class="line">iter.next(); // &#123;value: 1, done: false&#125;</div><div class="line">iter.next(); // &#123;value: 2, done: false&#125;</div><div class="line">iter.next(); // &#123;value: 3, done: false&#125;</div><div class="line">iter.next(); // &#123;value: undefined, done: true&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2016/02/21/linkedList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/21/linkedList/" itemprop="url">leetcode之linked list</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-21T00:00:00+08:00">
                2016-02-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="链表javascript实现"><a href="#链表javascript实现" class="headerlink" title="链表javascript实现"></a>链表javascript实现</h2><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺<br>序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度<br>分别是O(logn)和O(1)。</p>
<p>javascript实现可以通过下面的方法：</p>
<pre><code>function ListNode(val) {
    this.val = val;
    this.next = null;
}
</code></pre><p>下面我们看看链表题目的基本类型:</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除的题目有19, 83, 203, 237, 82</p>
<p>删除其实就是找到要删除元素的前一个元素pre;</p>
<pre><code>pre.next = pre.next.next;
</code></pre><p>不过还有一种是假删除，找前一个元素比较麻烦，我们可以直接把要删除元素的下一个元素的值赋给当前删除，然后删除下一个元素；</p>
<pre><code>cur.val = cur.next.val;
cur.next = cur.next.next;
</code></pre><p>看一个典型例题<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="external">19. Remove Nth Node From End of List</a>:</p>
<p>Given a linked list, remove the nth node from the end of list and return its head.<br>For example,</p>
<pre><code>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.
After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.
</code></pre><p>这个题目我们可以通过设置两个变量，fast变量先走n步，然后fast和slow变量同时走，直到fast为null; 此时slow就是到达了倒数第n个元素，执行删除即可；代码如下：</p>
<pre><code>var removeNthFromEnd = function(head, n) {
    var left, before, right = head;
    left = before = {next: head}; 
    while (n--) right = right.next;
    while (right) {
        right = right.next;
        left = left.next;
    }
    left.next = left.next.next;
    return before.next;
};
</code></pre><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找题目有：160, 141, 142</p>
<p>我们来看看<a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="external">141. Linked List Cycle</a>，判断是否🈶️环，我们可以通过设置两个指针fast和slow，slow一次走一步，fast一次走两部，如果🈶️环，fast必定在环内追上slow；于是：</p>
<pre><code>var hasCycle = function(head) {
    var slow = head;
    var fast = head;

    while(fast &amp;&amp; fast.next) {
        fast = fast.next.next;
        slow = slow.next;
        if(fast === slow) {
            return true;
        }
    }
    return false;
};
</code></pre><h2 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h2><p>翻转题目有234，206，24，92，61</p>
<p><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="external">234. Palindrome Linked List</a>其实是一个判断是否是回文的题目，但是我们可以利用翻转来判断；</p>
<p>首先利用两个变量来找到中间点，然后分为两个链表，把后面的链表翻转过来，并同时遍历两个链表比较：</p>
<pre><code>var isPalindrome = function(head) {
    function reverse(curr) {
        var prev = null;
        var next;
        while(curr) {
            next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
    var fast = head;
    var slow = head;
    while(fast &amp;&amp; fast.next) {
        fast = fast.next.next;
        slow = slow.next;
    }
    if(fast) slow = slow.next;

    slow = reverse(slow);
    while(slow &amp;&amp; head.val === slow.val) {
        head = head.next;
        slow = slow.next;
    }
    return slow === null;
};
</code></pre><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>合并的题目有：21，328，86，148，2，92，143</p>
<p><a href="https://leetcode.com/problems/partition-list/" target="_blank" rel="external">86. Partition List</a>这个题目是让我们把指定元素后面的都小于它的元素放到指定元素前面去；</p>
<p>我们可以设置两个表头，遍历链表，把小于指定元素的链接到第一个表，反之，链接到第二个表，最后把第二个链表链接到第一个链表后面；</p>
<pre><code>var partition = function(head, x) {
    var hd1 = new ListNode(0);
    var hd2 = new ListNode(0);
    var p1 = hd1;
    var p2 = hd2;
    while(head) {
        if(head.val &lt; x) {
            p1.next = head;
            p1 = p1.next;
        } else {
            p2.next = head;
            p2 = p2.next;
        }
        head = head.next;
    }
    p2.next = null;
    p1.next = hd2.next;
    return hd1.next;
};
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实链表的操作就是那几种：删除／查找／翻转／合并, 只要掌握链表的基本操作并配合标记或者特定题目的一些特性，基本都可以解决；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/12/27/DiveIntoJs_core/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/27/DiveIntoJs_core/" itemprop="url">深入理解Javascript： JavaScript核心</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-27T00:00:00+08:00">
                2015-12-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近本来准备把JS的对象、类、原型继承、作用域链、闭包以及this都写一下的，发现一篇文章写的太好了，就直接转载过来。</p>
<p>作者: JeremyWei | 可以转载, 但必须以超链接形式标明文章原始出处和作者信息及版权声明</p>
<p>网址: <a href="http://weizhifeng.net/javascript-the-core.html" target="_blank" rel="external">http://weizhifeng.net/javascript-the-core.html</a></p>
<p>最原始地址：<a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/" target="_blank" rel="external">http://dmitrysoshnikov.com/ecmascript/javascript-the-core/</a></p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><p>这篇文章是「深入ECMA-262-3」系列的一个概览和摘要。每个部分都包含了对应章节的链接，所以你可以阅读它们以便对其有更深的理解。</p>
<p>面向读者：经验丰富的程序员，专家。</p>
<p>我们以思考对象的概念做为开始，这是ECMAScript的基础。</p>
<h2 id="1-对象"><a href="#1-对象" class="headerlink" title="1.对象"></a>1.对象</h2><p>ECMAScript做为一个高度抽象的面向对象语言，是通过对象来交互的。即使ECMAScript里边也有基本类型，但是，当需要的时候，它们也会被转换成对象。</p>
<pre><code>一个对象就是一个属性集合，并拥有一个独立的prototype（原型）对象。这个prototype可以是一个对象或者null。
</code></pre><p>让我们看一个关于对象的基本例子。一个对象的prototype是以内部的[[Prototype]]属性来引用的。但是，在示意图里边我们将会使用<code>__&lt;internal-property&gt;__</code>下划线标记来替代两个括号，对于prototype对象来说是：<code>__proto__</code>。</p>
<p>对于以下代码：</p>
<pre><code>var foo = {
  x: 10,
  y: 20
};
</code></pre><p>我们拥有一个这样的结构，两个明显的自身属性和一个隐含的<code>__proto__</code>属性，这个属性是对foo原型对象的引用：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/basic-object.png" alt="基本对象"></p>
<p>这些prototype有什么用？让我们以<em>原型链</em>（prototype chain）的概念来回答这个问题。</p>
<h2 id="2-原型链"><a href="#2-原型链" class="headerlink" title="2.原型链"></a>2.原型链</h2><p>原型对象也是简单的对象并且可以拥有它们自己的原型。如果一个原型对象的原型是一个非null的引用，那么以此类推，这就叫作<em>原型链</em>。</p>
<pre><code>原型链是一个用来实现继承和共享属性的有限对象链。
</code></pre><p>考虑这么一个情况，我们拥有两个对象，它们之间只有一小部分不同，其他部分都相同。显然，对于一个设计良好的系统，我们将会重用相似的功能/代码，而不是在每个单独的对象中重复它。在基于类的系统中，这个代码重用风格叫作类继承－你把相似的功能放入类 A中，然后类 B和类 C继承类 A，并且拥有它们自己的一些小的额外变动。</p>
<p>ECMAScript中没有类的概念。但是，代码重用的风格并没有太多不同（尽管从某些方面来说比基于类（class-based）的方式要更加灵活）并且通过<em>原型链</em>来实现。这种继承方式叫作<em>委托继承</em>(delegation based inheritance)（或者，更贴近ECMAScript一些，叫作<em>原型继承</em>(prototype based inheritance)）。</p>
<p>跟例子中的类A，B，C相似，在ECMAScript中你创建对象：a，b，c。于是，对象a中存储对象b和c中通用的部分。然后b和c只存储它们自身的额外属性或者方法。</p>
<pre><code>var a = {
  x: 10,
  calculate: function (z) {
    return this.x + this.y + z
  }
};

var b = {
  y: 20,
  __proto__: a
};

var c = {
  y: 30,
  __proto__: a
};

// call the inherited method
b.calculate(30); // 60
c.calculate(40); // 80
</code></pre><p>足够简单，是不是？我们看到b和c访问到了在对象a中定义的<code>calculate</code>方法。这是通过原型链实现的。</p>
<p>规则很简单：如果一个属性或者一个方法在对象<em>自身</em>中无法找到（也就是对象自身没有一个那样的属性），然后它会尝试在原型链中寻找这个属性/方法。如果这个属性在原型中没有查找到，那么将会查找这个原型的原型，以此类推，遍历整个原型链（当然这在类继承中也是一样的，当解析一个继承的方法的时候－我们遍历<em>class链</em>（ class chain））。第一个被查找到的同名属性/方法会被使用。因此，一个被查找到的属性叫作<em>继承</em>属性。如果在遍历了整个原型链之后还是没有查找到这个属性的话，返回<code>undefined</code>值。</p>
<p>注意，继承方法中所使用的this的值被设置为<em>原始对象</em>，而并不是在其中查找到这个方法的（原型）对象。也就是，在上面的例子中<code>this.y</code>取的是b和c中的值，而不是a中的值。但是，<code>this.x</code>是取的是a中的值，并且又一次通过<em>原型链</em>机制完成。</p>
<p>如果没有明确为一个对象指定原型，那么它将会使用<strong>proto</strong>的默认值－<code>Object.prototype。Object.prototype</code>对象自身也有一个<code>__proto__</code>属性，这是原型链的<em>终点</em>并且值为null。</p>
<p>下一张图展示了对象a，b，c之间的继承层级：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/prototype-chain.png" alt="原型链"></p>
<p>注意： ES5标准化了一个实现原型继承的可选方法，即使用<code>Object.create</code>函数：</p>
<pre><code>var b = Object.create(a, {y: {value: 20}});
var c = Object.create(a, {y: {value: 30}});
</code></pre><p>你可以在对应的章节获取到更多关于ES5新API的信息。 ES6标准化了 <code>__proto__</code>属性，并且可以在对象初始化的时候使用它。</p>
<p>通常情况下需要对象拥有<em>相同或者相似的状态结构</em>（也就是相同的属性集合），赋以不同的状态值。在这个情况下我们可能需要使用<em>构造函数</em>(constructor function)，其以<em>指定的模式</em>来创造对象。</p>
<h2 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3.构造函数"></a>3.构造函数</h2><p>除了以指定模式创建对象之外，<em>构造函数</em>也做了另一个有用的事情－<em>它自动地为新创建的对象设置一个原型对象</em>。这个原型对象存储在<code>ConstructorFunction.prototype</code>属性中。</p>
<p>换句话说，我们可以使用构造函数来重写上一个拥有对象b和对象c的例子。因此，对象a（一个原型对象）的角色由<code>Foo.prototype</code>来扮演：</p>
<pre><code>// a constructor function
function Foo(y) {
  // which may create objects
  // by specified pattern: they have after
  // creation own &quot;y&quot; property
  this.y = y;
}

// also &quot;Foo.prototype&quot; stores reference
// to the prototype of newly created objects,
// so we may use it to define shared/inherited
// properties or methods, so the same as in
// previous example we have:

// inherited property &quot;x&quot;
Foo.prototype.x = 10;

// and inherited method &quot;calculate&quot;
Foo.prototype.calculate = function (z) {
  return this.x + this.y + z;
};

// now create our &quot;b&quot; and &quot;c&quot;
// objects using &quot;pattern&quot; Foo
var b = new Foo(20);
var c = new Foo(30);

// call the inherited method
b.calculate(30); // 60
c.calculate(40); // 80

// let&apos;s show that we reference
// properties we expect

console.log(

  b.__proto__ === Foo.prototype, // true
  c.__proto__ === Foo.prototype, // true

  // also &quot;Foo.prototype&quot; automatically creates
  // a special property &quot;constructor&quot;, which is a
  // reference to the constructor function itself;
  // instances &quot;b&quot; and &quot;c&quot; may found it via
  // delegation and use to check their constructor

  b.constructor === Foo, // true
  c.constructor === Foo, // true
  Foo.prototype.constructor === Foo // true

  b.calculate === b.__proto__.calculate, // true
  b.__proto__.calculate === Foo.prototype.calculate // true

);
</code></pre><p>这个代码可以表示为如下关系：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/constructor-proto-chain.png" alt="constructor-proto-chain"></p>
<p>这张图又一次说明了每个对象都有一个原型。构造函数Foo也有自己的<code>__proto__</code>，值为<code>Function.prototype</code>，<code>Function.prototype</code>也通过其<code>__proto__</code>属性关联到<code>Object.prototype</code>。因此，重申一下，<code>Foo.prototype</code>就是Foo的一个明确的属性，指向对象b和对象c的原型。</p>
<p>正式来说，如果思考一下<em>分类</em>的概念（并且我们已经对Foo进行了<em>分类</em>），那么构造函数和原型对象合在一起可以叫作「类」。实际上，举个例子，Python的第一级（first-class）动态类（dynamic classes）显然是以同样的属性/方法处理方案来实现的。从这个角度来说，Python中的类就是ECMAScript使用的委托继承的一个语法糖。</p>
<p>注意: 在ES6中「类」的概念被标准化了，并且实际上以一种构建在构造函数上面的语法糖来实现，就像上面描述的一样。从这个角度来看原型链成为了类继承的一种具体实现方式：</p>
<pre><code>// ES6
class Foo {
  constructor(name) {
    this._name = name;
  }

  getName() {
    return this._name;
  }
}

class Bar extends Foo {
  getName() {
    return super.getName() + &apos; Doe&apos;;
  }
}

var bar = new Bar(&apos;John&apos;);
console.log(bar.getName()); // John Doe
</code></pre><p>有关这个主题的完整、详细的解释可以在ES3系列的第七章找到。分为两个部分：<a href="http://dmitrysoshnikov.com/ecmascript/chapter-7-1-oop-general-theory/" target="_blank" rel="external">7.1 面向对象.基本理论</a>，在那里你将会找到对各种面向对象范例、风格的描述以及它们和ECMAScript之间的对比，然后在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-7-2-oop-ecmascript-implementation/" target="_blank" rel="external">7.2 面向对象.ECMAScript实现</a>，是对ECMAScript中面向对象的介绍。</p>
<p>现在，在我们知道了对象的基础之后，让我们看看<em>运行时程序的执行</em>（runtime program execution）在ECMAScript中是如何实现的。这叫作<em>执行上下文栈</em>（execution context stack），其中的每个元素也可以抽象成为一个对象。是的，ECMAScript几乎在任何地方都和对象的概念打交道;)</p>
<h2 id="4-执行上下文堆栈"><a href="#4-执行上下文堆栈" class="headerlink" title="4.执行上下文堆栈"></a>4.执行上下文堆栈</h2><p>这里有三种类型的ECMAScript代码：<em>全局代码</em>、<em>函数代码</em>和<em>eval代码</em>。每个代码是在其<em>执行上下文</em>（execution context）中被求值的。这里只有一个全局上下文，可能有多个函数执行上下文以及<em>eval</em>执行上下文。对一个函数的每次调用，会进入到函数执行上下文中，并对函数代码类型进行求值。每次对<code>eval</code>函数进行调用，会进入<em>eval</em>执行上下文并对其代码进行求值。</p>
<p>注意，一个函数可能会创建无数的上下文，因为对函数的每次调用（即使这个函数递归的调用自己）都会生成一个具有新状态的上下文：</p>
<pre><code>function foo(bar) {}

// call the same function,
// generate three different
// contexts in each call, with
// different context state (e.g. value
// of the &quot;bar&quot; argument)

foo(10);
foo(20);
foo(30);
</code></pre><p>一个执行上下文可能会触发另一个上下文，比如，一个函数调用另一个函数（或者在全局上下文中调用一个全局函数），等等。从逻辑上来说，这是以栈的形式实现的，它叫作<em>执行上下文栈</em>。</p>
<p>一个触发其他上下文的上下文叫作<em>caller</em>。被触发的上下文叫作<em>callee</em>。callee在同一时间可能是一些其他callee的caller（比如，一个在全局上下文中被调用的函数，之后调用了一些内部函数）。</p>
<p>当一个caller触发（调用）了一个callee，这个caller会暂缓自身的执行，然后把控制权传递给callee。这个callee被push到栈中，并成为一个运行中（活动的）执行上下文。在callee的上下文结束后，它会把控制权返回给caller，然后caller的上下文继续执行（它可能触发其他上下文）直到它结束，以此类推。callee可能简单的返回或者由于异常而退出。一个抛出的但是没有被捕获的异常可能退出（从栈中pop）一个或者多个上下文。</p>
<p>换句话说，所有ECMAScript<em>程序的运行时</em>可以用<em>执行上下文（EC）栈</em>来表示，<em>栈顶</em>是当前<em>活跃</em>(active)上下文：</p>
<p>当程序开始的时候它会进入<em>全局执行上下文</em>，此上下文位于<em>栈底</em>并且是栈中的<em>第一个元素</em>。然后全局代码进行一些初始化，创建需要的对象和函数。在全局上下文的执行过程中，它的代码可能触发其他（已经创建完成的）函数，这些函数将会进入它们自己的执行上下文，向栈中push新的元素，以此类推。当初始化完成之后，运行时系统（runtime system）就会等待一些<em>事件</em>（比如，用户鼠标点击），这些事件将会触发一些函数，从而进入新的执行上下文中。</p>
<p>在下个图中，拥有一些函数上下文<code>EC1</code>和全局上下文<code>Global EC</code>，当EC1进入和退出全局上下文的时候下面的栈将会发生变化：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/ec-stack-changes.png" alt="ec-stack-changes"></p>
<p>这就是ECMAScript的运行时系统如何真正地管理代码执行的。</p>
<p>更多有关ECMAScript中执行上下文的信息可以在对应的<a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/" target="_blank" rel="external">第一章 执行上下文</a>中获取。</p>
<p>像我们所说的，栈中的每个执行上下文都可以用一个对象来表示。让我们来看看它的结构以及一个上下文到底需要什么<em>状态</em>（什么属性）来执行它的代码。</p>
<h2 id="5-执行上下文"><a href="#5-执行上下文" class="headerlink" title="5.执行上下文"></a>5.执行上下文</h2><p>一个执行上下文可以抽象的表示为一个简单的对象。每一个执行上下文拥有一些属性（可以叫作<em>上下文状态</em>）用来跟踪和它相关的代码的执行过程。在下图中展示了一个上下文的结构：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/execution-context.png" alt="execution-context"></p>
<p>除了这三个必需的属性（一个<em>变量对象</em>（variable objec），一个<em>this</em>值以及一个<em>作用域链</em>（scope chain））之外，执行上下文可以拥有任何附加的状态，这取决于实现。</p>
<p>让我们详细看看上下文中的这些重要的属性。</p>
<h2 id="6-变量对象"><a href="#6-变量对象" class="headerlink" title="6.变量对象"></a>6.变量对象</h2><pre><code>变量对象是与执行上下文相关的数据作用域。它是一个与上下文相关的特殊对象，其中存储了在上下文中定义的变量和函数声明。
</code></pre><p>注意，<em>函数表达式</em>（与<em>函数声明</em>相对）不包含在变量对象之中。</p>
<p>变量对象是一个抽象概念。对于不同的上下文类型，在物理上，是使用不同的对象。比如，在全局上下文中变量对象就是<em>全局对象本身</em>（这就是为什么我们可以通过全局对象的属性名来关联全局变量）。</p>
<p>让我们在全局执行上下文中考虑下面这个例子：</p>
<pre><code>var foo = 10;

function bar() {} // function declaration, FD
(function baz() {}); // function expression, FE

console.log(
  this.foo == foo, // true
  window.bar == bar // true
);

console.log(baz); // ReferenceError, &quot;baz&quot; is not defined
</code></pre><p>之后，全局上下文的变量对象（variable objec，简称VO）将会拥有如下属性：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/variable-object.png" alt="variable-object"></p>
<p>再看一遍，函数<code>baz</code>是一个<em>函数表达式</em>，没有被包含在变量对象之中。这就是为什么当我们想要在函数自身之外访问它的时候会出现<code>ReferenceError</code>。</p>
<p>注意，与其他语言（比如C/C++）相比，在ECMAScript中只有函数可以创建一个新的作用域。在函数作用域中所定义的变量和内部函数在函数外边是不能直接访问到的，而且并不会污染全局变量对象。</p>
<p>使用<code>eval</code>我们也会进入一个新的（eval类型）执行上下文。无论如何，<code>eval</code>使用全局的变量对象或者使用caller（比如<code>eval</code>被调用时所在的函数）的变量对象。</p>
<p>那么函数和它的变量对象是怎么样的？在函数上下文中，变量对象是以<em>活动对象</em>（activation object）来表示的。</p>
<h2 id="7-活动对象"><a href="#7-活动对象" class="headerlink" title="7.活动对象"></a>7.活动对象</h2><p>当一个函数被caller所<em>触发</em>（被调用），一个特殊的对象，叫作<em>活动对象</em>（activation object）将会被创建。这个对象中包含<em>形参</em>和那个特殊的<code>arguments对象</code>（是对形参的一个映射，但是值是通过索引来获取）。<em>活动对象</em>之后会做为函数上下文的<em>变量对象</em>来使用。</p>
<p>换句话说，函数的变量对象也是一个同样简单的变量对象，但是除了变量和函数声明之外，它还存储了形参和<code>arguments对象</code>，并叫作<em>活动对象</em>。</p>
<p>考虑如下例子：</p>
<pre><code>function foo(x, y) {
  var z = 30;
  function bar() {} // FD
  (function baz() {}); // FE
}

foo(10, 20);
</code></pre><p>我们看下函数foo的上下文中的活动对象（activation object，简称AO）：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/activation-object.png" alt="activation-object"></p>
<p>并且<em>函数表达式</em><code>baz</code>还是没有被包含在变量/活动对象中。</p>
<p>关于这个主题所有细节方面（像变量和函数声明的<em>提升问题</em>（hoisting））的完整描述可以在同名的章节<a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/" target="_blank" rel="external">第二章 变量对象</a>中找到。</p>
<p>注意，在ES5中<em>变量对象</em>和<em>活动对象</em>被并入了<em>词法环境</em>模型（lexical environments model），详细的描述可以在<a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/" target="_blank" rel="external">对应的章节</a>找到。</p>
<p>然后我们向下一个部分前进。众所周知，在ECMAScript中我们可以使用<em>内部函数</em>，然后在这些内部函数我们可以引用父函数的变量或者全局上下文中的变量。当我们把变量对象命名为上下文的<em>作用域对象</em>，与上面讨论的原型链相似，这里有一个叫作<em>作用域链</em>的东西。</p>
<h2 id="8-作用域链"><a href="#8-作用域链" class="headerlink" title="8.作用域链"></a>8.作用域链</h2><pre><code>作用域链是一个对象列表，上下文代码中出现的标识符在这个列表中进行查找。
</code></pre><p>这个规则还是与原型链同样简单以及相似：如果一个变量在函数自身的作用域（在自身的变量/活动对象）中没有找到，那么将会查找它父函数（外层函数）的变量对象，以此类推。</p>
<p>就上下文而言，标识符指的是：<em>变量名称，函数声明，形参</em>，等等。当一个函数在其代码中引用一个不是局部变量（或者局部函数或者一个形参）的标识符，那么这个标识符就叫作<em>自由变量</em>。<em>搜索这些自由变量</em>(free variables)正好就要用到<em>作用域链</em>。</p>
<p>在通常情况下，<em>作用域链</em>是一个包含所有<em>父（函数）变量对象</em>__加上（在作用域链头部的）函数<em>自身变量/活动对象</em>的一个列表。但是，这个作用域链也可以包含任何其他对象，比如，在上下文执行过程中动态加入到作用域链中的对象－像<em>with对象</em>或者特殊的<em>catch从句</em>（catch-clauses）对象。</p>
<p>当<em>解析</em>（查找）一个标识符的时候，会从作用域链中的活动对象开始查找，然后（如果这个标识符在函数自身的活动对象中没有被查找到）向作用域链的上一层查找－重复这个过程，就和原型链一样。</p>
<pre><code>var x = 10;

(function foo() {
  var y = 20;
  (function bar() {
    var z = 30;
    // &quot;x&quot; and &quot;y&quot; are &quot;free variables&quot;
    // and are found in the next (after
    // bar&apos;s activation object) object
    // of the bar&apos;s scope chain
    console.log(x + y + z);
  })();
})();
</code></pre><p>我们可以假设通过隐式的<code>__parent__</code>属性来和作用域链对象进行关联，这个属性指向作用域链中的下一个对象。这个方案可能在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/#feature-of-implementations-property-__parent__" target="_blank" rel="external">真实的Rhino代码</a>中经过了测试，并且这个技术很明确得被用于ES5的词法环境中（在那里被叫作<code>outer</code>连接）。作用域链的另一个表现方式可以是一个简单的数组。利用<em><strong>parent</strong></em>概念，我们可以用下面的图来表现上面的例子（并且父变量对象存储在函数的[[Scope]]属性中）：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/scope-chain.png" alt="scope-chain"></p>
<p>在代码执行过程中，作用域链可以通过使用<code>with</code>语句和<code>catch</code>从句对象来增强。并且由于这些对象是简单的对象，它们可以拥有原型（和原型链）。这个事实导致作用域链查找变为<em>两个维度</em>：（1）首先是作用域链连接，然后（2）在每个作用域链连接上－深入作用域链连接的原型链（如果此连接拥有原型）。</p>
<p>对于这个例子：</p>
<pre><code>Object.prototype.x = 10;

var w = 20;
var y = 30;

// in SpiderMonkey global object
// i.e. variable object of the global
// context inherits from &quot;Object.prototype&quot;,
// so we may refer &quot;not defined global
// variable x&quot;, which is found in
// the prototype chain

console.log(x); // 10

(function foo() {

  // &quot;foo&quot; local variables
  var w = 40;
  var x = 100;

  // &quot;x&quot; is found in the
  // &quot;Object.prototype&quot;, because
  // {z: 50} inherits from it

  with ({z: 50}) {
    console.log(w, x, y , z); // 40, 10, 30, 50
  }

  // after &quot;with&quot; object is removed
  // from the scope chain, &quot;x&quot; is
  // again found in the AO of &quot;foo&quot; context;
  // variable &quot;w&quot; is also local
  console.log(x, w); // 100, 40

  // and that&apos;s how we may refer
  // shadowed global &quot;w&quot; variable in
  // the browser host environment
  console.log(window.w); // 20

})();
</code></pre><p>我们可以给出如下的结构（确切的说，在我们查找<code>__parent__</code>连接之前，首先查找<code>__proto__</code>链）：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/scope-chain-with.png" alt="scope-chain-with"></p>
<p>注意，不是在所有的实现中全局对象都是继承自<code>Object.prototype</code>。上图中描述的行为（从全局上下文中引用「未定义」的变量x）可以在诸如SpiderMonkey引擎中进行测试。</p>
<p>由于所有父变量对象都存在，所以在内部函数中获取父函数中的数据没有什么特别－我们就是遍历作用域链去解析（搜寻）需要的变量。就像我们上边提及的，在一个上下文结束之后，它所有的状态和它自身都会被销毁。在同一时间父函数可能会<em>返回</em>一个<em>内部函数</em>。而且，这个返回的函数之后可能在另一个上下文中被调用。如果自由变量的上下文已经「消失」了，那么这样的调用将会发生什么？通常来说，有一个概念可以帮助我们解决这个问题，叫作<em>（词法）闭包</em>，其在ECMAScript中就是和<em>作用域链</em>的概念紧密相关的。</p>
<h2 id="9-闭包"><a href="#9-闭包" class="headerlink" title="9.闭包"></a>9.闭包</h2><p>在ECMAScript中，函数是<em>第一级</em>（first-class）对象。这个术语意味着函数可以做为参数传递给其他函数（在那种情况下，这些参数叫作「函数类型参数」（funargs，是”functional arguments”的简称））。接收「函数类型参数」的函数叫作<em>高阶函数</em>或者，贴近数学一些，叫作高阶<em>操作符</em>。同样函数也可以从其他函数中返回。返回其他函数的函数叫作<em>以函数为值</em>（function valued）的函数（或者叫作拥有函数类<em>值的函数</em>（functions with functional value））。</p>
<p>这有两个在概念上与「函数类型参数（funargs）」和「函数类型值（functional　values）」相关的问题。并且这两个子问题在”<em>Funarg problem</em>“（或者叫作”functional argument”问题）中很普遍。为了解决<em>整个”funarg problem”</em>，<em>闭包</em>（closure）的概念被创造了出来。我们详细的描述一下这两个子问题（我们将会看到这两个问题在ECMAScript中都是使用图中所提到的函数的[[Scope]]属性来解决的）。</p>
<p>「funarg问题」的第一个子问题是<em>「向上funarg问题」</em>（upward funarg problem）。它会在当一个函数从另一个函数向上返回（到外层）并且使用上面所提到的<em>自由变量的</em>时候出现。为了在<em>即使父函数上下文结束</em>的情况下也能访问其中的变量，内部函数在<em>被创建的时候</em>会在它的[[Scope]]属性中保存父函数的<em>作用域链</em>。所以当函数被<em>调用</em>的时候，它上下文的作用域链会被格式化成活动对象与[[Scope]]属性的和（实际上就是我们刚刚在上图中所看到的）：</p>
<pre><code>Scope chain = Activation object + [[Scope]]
</code></pre><p>再次注意这个关键点－确切的说在<em>创建时刻</em>－函数会保存<em>父函数的</em>作用域链，因为确切的说这个<em>保存下来的作用域链</em>将会在未来的函数调用时用来查找变量。</p>
<pre><code>function foo() {
  var x = 10;
  return function bar() {
    console.log(x);
  };
}

// &quot;foo&quot; returns also a function
// and this returned function uses
// free variable &quot;x&quot;

var returnedFunction = foo();

// global variable &quot;x&quot;
var x = 20;

// execution of the returned function

returnedFunction(); // 10, but not 20
</code></pre><p>这个类型的作用域叫作<em>静态（或者词法）作用域</em>。我们看到变量x在返回的<code>bar</code>函数的[[Scope]]属性中被找到。通常来说，也存在<em>动态作用域</em>，那么上面例子中的变量x将会被解析成20，而不是10。但是，动态作用域在ECMAScript中没有被使用。</p>
<p>「funarg问题」的第二个部分是<em>「向下funarg问题」</em>。这种情况下可能会存在一个父上下文，但是在解析标识符的时候可能会模糊不清。问题是：标识符该使用<em>哪个作用域</em>的值－以静态的方式存储在函数创建时刻的还是在执行过程中以动态方式生成的（比如<em>caller</em>的作用域）？为了避免这种模棱两可的情况并形成闭包，<em>静态作用域</em>被采用：</p>
<pre><code>// global &quot;x&quot;
var x = 10;

// global function
function foo() {
  console.log(x);
}

(function (funArg) {

  // local &quot;x&quot;
  var x = 20;

  // there is no ambiguity,
  // because we use global &quot;x&quot;,
  // which was statically saved in
  // [[Scope]] of the &quot;foo&quot; function,
  // but not the &quot;x&quot; of the caller&apos;s scope,
  // which activates the &quot;funArg&quot;

  funArg(); // 10, but not 20

})(foo); // pass &quot;down&quot; foo as a &quot;funarg&quot;
</code></pre><p>我们可以断定<em>静态作用域</em>是一门语言拥有<em>闭包的必需条件</em>。但是，一些语言可能会同时提供动态和静态作用域，允许程序员做选择－什么应该包含（closure）在内和什么不应包含在内。由于在ECMAScript中只使用了静态作用域（比如我们对于<code>funarg问题</code>的两个子问题都有解决方案），所以结论是：<em>ECMAScript完全支持闭包</em>，技术上是通过函数的[[Scope]]属性实现的。现在我们可以给闭包下一个准确的定义：</p>
<pre><code>闭包是一个代码块（在ECMAScript是一个函数）和以静态方式/词法方式进行存储的所有父作用域的一个集合体。所以，通过这些存储的作用域，函数可以很容易的找到自由变量。
</code></pre><p>注意，由于<em>每个</em>（标准的）函数都在创建的时候保存了[[Scope]]，所以理论上来讲，ECMAScript中的<em>所有函数</em>都是<em>闭包</em>。</p>
<p>另一个需要注意的重要事情是，多个函数可能拥有<em>相同的父作用域</em>（这是很常见的情况，比如当我们拥有两个内部/全局函数的时候）。在这种情况下，<code>[[Scope]]</code>属性中存储的变量是在拥有相同父作用域链的<em>所有函数之间共享</em>的。一个闭包对变量进行的修改会<em>体现</em>在另一个闭包对这些变量的读取上：</p>
<pre><code>function baz() {
  var x = 1;
  return {
    foo: function foo() { return ++x; },
    bar: function bar() { return --x; }
  };
}

var closures = baz();

console.log(
  closures.foo(), // 2
  closures.bar()  // 1
);
</code></pre><p>以上代码可以通过下图进行说明：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/shared-scope.png" alt="shared-scope"></p>
<p>确切来说这个特性在循环中创建多个函数的时候会使人非常困惑。在创建的函数中使用循环计数器的时候，一些程序员经常会得到非预期的结果，所有函数中的计数器都是<em>同样</em>的值。现在是到了该揭开谜底的时候了－因为所有这些函数拥有同一个<code>[[Scope]]</code>，这个属性中的循环计数器的值是最后一次所赋的值。</p>
<pre><code>var data = [];

for (var k = 0; k &lt; 3; k++) {
  data[k] = function () {
    alert(k);
  };
}

data[0](); // 3, but not 0
data[1](); // 3, but not 1
data[2](); // 3, but not 2
</code></pre><p>这里有几种技术可以解决这个问题。其中一种是在作用域链中提供一个额外的对象－比如，使用额外函数：</p>
<pre><code>var data = [];

for (var k = 0; k &lt; 3; k++) {
  data[k] = (function (x) {
    return function () {
      alert(x);
    };
  })(k); // pass &quot;k&quot; value
}

// now it is correct
data[0](); // 0
data[1](); // 1
data[2](); // 2
</code></pre><p>对闭包理论和它们的实际应用感兴趣的同学可以在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/" target="_blank" rel="external">第六章 闭包</a>中找到额外的信息。如果想获取更多关于作用域链的信息，可以看一下同名的<a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/" target="_blank" rel="external">第四章 作用域链</a>。</p>
<p>然后我们移动到下个部分，考虑一下执行上下文的最后一个属性。这就是关于<code>this</code>值的概念。</p>
<h2 id="10-This"><a href="#10-This" class="headerlink" title="10.This"></a>10.This</h2><pre><code>this是一个与执行上下文相关的特殊对象。因此，它可以叫作上下文对象（也就是用来指明执行上下文是在哪个上下文中被触发的对象）。
</code></pre><p><em>任何对象</em>都可以做为上下文中的<code>this</code>的值。我想再一次澄清，在一些对ECMAScript执行上下文和部分<code>this</code>的描述中的所产生误解。this经常被错误的描述成是变量对象的一个属性。这类错误存在于比如像这本书中（即使如此，这本书的相关章节还是十分不错的）。再重复一次：</p>
<pre><code>this是执行上下文的一个属性，而不是变量对象的一个属性
</code></pre><p>这个特性非常重要，因为<em>与变量相反，<code>this</code>从不会参与到标识符解析过程</em>。换句话说，在代码中当访问<code>this</code>的时候，它的值是<em>直接</em>从执行上下文中获取的，并<em>不需要任何作用域链查找</em>。<code>this</code>的值只在<em>进入上下文</em>的时候进行<em>一次</em>确定。</p>
<p>顺便说一下，与ECMAScript相反，比如，Python的方法都会拥有一个被当作简单变量的<code>self</code>参数，这个变量的值在各个方法中是相同的的并且在执行过程中可以被更改成其他值。在ECMAScript中，给<code>this</code>赋一个新值<em>是不可能的</em>，因为，再重复一遍，它不是一个变量并且不存在于变量对象中。</p>
<p>在全局上下文中，<code>this</code>就等于<em>全局对象本身</em>（这意味着，这里的this等于<em>变量对象</em>）：</p>
<pre><code>var x = 10;

console.log(
  x, // 10
  this.x, // 10
  window.x // 10
);
</code></pre><p>在函数上下文的情况下，对<em>函数的每次调用</em>，其中的<code>this</code>值可能是<em>不同的</em>。这个<code>this</code>值是通过<em>函数调用表达式</em>（也就是函数被调用的方式）的形式由<em>caller</em>所提供的。举个例子，下面的函数<code>foo</code>是一个<em>callee</em>，在全局上下文中被调用，此上下文为caller。让我们通过例子看一下，对于一个代码相同的函数，<code>this</code>值是如何在不同的调用中（函数触发的不同方式），由caller给出<em>不同的</em>结果的：</p>
<pre><code>// the code of the &quot;foo&quot; function
// never changes, but the &quot;this&quot; value
// differs in every activation

function foo() {
  alert(this);
}

// caller activates &quot;foo&quot; (callee) and
// provides &quot;this&quot; for the callee

foo(); // global object
foo.prototype.constructor(); // foo.prototype

var bar = {
  baz: foo
};

bar.baz(); // bar

(bar.baz)(); // also bar
(bar.baz = bar.baz)(); // but here is global object
(bar.baz, bar.baz)(); // also global object
(false || bar.baz)(); // also global object

var otherFoo = bar.baz;
otherFoo(); // again global object
</code></pre><p>为了深入理解<code>this</code>为什么（并且更本质一些－<em>如何</em>）在每个函数调用中可能会发生变化，你可以阅读<a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/" target="_blank" rel="external">第三章 This</a>。在那里，上面所提到的情况都会有详细的讨论。</p>
<p>总结</p>
<p>通过本文我们完成了对概要的综述。尽管，它看起来并不像是「概要」;)。对所有这些主题进行完全的解释需要一本完整的书。我们只是没有涉及到两个大的主题：<em>函数</em>（和不同函数之间的区别，比如，<em>函数声明</em>和<em>函数表达式</em>）和ECMAScript中所使用的<em>求值策略</em>(evaluation strategy )。这两个主题是可以ES3系列的在对应章节找到：<a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/" target="_blank" rel="external">第五章 函数</a>和<a href="http://dmitrysoshnikov.com/ecmascript/chapter-8-evaluation-strategy/" target="_blank" rel="external">第八章 求值策略</a>。</p>
<p>如果你有留言，问题或者补充，我将会很乐意地在评论中讨论它们。</p>
<p>祝学习ECMAScript好运！</p>
<p>作者：Dmitry A. Soshnikov<br>发布于：2010-09-02</p>
<p>(完)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/12/15/DiveIntoJs_module_pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/15/DiveIntoJs_module_pattern/" itemprop="url">深入理解Javascript：模块模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-15T00:00:00+08:00">
                2015-12-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文转载自前端乱炖：<a href="http://www.html-js.com/article/Study-JavaScript-Javascript-module-every-day" target="_blank" rel="external">Javascript 模块模式</a></p>
<h2 id="1-Javascript-模块模式"><a href="#1-Javascript-模块模式" class="headerlink" title="1.Javascript 模块模式"></a>1.Javascript 模块模式</h2><p>假设现在我们有一个小型的Js库，目的是用来增加一个数字：</p>
<pre><code>var jspy = {
  count: 0,

  incrementCount: function() {
    this.count++;
  },

  decrementCount: function() {
    this.count--;
  },

  getCount: function() {
    return this.count;
  }

};
</code></pre><p>但是，使用这个js库的人可以用jspy.count = 5 的方法来改变这个值。并不是我们的最初目的。在其他的编程语言中你可以定义一个私有变量，但是Javascript并不能“真正”定义私有变量。然而，我们可以通过操作Javascript来实现，这就引出了一个最流行的Javascript设计模式，模块模式。</p>
<p>针对上面问题的解决方案如下：</p>
<pre><code>var jspy = (function() {
  var _count = 0;

  var incrementCount = function() {
    _count++;
  }

  var getCount = function() {
    return _count;
  }
  return {
    incrementCount: incrementCount,
    getCount: getCount
  };

})();
</code></pre><p>首先我们创造一个_count变量，下划线表明它是一个私有变量。再Javascript中下划线并没有什么实际的意义，但是它是一个用来标明私有变量的普遍用法。现在函数就可以操纵、返回变量了：</p>
<p>然而，你注意到了我吧整个库包含在了一个自调用匿名函数中。这是一个在执行过程中马上被执行的函数。这个函数运行，定义了函数和变量然后到了return {}的部分，它告诉函数将其返回给变量jspy，或者换句话说，暴露给用户。我们暴露两个函数而不是_count变量，这意味着我们可以做如下操作：</p>
<pre><code>jspy.incrementCount();
jspy.getCount();
</code></pre><p>但是当我们试图进行如下操作时：</p>
<pre><code>jspy._count; //undefined
</code></pre><p>它返回undefined。</p>
<p>对于上面的这种设计模式有许多不同的实现方法。有人喜欢在return 中定义函数：</p>
<pre><code>var jspy = (function() {
    var _count = 0;

    return {
      incrementCount: function() {
        _count++;
      },
      getCount: function() {
        return _count;
      }
    };
})();   
</code></pre><p>受到上面例子的启发，CHristian Heilmann提出了Revealing Module Pattern。他的方法是将所有方法定义为私有变量，也就是说，不在return中定义，但是在那里暴露给用户，如下所示：</p>
<pre><code>var jspy = (function() {
  var _count = 0;
  var incrementCount = function() {
    _count++;
  };
  var resetCount = function() {
    _count = 0;
  };
  var getCount = function() {
    return _count;
  };
  return {
    add: incrementCount,
    reset: resetCount,
    get: getCount
  };
})();
</code></pre><p>这种设计模式有两个好处：</p>
<ul>
<li><p>首先，它使我们更容易的了解暴露的函数。当你不在return中定义函数时，我们能轻松的了解到每一行就是一个暴露的函数，这时我们阅读代码更加轻松。</p>
</li>
<li><p>其次，你可以用简短的名字（例如 add）来暴露函数，但在定义的时候仍然可以使用冗余的定义方法（例如 incrementCount）。   </p>
</li>
</ul>
<p>相关阅读：<a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="external">阮一峰：Javascript模块化编程（一）：模块的写法</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/11/19/DiveIntoJs_hoisted/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/19/DiveIntoJs_hoisted/" itemprop="url">深入理解Javascript： 声明提升</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-19T00:00:00+08:00">
                2015-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在JS程序中，我们都会需要声明变量和函数，变量声明和函数声明有些什么要注意的呢？</p>
<p>今天就让我们一探究竟。</p>
<p>先看一个例子：</p>
<pre><code>var scope = &apos;global&apos;;
function checkscope(){
    return scope;
    var scope = &apos;local&apos;;
}
var result = checkscope();
console.log(result);
</code></pre><p>上面例子最后打印出来的result是什么呢，可能有人会说是global，有人会说是local，实际结果却是undifined；</p>
<p>最开始我真是被打击到了，打击过后还是要搞明白啊。</p>
<h2 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1.作用域"></a>1.作用域</h2><p>还是先看一个上面例子的变种：</p>
<pre><code>var scope = &apos;global&apos;;
function checkscope(){
    var scope = &apos;local&apos;;
    return scope;
}
var result = checkscope();
console.log(result);
</code></pre><p>这个可能大家都能说出来是local，是的没错，跟大多数编程语言一样，JS也分全局作用域和函数作用域。</p>
<p>我们先来了解作用域这个概念，在JS中一个变量的作用域是程序源代码中定义这个变量的区域。</p>
<p>全局变量用于全局作用域，在JS代码中的任何地方都是有定义的。然而在函数内的变量只在函数体内有定义。他们是局部变量，作用域是局部的。函数参数也是局部变量，它们只在函数体内有定义。</p>
<p>并且，在函数体内，局部变量的优先级高于同名的全局变量。如果在函数体内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量覆盖。</p>
<p>上面例子的结果就呼之欲出了。</p>
<p>还有一个坑，当我们声明变量时，如果没有加var语句，那么这个变量将会提升为全局变量，如：</p>
<pre><code>var scope = &apos;global&apos;;
function checkscope(){
    scope = &apos;local&apos;;
    return scope;
}
var result = checkscope();
console.log(result); // local
</code></pre><p>结果变成了local，所以平时声明变量都要加var，不然会造成很多bug，或者原本意义的偏离。</p>
<h2 id="2-变量声明提升"><a href="#2-变量声明提升" class="headerlink" title="2.变量声明提升"></a>2.变量声明提升</h2><p>再来看文章开始的例子，为什么会有undefined的结果呢；</p>
<p>原来JS没有块级作用域，JS有函数作用域，变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的，即函数体内的声明的所有变量在函数体内始终是可见的。</p>
<p>有意思的是，这意味着在声明之前甚至可用；JS这个特性被称为变量声明提前，即JS函数内声明的所有变量（不涉及赋值）都被提前至函数体的顶部；这步操作是JS引擎在预编译进行的，是在代码运行之前。</p>
<p>这个例子等价于下面的代码：</p>
<pre><code>var scope = &apos;global&apos;;
function checkscope(){
    var scope;
    return scope;
    scope = &apos;local&apos;;
}
var result = checkscope();
console.log(result);
</code></pre><p>再来看这个例子，我们就知道由于函数作用域的特性，局部变量在整个函数体始终是有定义的，也就是说，在函数体内局部变量遮盖了同名全局变量。尽管如此，只有在程序执行到var scope = ‘local’时，局部变量才被真正赋值。</p>
<p>所以由于JS没有块级作用域，我们编写程序可以将变量声明放在函数体顶部，这样做法是一个很好的反应真实的变量作用域，减少bug。</p>
<h2 id="3-函数声明提升"><a href="#3-函数声明提升" class="headerlink" title="3.函数声明提升"></a>3.函数声明提升</h2><p>老规矩，再来看一个例子：</p>
<pre><code>var foo = 1;
function bar() {
    return foo;
    foo = 2;
    function foo() {return 3;}
    var foo = 4;
}
console.log(bar());
</code></pre><p>大家会不会说是undefined呢？不是的，这个结果是<code>[function: foo]</code>,为什么会出现这种情况呢？</p>
<p>原来函数声明与通过var声明变量一样，<strong>函数声明语句</strong>中的函数被显式地提前到脚本或函数的顶部，因此它们在整个脚本和函数内部都是可见的。</p>
<p>与变量声明提前不同的是：使用var的话，只有变量声明提前，变量的初始化代码仍然在原来的位置。然而用函数声明语句的话，函数名称和函数体均提前,脚本中的所有函数和函数中所嵌套的函数都会在当前上下文中其它代码之前声明。</p>
<p>为什么要指定是函数声明之前呢，因为使用函数定义表达式创建的函数是不会提前的，见下面的例子：</p>
<pre><code>var foo = 1;
function bar() {
    return foo;
    foo = 2;
    var foo = function foo() {return 3;}
    var foo = 4;
}
console.log(bar()); // undefined
</code></pre><p>关于函数定义表达式和函数生命表达式的详细内容，以后在深入理解函数中再讲。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/10/19/DiveIntoJs_compare/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/19/DiveIntoJs_compare/" itemprop="url">深入理解Javascript： 比较</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-19T00:00:00+08:00">
                2015-10-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>开始这个之前我们先看几个例子</p>
<pre><code>var a = [1, 2]
var b = [1, 2]
a == [1, 2] // false
a == b // false

var c = {a: 1, b: 2}
var d = {a: 1, b: 2}
c == d // false

var str = &apos;test&apos;
str == &apos;test&apos; // true

str.toUpperCase() // &apos;TEST&apos;
str // &apos;test&apos;
</code></pre><p>为什么有这种现象发生呢？</p>
<h2 id="1-JS的原始值与对象"><a href="#1-JS的原始值与对象" class="headerlink" title="1.JS的原始值与对象"></a>1.JS的原始值与对象</h2><p>原来JS分为两种对象，一个是原始类型，有undefined、null、布尔值、数字和字符串；一个是对象类型（数组、函数等）；</p>
<p>原始类型值是不可更改的，任何方法都无法更改一个原始值，如上面例子中str经过转换大写之后还是‘test’；原始类型值的比较是值的比较；</p>
<p>对象类型值的比较并非值的比较，即使两个对象包含同样的属性及相同的值，如上例子的a与b、c与d的比较都为false；</p>
<p>对象的比较为引用的比较，当且仅当它们引用同一个基对象时，它们才相等，如下：</p>
<pre><code>var a = [1, 2]
var b = a
a == b // true
</code></pre><h2 id="2-与"><a href="#2-与" class="headerlink" title="2.== 与 ==="></a>2.<code>==</code> 与 <code>===</code></h2><p>再来看一个例子：</p>
<pre><code>1 == &apos;1&apos; // true
1 === &apos;1&apos; // false
var undefined;
undefined == null; // true
1 == true;   // true
2 == true;   // false
0 == false;  // true
0 == &apos;&apos;;     // true
NaN == NaN;  // false
[] == false; // true
[] == ![];   // true
</code></pre><p>为啥会有前面两行的结果呢？</p>
<p>原来‘==’运算符用来检测两个操作数是否相等，这里相等的定义非常宽松，可以允许进行类型转换；</p>
<p>而‘===’运算符用来检测两个操作数是否<strong>严格</strong>相等，会比较两个操作数的类型是否相同；</p>
<h3 id="运算规则"><a href="#运算规则" class="headerlink" title="===运算规则"></a><code>===</code>运算规则</h3><p>‘===’运算符首先计算其操作数的值，然后比较这两个值，比较过程没有任何类型转换；</p>
<ul>
<li><p>如果两个值类型不同，返回false；</p>
</li>
<li><p>如果两个值都为null或者undefined，返回true；</p>
</li>
<li><p>如果两个值都为布尔值true或者false，返回true；</p>
</li>
<li><p>如果其中一个为NaN,则返回false，即使另一个也为NaN；</p>
</li>
<li><p>如果两个值为数字且数值相等，则返回true，0与-0也返回true；</p>
</li>
<li><p>如果两个字符串的长度或者内容不同，则返回false；</p>
</li>
<li><p>如果两个引用值指向同一个对象，则返回true，其他对象比较都返回false；</p>
</li>
</ul>
<h3 id="运算规则-1"><a href="#运算规则-1" class="headerlink" title="==运算规则"></a><code>==</code>运算规则</h3><p>‘==’运算符跟‘===’类似，不过比较并不严格。如果两个操作数类型相同，则和上文所述的严格相等的比较规则一样；</p>
<p>如果两个操作数不是同一类型，那么相等运算符会尝试进行一些类型转换，然后进行比较：</p>
<ul>
<li><p>如果一个值为null，另一个为undefined，则它们相等；</p>
</li>
<li><p>如果一个值是数字，另一个是字符串，先将字符串转换为数字，然后使用转换后的值进行比较；</p>
</li>
<li><p>如果其中一个是true，则将其转换为1再进行比较；如果是false，则转换为0再进行比较；</p>
</li>
<li><p>如果一个值为对象，另一个值是数字或字符串，则使用下一小节要讲的类型转换规则转换为原始值，然后再进行比较；对象通过toString()方法或valueOf方法转换为原始值；JS语言核心的内置类首先尝试使用valueOf()，再尝试toString()，除了日期类，日期类只使用toString()转换。那些不是内置对象则通过各自实现中定义的方法转换为原始值；</p>
</li>
<li><p>其他不同类型之间的比较均不相等；</p>
</li>
</ul>
<p>如<code>&#39;1&#39; == true</code>返回true，其中true转换为1，‘1’转换为1，因为两个数字的值相等，所以返回true。</p>
<h2 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="3.类型转换"></a>3.类型转换</h2><p>类型转换有隐式和显式转换，下图为转换的规则：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/类型转换.jpg" alt="http://7xj29n.com1.z0.glb.clouddn.com/类型转换.jpg"></p>
<h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><p>做显示转换最简单的方法就是使用Boolean()、Number()、String()或Object()函数；</p>
<p>注意这些函数与它们作为函数构造器是有区别的，作为函数构造器是使用new Number()，这种得出来的是属于包装对象；</p>
<p>如下：</p>
<pre><code>Number(&quot;3&quot;)
new Number(&quot;3&quot;)
typeof Number(&quot;3&quot;) // number
typeof new Number(&quot;3&quot;) // object
</code></pre><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>隐式转换是通过上下语境或者运算符来转换的；</p>
<p>例如‘+’运算符有一个操作数为字符串时，另一个操作数不为字符串时会隐式转换为字符串；’-‘运算符会隐式把两个操作数转换为数字;</p>
<p>再如一元运算符‘！’会把操作数转换为布尔值并取反；如：</p>
<pre><code>12 + &apos;1&apos; // &apos;121&apos;
new Number(&quot;3&quot;) - [1] // 2
!![] // true
</code></pre><p>对应的转换规则如上面图中所示，下面只来说说对象转换为原始值的方式（<em>这里只谈原生对象，而非宿主对象的转换，宿主对象根据各自的算法进行转换</em>）；</p>
<p>1.对象转换为字符串</p>
<ul>
<li>如果对象具有toString()方法，且调用这个方法返回一个原始值，则对象先转换为原始值，然后再通过上图的转换规则转换为字符串；</li>
<li>否则JS会调用valueOf()方法，且调用这个方法返回一个原始值，则对象先转换为原始值，然后再通过上图的转换规则转换为字符串；</li>
<li>如果对象无法从上面两个方法获得一个原始值，这时它将抛出一个类型错误异常；</li>
</ul>
<p>例如计算<code>[1, 2, 3] + &#39;abc&#39;</code>返回<code>&#39;1,2,3abc&#39;</code></p>
<p>首先<code>[1, 2, 3]</code>调用<code>toString()</code>方法返回<code>‘1,2,3’</code>然后再执行字符串的+运算，返回<code>&#39;1,2,3abc&#39;</code></p>
<p>2.对象转换为数字</p>
<p>这个与上面转换为字符串相反，先调用valueOf()，失败再尝试toString()；</p>
<ul>
<li>否则JS会调用valueOf()方法，且调用这个方法返回一个原始值，则对象先转换为原始值，然后再通过上图的转换规则转换为字符串；</li>
<li>如果对象具有toString()方法，且调用这个方法返回一个原始值，则对象先转换为原始值，然后再通过上图的转换规则转换为字符串；</li>
<li>如果对象无法从上面两个方法获得一个原始值，这时它将抛出一个类型错误异常；</li>
</ul>
<p>例如计算<code>[1, 2, 3] - 1</code>返回<code>NaN</code></p>
<p>首先<code>[1, 2, 3]</code>调用<code>valueOf()</code>方法，而此方法返回一个对象而不是原始值，则调用<code>toString()</code>方法，返回<code>‘1,2,3’</code>然后再转换为数字，根据字符串转换为数字的规则，为<code>NaN</code>,<code>NaN - 1</code>返回<code>NaN</code>。</p>
<p>注意：日期对象有点特别，通过valueOf和toString方法返回的原始值将被直接使用；</p>
<h2 id="4-后记"><a href="#4-后记" class="headerlink" title="4.后记"></a>4.后记</h2><p>通过上面的一些例子我们知道JS原始类型与对象类型的一些转换规则以及JS的内部实现，有机会再聊聊JS的常见运算符。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/10/19/DiveIntoJs_Events_propagation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/19/DiveIntoJs_Events_propagation/" itemprop="url">深入理解Javascript：DOM事件之事件传播</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-19T00:00:00+08:00">
                2015-10-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>客户端Javascript程序采用异步事件驱动编程模型。</p>
<p>那首先什么是异步事件驱动编程模型呢？</p>
<p>在这种设计风格下，当文档、浏览器、元素或与之相关的对象发生某些有趣的事情时，Web浏览器就会产生事件。</p>
<p>这些对象等待事件发生，然后他们相应，这就是所谓的异步驱动风格。</p>
<h2 id="1-事件是什么呢？"><a href="#1-事件是什么呢？" class="headerlink" title="1.事件是什么呢？"></a>1.事件是什么呢？</h2><p>事件就是Web浏览器通知应用程序发生了什么事情。</p>
<p>事件类型：是一个用来说明发生什么类型事件的字符串；例如‘mousemove’表示用户移动鼠标，由于事件类型只是一个字符串，有时也可称为事件名字。</p>
<p>事件目标：发生的事件或者与之相关的对象。在JS应用程序中，Windows、Document、Element对象是最常见的事件目标。</p>
<p>下面的代码就是弹出事件目标与类型的方法：</p>
<pre><code>&lt;div id=&apos;box&apos;&gt;
    &lt;button&gt;按钮&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    var bt = document.getElementsByTagName(&apos;button&apos;)[0];

    bt.addEventListener(&apos;click&apos;,function(event){
        alert(&apos;事件目标:&apos; + event.target);
        alert(&apos;事件类型：&apos; + event.type);
    })
&lt;/script&gt;
</code></pre><p>事件处理程序：处理或相应事件的函数。当在特定的事件目标上发生特定类型的事件时，浏览器会调用对应的事件处理程序。</p>
<p>事件对象：与特定事件相关且包含有关该事件详细信息的对象；例如，鼠标事件的相关对象会包含鼠标指针的坐标。</p>
<p>事件传播：浏览器决定哪个对象触发其事件处理程序的过程：</p>
<ul>
<li>对于单个对象的特定事件（比如windows的load事件），必须是不能传播的；</li>
<li>事件传播向上传播，即冒泡传播；</li>
<li>事件处理程序能够通过调用方法或者设置事件对象属性来阻止事件传播，这样就能停止冒泡；</li>
</ul>
<p>事件捕获：事件传播的另外一种形式，在容器元素上注册的特定处理程序有机会在事件传播到真实目标之前捕获它。IE8或之前的版本不支持事件捕获，所以不常用它。</p>
<h2 id="2-事件传播"><a href="#2-事件传播" class="headerlink" title="2.事件传播"></a>2.事件传播</h2><p>上面介绍了什么是事件，下面详细介绍事件的传播机制；</p>
<p>当事件目标是Windows对象或其他的一些单独对象（如XMLHTTPRequest）时，浏览器简单的通过调用对象上适当的处理程序相应事件。</p>
<p>当事件目标是文档或者文档元素时，情况不同：</p>
<p>事件传播有三个阶段：</p>
<p>捕获阶段，发生在目标处理程序调用之前，称为‘捕获’阶段，为<strong>第一阶段</strong>；</p>
<p>目标对象本身的时间处理程序调用是<strong>第二个阶段</strong>；</p>
<p>事件冒泡是事件传播的<strong>第三个阶段</strong>；</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/事件传播.jpg" alt="http://7xj29n.com1.z0.glb.clouddn.com/事件传播.jpg"></p>
<h2 id="3-事件冒泡"><a href="#3-事件冒泡" class="headerlink" title="3.事件冒泡"></a>3.事件冒泡</h2><p>事件最开始由具体的元素（即事件发生的对象）接受，然后逐级向上传播至最不具体的那个节点。</p>
<p>下面是html：</p>
<pre><code>&lt;body&gt;
    &lt;div id=&apos;box&apos;&gt;
        &lt;button&gt;按钮&lt;/button&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre><p>比如当点击上面HTML中的按钮，事件会一直向上冒泡，寻找注册了clink的事件处理程序的元素：</p>
<pre><code>button --&gt;　box --&gt;　body --&gt; html --&gt; document root
</code></pre><h2 id="4-事件捕获"><a href="#4-事件捕获" class="headerlink" title="4.事件捕获"></a>4.事件捕获</h2><p>事件捕获像反向的冒泡阶段；最先调用windows对象的捕获处理程序，然后是Document对象的捕获处理程序，接着是body对象的，再然后是DOM树向下，依次类推，直到调用事件目标的父元素的捕获事件处理程序。</p>
<p>事件捕获只能用于addEventListener()注册且第三个参数是true的事件处理程序中。意味着事件捕获无法在IE9之前的IE中使用。因为IE9之前的IE中不支持addEventListener。</p>
<pre><code>&lt;body&gt;
    &lt;div id=&apos;box&apos;&gt;
        &lt;button&gt;按钮&lt;/button&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre><p>当点击上面html的按钮时，事件捕获阶段会从上到下寻找注册了click事件捕获处理程序的元素：</p>
<pre><code>document root --&gt; html --&gt; body --&gt; box --&gt; button
</code></pre><h2 id="5-事件的取消"><a href="#5-事件的取消" class="headerlink" title="5.事件的取消"></a>5.事件的取消</h2><p>取消事件的浏览器默认操作有三种方式：</p>
<ul>
<li>设置事件处理程序的返回值为false；</li>
<li>在支持addEventListener的浏览器中，也能通过调用事件对象的preventDefault()方法取消事件的默认行为</li>
<li>在IE9之前的IE中，可以设置事件对象的returnValue属性为false</li>
</ul>
<p>取消事件的传播可以通过：</p>
<ul>
<li>在支持addEventListener的浏览器中，也能通过调用事件对象的一个stopPropagation()方法取消事件的继续传播；如果在同一对象上定义了其他处理程序，剩下的处理程序将依旧被调用，但调用stopPropagation方法之后其他任何对象的事件处理程序将不会调用</li>
<li>IE9之前不支持上一种方法的可以通过IE事件对象的cancelBubble属性设置为true能阻止事件进一步冒泡（这些版本事件传播不支持事件的捕获阶段）</li>
</ul>
<h2 id="6-综合例子"><a href="#6-综合例子" class="headerlink" title="6.综合例子"></a>6.综合例子</h2><p>下面是一个综合例子：</p>
<p>当点击按钮时，会依次弹出对话框：‘事件捕获阶段body’、‘事件捕获阶段box’、‘事件捕获阶段：button’、‘事件调用阶段：button’、‘事件冒泡阶段：box’、‘事件冒泡阶段：body’；</p>
<p>当点击box时，会依次弹出对话框：‘事件捕获阶段body’、‘事件捕获阶段box’、‘事件冒泡阶段：box’、‘事件冒泡阶段：body’；</p>
<pre><code>&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;事件流&lt;/title&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;style&gt;
            #box {height:100px;width: 100px;border: solid 1px red; text-align: center;background-color: burlywood}
            #button {border: solid 1px red;}
        &lt;/style&gt;
    &lt;/head&gt;

    &lt;body id=&quot;body&quot;&gt;
        &lt;div id=&quot;box&quot;&gt;box
            &lt;button id=&quot;button&quot;&gt;按钮&lt;/button&gt;
        &lt;/div&gt;
        &lt;script&gt;
            var bt = document.getElementById(&apos;button&apos;);
            var bx = document.getElementById(&apos;box&apos;);
            var bd = document.getElementById(&apos;body&apos;);

            bt.addEventListener(&apos;click&apos;, function(){
                alert(&quot;事件捕获阶段：button&quot;);
            }, true);
            bx.addEventListener(&apos;click&apos;, function(){
                alert(&quot;事件捕获阶段box&quot;);
            },true);
            bd.addEventListener(&apos;click&apos;, function(){
                alert(&quot;事件捕获阶段body&quot;);
                // event.stopPropagation();
            },true);

            bt.addEventListener(&apos;click&apos;, function(){
                alert(&quot;事件调用阶段：button&quot;);
            }, false);
            bx.addEventListener(&apos;click&apos;, function(){
                alert(&quot;事件冒泡阶段：box&quot;);
            },false);
            bd.addEventListener(&apos;click&apos;, function(){
                alert(&quot;事件冒泡阶段：body&quot;);
            },false);
        &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/09/22/css_notes_3-overflow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/22/css_notes_3-overflow/" itemprop="url">CSS：overflow</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-22T00:00:00+08:00">
                2015-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/css/" itemprop="url" rel="index">
                    <span itemprop="name">css</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-overflow基本属性"><a href="#1-overflow基本属性" class="headerlink" title="1.overflow基本属性"></a>1.overflow基本属性</h2><p>值：<code>visible、hidden、scroll、auto、inherit</code></p>
<p>初始值：<code>visible</code></p>
<p>应用于：块级元素和替换元素</p>
<p>继承值：无</p>
<p>计算值：根据指定确定</p>
<h3 id="overflow-x和overflow-y"><a href="#overflow-x和overflow-y" class="headerlink" title="overflow-x和overflow-y"></a>overflow-x和overflow-y</h3><p>当容器高宽都不足以容下图片时，<code>overflow-x:hidden</code>会把x方向的隐藏掉、y方向出现滚动条；为什么会出现这种情况呢？</p>
<p>如果<code>overflow-x</code>和<code>overflow-y</code>值相同，则等同于<code>overflow</code>；</p>
<p>如果<code>overflow-x</code>和<code>overflow-y</code>值不同，且其中一个值为<code>visible</code>，另一个值为<code>hidden、scroll、auto</code>，则<code>visible</code>会被重置为<code>auto</code>；这就是为什么上面的y方向出现滚动条；</p>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>不同浏览器滚动条的表现不一样；</p>
<p>宽度设定机制，见下面一个例子：</p>
<pre><code>&lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;content&quot;&gt;&lt;/div&gt;&lt;/div&gt;

.box { width: 400px; height: 100px; overflow: auto; }
.content { width: 100%; height: 200px; background-color: #beceeb; }
</code></pre><p>在IE7中，垂直和水平方向都出现了滚动条；这是宽度设定机制差异导致的，IE7浏览器把100%宽度算成了外部容器的400px，而垂直方向出现滚动条后，会占用宽度的，从而外部容器水平方向没有400px，从而水平方向出现了滚动条。</p>
<p>如何避免这种情况呢，直接去掉<code>width: 100%</code>就好了。</p>
<p>IE8没有这种情况；</p>
<h3 id="如何使overflow属性有效"><a href="#如何使overflow属性有效" class="headerlink" title="如何使overflow属性有效"></a>如何使overflow属性有效</h3><ul>
<li><p>非<code>display： inline</code>水平</p>
</li>
<li><p>对应方位的尺寸限制；<code>width/height/max-width/max-height/absolute</code>拉伸；</p>
</li>
<li><p>对于单元格td等，还需要table为<code>table-layout：fixed</code>状态才行；</p>
</li>
</ul>
<p>两个IE7的bug：</p>
<p>(1)IE7浏览器下，按钮里的文字越多，按钮两侧的padding留白就越大！</p>
<p>解决方案：给所有按钮添加css样式<code>overflow:visible</code></p>
<p>(2)</p>
<pre><code>.size{ max-width: 200px; max-height: 300px; overflow: auto; }
&lt;div class=&apos;size&apos;&gt;&lt;img src=&quot;mm1.jpg&quot; width=&quot;256&quot; height=&quot;191&quot;&gt;&lt;/div&gt;
</code></pre><p>按理论只有水平出现滚动条，结果垂直方向也出现了；</p>
<h2 id="2-overflow与滚动条"><a href="#2-overflow与滚动条" class="headerlink" title="2.overflow与滚动条"></a>2.overflow与滚动条</h2><h3 id="滚动条出现的条件"><a href="#滚动条出现的条件" class="headerlink" title="滚动条出现的条件"></a>滚动条出现的条件</h3><p>1.<code>overflow:auto/overflow:scroll  //&lt;html&gt;、&lt;textarea&gt;</code></p>
<p>2.当子元素的水平或者垂直方向超过容器对应方向的最大限度；</p>
<h3 id="body-html与滚动条"><a href="#body-html与滚动条" class="headerlink" title="body/html与滚动条"></a>body/html与滚动条</h3><p>无论什么浏览器，<strong>默认滚动条均来自<code>&lt;html&gt;</code></strong>而不是<code>&lt;body&gt;</code>标签；</p>
<p>原因：新建一个空白HTML页面，<code>&lt;body&gt;</code>默认<code>.5em margin</code>值，如果滚动条来自<code>&lt;body&gt;</code>，则应该滚动条与浏览器边框有边距；而事实是滚动条是紧贴着浏览器边框的；</p>
<p>IE7-浏览器默认类似： <code>html { overflow-y: scroll; }</code><br>IE8+等浏览器默认：<code>html { overflow: hidden; }</code></p>
<p>所以，如果我们想要去除页面默认滚动条，只需要：</p>
<pre><code>html { overflow: hidden; }
</code></pre><p>而没必要把<body>也拉下水：</body></p>
<pre><code>html, body { overflow: hidden; } //不需要body标签
</code></pre><h3 id="JS与滚动高度"><a href="#JS与滚动高度" class="headerlink" title="JS与滚动高度"></a>JS与滚动高度</h3><p>chrome浏览器是：<code>document.body.scrollTop</code>;</p>
<p>其他浏览器是：<code>document.documentElement.scrollTop</code>;</p>
<p>目前，两者不会同时存在，因此，有人会写成：</p>
<pre><code>var st = document.body.scrollTop +　document.documentElement.scrollTop
</code></pre><p>建议使用：</p>
<pre><code>var st = document.body.scrollTop ||　document.documentElement.scrollTop
</code></pre><h3 id="overflow的padding-bottom缺失现象"><a href="#overflow的padding-bottom缺失现象" class="headerlink" title="overflow的padding-bottom缺失现象"></a>overflow的padding-bottom缺失现象</h3><pre><code>.box { width: 400px; height: 100px; padding: 100px 0; overflow: auto; }
</code></pre><p>在chrome浏览器下面的padding-bottom可以滚动出来；而其他浏览器都不存在；</p>
<p>可能导致的： 不一样的scrollHeight(元素内容高度)</p>
<h3 id="滚动条的宽度机制"><a href="#滚动条的宽度机制" class="headerlink" title="滚动条的宽度机制"></a>滚动条的宽度机制</h3><p>滚动条会占用容器的可用宽度和高度；</p>
<p>下面这种方法可以计算滚动条的宽度：</p>
<pre><code>.box {width: 400px; overflow: scroll; }
.in {*zoom: 1; /* for IE7 */}

&lt;div class=&quot;box&quot;&gt;
    &lt;div id=&quot;in&quot; class=&quot;in&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

console.log(400 - document.getElementById(&quot;in&quot;).clientWidth);
</code></pre><p>测得的结果：IE7+/Chrome/FireFox(win7)-均是17像素；</p>
<h3 id="overflow-auto的潜在布局隐患"><a href="#overflow-auto的潜在布局隐患" class="headerlink" title="overflow:auto的潜在布局隐患"></a>overflow:auto的潜在布局隐患</h3><p>滚动条会占用容器尺寸，原本和谐的布局，滚动条出现后可能挂掉；</p>
<h3 id="水平居中跳动问题"><a href="#水平居中跳动问题" class="headerlink" title="水平居中跳动问题"></a>水平居中跳动问题</h3><pre><code>.container { width: 1150px; margin: 0 auto; }
</code></pre><p>问题的修复：</p>
<p>1.<code>html { overflow-y: scroll; }</code> // 太丑</p>
<p>2.<code>.container { padding-left: calc(100vw - 100%);}</code></p>
<h2 id="3-overflow与BFC"><a href="#3-overflow与BFC" class="headerlink" title="3.overflow与BFC"></a>3.overflow与BFC</h2><p>BFC(block formatting context) - ‘块级格式化上下面’</p>
<p>BFC有一个特点：页面之结界，内部元素再怎么翻云覆雨都不会影响外部；</p>
<h3 id="overflow与BFC"><a href="#overflow与BFC" class="headerlink" title="overflow与BFC"></a>overflow与BFC</h3><p>overflow有三种属性会触发BFC：<code>auto、scroll、hidden</code></p>
<p>有三种常用用途：</p>
<p>清楚浮动影响、避免margin穿透问题、两栏自适应布局</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/08/21/css_notes_2-float/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/21/css_notes_2-float/" itemprop="url">CSS：浮动</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-21T00:00:00+08:00">
                2015-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/css/" itemprop="url" rel="index">
                    <span itemprop="name">css</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>什么是浮动，浮动有什么作用？</p>
<h2 id="1-浮动的前世今生"><a href="#1-浮动的前世今生" class="headerlink" title="1.浮动的前世今生"></a>1.浮动的前世今生</h2><p>从Netscape1以来，就可以通过声明让图像浮动，如：</p>
<pre><code>&lt;img src=&quot;b5.gif&quot; align=&quot;right&quot;&gt;
</code></pre><p>这会导致一个图像浮动到右边，而允许其他内容如文本“围绕”该图像。</p>
<p>可见浮动的初衷是为了实现文字环绕效果；</p>
<p>过去只可能浮动图像。但CSS允许浮动任何元素，从图像到段落再到列表，所有元素都可以浮动。在CSS中，这种行为是用属性float实现。</p>
<h2 id="2-float取值"><a href="#2-float取值" class="headerlink" title="2.float取值"></a>2.float取值</h2><p>值：left、right、none、inherit</p>
<p>初始值：none</p>
<p>应用于：所有元素</p>
<p>继承值：无</p>
<p>计算值：根据指定确定</p>
<h2 id="3-浮动的特性：包裹与破坏"><a href="#3-浮动的特性：包裹与破坏" class="headerlink" title="3.浮动的特性：包裹与破坏"></a>3.浮动的特性：包裹与破坏</h2><p>什么是包裹（对本身而言）：包裹是收缩、坚挺（有高度了）、隔绝（内部内容与外界不相关）</p>
<p>具有包裹的其他小伙伴：</p>
<ul>
<li><p>display: inline-block/table-cell/…</p>
</li>
<li><p>position: absolute/fixed/sticky</p>
</li>
<li><p>overflow: hidden/scroll</p>
</li>
</ul>
<p>什么是破坏（对父元素而言）：容器被破坏，父元素的高度塌陷</p>
<p>具有破坏的其他小伙伴：</p>
<ul>
<li><p>display: none</p>
</li>
<li><p>position: absolute/fixed/sticky</p>
</li>
</ul>
<p>对于浮动元素有几点要记住。</p>
<p>首先，会以某种方式将浮动元素从文档的正常流中删除，不过它还是会影响布局。</p>
<p>采用CSS的特有方式，浮动元素几乎自成一派，不过它们还是对文档的其他元素有影响。</p>
<h2 id="4-清除浮动"><a href="#4-清除浮动" class="headerlink" title="4.清除浮动"></a>4.清除浮动</h2><p>由于浮动具有破坏性，那我们怎么清楚浮动带来的影响；有以下三种方式：</p>
<p>(1)浮动元素脚底插入clear：both</p>
<p><strong>注意：脚底插入的标签是要为block元素；</strong></p>
<p>直接把<code>&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;</code>放到当作最后一个子标签放到父标签那儿，此方法兼容性强，使用方便，但是浪费了一个标签，而且只能使用一次，而且有时候如果不注意中间多了个空格会产生一段空白高度。</p>
<p>优点：通俗易懂，容易掌握；</p>
<p>缺点：可以想象通过此方法，会添加多少无意义的空标签，有违结构与表现的分离，在后期维护中将是噩梦；<strong>只是解决了浮动，但新添加的标签会与父元素外面的元素发生margin重叠；</strong></p>
<p>(2)使用after伪对象清除浮动（与第一种方法原理相同）</p>
<p>该方法只适用于非IE浏览器，因为IE6/IE7不认识伪元素,具体写法可参照下面例;</p>
<pre><code>.fix{zoom:1;}
.fix:after{
    display:block;
    content:&apos;.&apos;;
    clear:both;
    line-height:0;
    visibility:hidden;
}
</code></pre><p>对于伪元素可以使用下面的方案，不用写太多东西：</p>
<pre><code>.clearfix:after { content: &apos;&apos;; **display: table**; clear: both; }
.clearfix { *zoom: 1; }
</code></pre><p>使用中需注意以下几点：</p>
<p>a.该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；</p>
<p>b.content属性是必须的，但其值可以为空，蓝色理想讨论该方法的时候content属性的值 设为”.”，但我发现为空亦是可以的。</p>
<p>c.line-height:0写成height:0也是可以的。不会影响任何其他样式，通用性强，覆盖面广;</p>
<p>(3)BFC/haslayout解决</p>
<p>例如给包含浮动元素的<strong>父标签</strong>添加css属性<code>.clearfix{overflow:hidden; zoom:1;}</code></p>
<p>其中<code>zoom:1</code>用于让IE6/IE7haslayout又不影响形体的神器。</p>
<p>此方法优点在于代码简洁，涵盖所有浏览器，可是对于overflow:hidden;要是里面的元素要是想来个margin负值定位或是负的绝对定位，岂不是直接被裁掉了，所以此方法是有不小的局限性的。</p>
<p>优点：不存在结构和语义化问题，代码量极少；<strong>父元素把子元素都包裹起来了，子元素不会与外层的元素发生margin重叠；</strong></p>
<p>缺点：内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。</p>
<p>BFC/haslayout通常有以下声明：</p>
<ul>
<li>float:left/right</li>
<li>position:absolute/fixed</li>
<li>overflow:hidden/scroll(IE7+)</li>
<li>display:inline-block/table-cell(IE8+)</li>
<li>width/height/zoom:1/…(IE6/IE7)</li>
</ul>
<p>(4)总结：</p>
<p>此三种方法各有利弊，使用时应择优选择，比较之下第二种方法更为可取；</p>
<p>可以使用兼容性的解决方案：</p>
<pre><code>.clearfix:after { // 解决IE8+
content: &apos;&apos;; 
display: block; 
height: 0; 
overflow: hidden; 
clear: both
}
.clearfix {*zoom: 1;} // 解决IE6/IE7
</code></pre><h2 id="5-浮动的滥用"><a href="#5-浮动的滥用" class="headerlink" title="5.浮动的滥用"></a>5.浮动的滥用</h2><p>浮动的两大特性：元素block块状化（砌砖头）、破坏造成的紧密排列特性（去空格化）</p>
<p>block化即当元素增加浮动属性，其display属性转化为block;</p>
<p>去空格化是指当元素增加浮动属性，后面的空格&amp;nbsp或者换行符\n都被移到后面了，实现了文字环绕效果；而换行符在标签的末尾没有任何表现，&amp;nbsp可以选中；</p>
<p>砌砖布局的问题：</p>
<pre><code>妙脆角-嘎吱脆； // 容错性比较糟糕，容易出问题

吝啬鬼-重用废； // 尺寸限定，模块到另外一个尺寸容器中，不配对，要重新整，完全没有重用性；

洋葱头-IE7飙泪； // 在低版本的IE有很多问题
</code></pre><h2 id="6-float与流体布局"><a href="#6-float与流体布局" class="headerlink" title="6.float与流体布局"></a>6.float与流体布局</h2><p>单侧固定（有两种方式）：</p>
<pre><code>width+float // 这一种是设置紧跟元素的width并设置为右浮动
padding-left/margin-left // 这一种是不设置width，只设置margin-left\
或者padding-left，让其自然适应
</code></pre><p>DOM与显示位置匹配的单侧固定布局：</p>
<pre><code>width:100% + float // 外层
    padding-left/margin-left //设置margin-right，以防父元素的后面元素margin-left进父元素后，内容被父元素内容覆盖
width + float + margin负值 // 设置width和margin-left负值，使其进入上面元素内
</code></pre><p>高级进化 – 智能自适应尺寸（推荐）：</p>
<pre><code>float
display: table-cell; width: 2000px;          IE8+
*display: inline-block; *width: auto;       IE7-
</code></pre><h2 id="7-浮动与兼容型"><a href="#7-浮动与兼容型" class="headerlink" title="7.浮动与兼容型"></a>7.浮动与兼容型</h2><p>IE7的浮动问题：</p>
<ul>
<li><p>含clear的浮动元素包裹不正确的问题</p>
</li>
<li><p>浮动元素倒数两个莫名垂直间距问题</p>
</li>
<li><p>浮动元素最后一个字符重复问题</p>
</li>
<li><p>浮动元素楼梯排列问题</p>
</li>
<li><p>浮动元素和文本不在同一行的问题</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/08/13/css_notes_1-layout/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/13/css_notes_1-layout/" itemprop="url">CSS：网页布局</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-13T00:00:00+08:00">
                2015-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/css/" itemprop="url" rel="index">
                    <span itemprop="name">css</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>三大布局：标准文档流、浮动布局、定位布局</p>
<h3 id="标准文档流（flow）"><a href="#标准文档流（flow）" class="headerlink" title="标准文档流（flow）"></a>标准文档流（flow）</h3><ul>
<li><p>块级元素（block）：从左到右撑满页面，独占行，从上到下</p>
</li>
<li><p>内联元素、或行级元素（inline）：行内显示，从左到右</p>
</li>
<li><p>块级内联元素（inline-block）：行内，但可以像块级元素一样编辑高度、宽度、行高以及顶和底边距</p>
</li>
</ul>
<p><em>注：块级元素和行级元素都是盒子模型</em></p>
<h3 id="浮动布局（float）"><a href="#浮动布局（float）" class="headerlink" title="浮动布局（float）"></a>浮动布局（float）</h3><ul>
<li><p>设置了浮动的元素，仍旧处于标准文档流中</p>
</li>
<li><p>左浮动、右浮动，对紧邻后面的元素有影响</p>
</li>
<li><p>清除浮动：</p>
<ol>
<li>clear：both(left、right）  </li>
<li>同时设置：width:100%（或固定宽度）+ overflow：hidden</li>
</ol>
</li>
</ul>
<h3 id="定位布局（position）"><a href="#定位布局（position）" class="headerlink" title="定位布局（position）"></a>定位布局（position）</h3><p>三种定位方式：静态定位、相对定位、绝对定位</p>
<p>四个属性值：static、relative、absolute、fixed</p>
<ul>
<li><p>相对定位(relative)</p>
<p>  相对于自身位置进行偏移(<strong>原先位置仍然存在，对兄弟模块有影响，占了位置</strong>)、<strong>仍处于标准文档流中</strong>、随即拥有偏移属性和<strong>Z-index属性</strong></p>
</li>
<li><p>绝对定位（absolute）</p>
<p>  （1）建立了以包含块为基准的定位、<strong>完全脱离了标准文档流（对兄弟模块无影响）</strong>、随即拥有偏移属性和<strong>Z-index属性</strong></p>
<p>  （2）未设置偏移量：无论是否存在已定位祖先元素，都保持在元素初始位置。</p>
<p>  （3）设置了偏移量：a.无已定位祖先元素，以<html>为偏移参考基准；b.有已定位祖先元素，以距其最近的已定位祖先元素为偏移参考基准。</html></p>
</li>
<li><p>绝对定位（fixed） </p>
<p>  (1) 与absolute定位类型类似，完全脱离了标准文档流（对兄弟模块无影响），但它的<strong>相对移动的坐标是视图（屏幕内的网页窗口）本身</strong></p>
<p>  (2) 未设置偏移量时，有已定位祖先元素，以祖先元素为基准定位；无已定位元素，以浏览器窗口为基准定位；</p>
<p>  (3)    设置偏移量时，有、无已定位祖先元素，都以浏览器可视窗口为基准偏移；</p>
<p>  <strong>注意：上面设置偏移量的时候，可以根据需求设置，只设置top，只有top方向才会跟已定位的祖先元素偏移，left是不会相对已定位的祖先偏移的</strong></p>
<p>  不过遇到一个问题一直想不明白，两个盒子box1、box2，box1在box2之前，并列关系，box1设置fixed之后，box2设置margin-top为50px，结果box1也跟着下来50px了？？？？</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/abu.jpg"
                alt="cauil" />
            
              <p class="site-author-name" itemprop="name">cauil</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/cauil" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/cauil" target="_blank" title="Weibo">
                    
                      <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://douban.com/people/cauil" target="_blank" title="DouBan">
                    
                      <i class="fa fa-fw fa-douban"></i>DouBan</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cauil</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
