<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Cauil&#39;s Blog">
<meta property="og:url" content="http://cauil.github.io/page/3/index.html">
<meta property="og:site_name" content="Cauil&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cauil&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://cauil.github.io/page/3/"/>





  <title>Cauil's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cauil's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">陌上花开，可缓缓归矣</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/12/15/DiveIntoJs_module_pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/15/DiveIntoJs_module_pattern/" itemprop="url">深入理解Javascript：模块模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-15T00:00:00+08:00">
                2015-12-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文转载自前端乱炖：<a href="http://www.html-js.com/article/Study-JavaScript-Javascript-module-every-day" target="_blank" rel="external">Javascript 模块模式</a></p>
<h2 id="1-Javascript-模块模式"><a href="#1-Javascript-模块模式" class="headerlink" title="1.Javascript 模块模式"></a>1.Javascript 模块模式</h2><p>假设现在我们有一个小型的Js库，目的是用来增加一个数字：</p>
<pre><code>var jspy = {
  count: 0,

  incrementCount: function() {
    this.count++;
  },

  decrementCount: function() {
    this.count--;
  },

  getCount: function() {
    return this.count;
  }

};
</code></pre><p>但是，使用这个js库的人可以用jspy.count = 5 的方法来改变这个值。并不是我们的最初目的。在其他的编程语言中你可以定义一个私有变量，但是Javascript并不能“真正”定义私有变量。然而，我们可以通过操作Javascript来实现，这就引出了一个最流行的Javascript设计模式，模块模式。</p>
<p>针对上面问题的解决方案如下：</p>
<pre><code>var jspy = (function() {
  var _count = 0;

  var incrementCount = function() {
    _count++;
  }

  var getCount = function() {
    return _count;
  }
  return {
    incrementCount: incrementCount,
    getCount: getCount
  };

})();
</code></pre><p>首先我们创造一个_count变量，下划线表明它是一个私有变量。再Javascript中下划线并没有什么实际的意义，但是它是一个用来标明私有变量的普遍用法。现在函数就可以操纵、返回变量了：</p>
<p>然而，你注意到了我吧整个库包含在了一个自调用匿名函数中。这是一个在执行过程中马上被执行的函数。这个函数运行，定义了函数和变量然后到了return {}的部分，它告诉函数将其返回给变量jspy，或者换句话说，暴露给用户。我们暴露两个函数而不是_count变量，这意味着我们可以做如下操作：</p>
<pre><code>jspy.incrementCount();
jspy.getCount();
</code></pre><p>但是当我们试图进行如下操作时：</p>
<pre><code>jspy._count; //undefined
</code></pre><p>它返回undefined。</p>
<p>对于上面的这种设计模式有许多不同的实现方法。有人喜欢在return 中定义函数：</p>
<pre><code>var jspy = (function() {
    var _count = 0;

    return {
      incrementCount: function() {
        _count++;
      },
      getCount: function() {
        return _count;
      }
    };
})();   
</code></pre><p>受到上面例子的启发，CHristian Heilmann提出了Revealing Module Pattern。他的方法是将所有方法定义为私有变量，也就是说，不在return中定义，但是在那里暴露给用户，如下所示：</p>
<pre><code>var jspy = (function() {
  var _count = 0;
  var incrementCount = function() {
    _count++;
  };
  var resetCount = function() {
    _count = 0;
  };
  var getCount = function() {
    return _count;
  };
  return {
    add: incrementCount,
    reset: resetCount,
    get: getCount
  };
})();
</code></pre><p>这种设计模式有两个好处：</p>
<ul>
<li><p>首先，它使我们更容易的了解暴露的函数。当你不在return中定义函数时，我们能轻松的了解到每一行就是一个暴露的函数，这时我们阅读代码更加轻松。</p>
</li>
<li><p>其次，你可以用简短的名字（例如 add）来暴露函数，但在定义的时候仍然可以使用冗余的定义方法（例如 incrementCount）。   </p>
</li>
</ul>
<p>相关阅读：<a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="external">阮一峰：Javascript模块化编程（一）：模块的写法</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/11/19/DiveIntoJs_hoisted/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/19/DiveIntoJs_hoisted/" itemprop="url">深入理解Javascript： 声明提升</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-19T00:00:00+08:00">
                2015-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在JS程序中，我们都会需要声明变量和函数，变量声明和函数声明有些什么要注意的呢？</p>
<p>今天就让我们一探究竟。</p>
<p>先看一个例子：</p>
<pre><code>var scope = &apos;global&apos;;
function checkscope(){
    return scope;
    var scope = &apos;local&apos;;
}
var result = checkscope();
console.log(result);
</code></pre><p>上面例子最后打印出来的result是什么呢，可能有人会说是global，有人会说是local，实际结果却是undifined；</p>
<p>最开始我真是被打击到了，打击过后还是要搞明白啊。</p>
<h2 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1.作用域"></a>1.作用域</h2><p>还是先看一个上面例子的变种：</p>
<pre><code>var scope = &apos;global&apos;;
function checkscope(){
    var scope = &apos;local&apos;;
    return scope;
}
var result = checkscope();
console.log(result);
</code></pre><p>这个可能大家都能说出来是local，是的没错，跟大多数编程语言一样，JS也分全局作用域和函数作用域。</p>
<p>我们先来了解作用域这个概念，在JS中一个变量的作用域是程序源代码中定义这个变量的区域。</p>
<p>全局变量用于全局作用域，在JS代码中的任何地方都是有定义的。然而在函数内的变量只在函数体内有定义。他们是局部变量，作用域是局部的。函数参数也是局部变量，它们只在函数体内有定义。</p>
<p>并且，在函数体内，局部变量的优先级高于同名的全局变量。如果在函数体内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量覆盖。</p>
<p>上面例子的结果就呼之欲出了。</p>
<p>还有一个坑，当我们声明变量时，如果没有加var语句，那么这个变量将会提升为全局变量，如：</p>
<pre><code>var scope = &apos;global&apos;;
function checkscope(){
    scope = &apos;local&apos;;
    return scope;
}
var result = checkscope();
console.log(result); // local
</code></pre><p>结果变成了local，所以平时声明变量都要加var，不然会造成很多bug，或者原本意义的偏离。</p>
<h2 id="2-变量声明提升"><a href="#2-变量声明提升" class="headerlink" title="2.变量声明提升"></a>2.变量声明提升</h2><p>再来看文章开始的例子，为什么会有undefined的结果呢；</p>
<p>原来JS没有块级作用域，JS有函数作用域，变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的，即函数体内的声明的所有变量在函数体内始终是可见的。</p>
<p>有意思的是，这意味着在声明之前甚至可用；JS这个特性被称为变量声明提前，即JS函数内声明的所有变量（不涉及赋值）都被提前至函数体的顶部；这步操作是JS引擎在预编译进行的，是在代码运行之前。</p>
<p>这个例子等价于下面的代码：</p>
<pre><code>var scope = &apos;global&apos;;
function checkscope(){
    var scope;
    return scope;
    scope = &apos;local&apos;;
}
var result = checkscope();
console.log(result);
</code></pre><p>再来看这个例子，我们就知道由于函数作用域的特性，局部变量在整个函数体始终是有定义的，也就是说，在函数体内局部变量遮盖了同名全局变量。尽管如此，只有在程序执行到var scope = ‘local’时，局部变量才被真正赋值。</p>
<p>所以由于JS没有块级作用域，我们编写程序可以将变量声明放在函数体顶部，这样做法是一个很好的反应真实的变量作用域，减少bug。</p>
<h2 id="3-函数声明提升"><a href="#3-函数声明提升" class="headerlink" title="3.函数声明提升"></a>3.函数声明提升</h2><p>老规矩，再来看一个例子：</p>
<pre><code>var foo = 1;
function bar() {
    return foo;
    foo = 2;
    function foo() {return 3;}
    var foo = 4;
}
console.log(bar());
</code></pre><p>大家会不会说是undefined呢？不是的，这个结果是<code>[function: foo]</code>,为什么会出现这种情况呢？</p>
<p>原来函数声明与通过var声明变量一样，<strong>函数声明语句</strong>中的函数被显式地提前到脚本或函数的顶部，因此它们在整个脚本和函数内部都是可见的。</p>
<p>与变量声明提前不同的是：使用var的话，只有变量声明提前，变量的初始化代码仍然在原来的位置。然而用函数声明语句的话，函数名称和函数体均提前,脚本中的所有函数和函数中所嵌套的函数都会在当前上下文中其它代码之前声明。</p>
<p>为什么要指定是函数声明之前呢，因为使用函数定义表达式创建的函数是不会提前的，见下面的例子：</p>
<pre><code>var foo = 1;
function bar() {
    return foo;
    foo = 2;
    var foo = function foo() {return 3;}
    var foo = 4;
}
console.log(bar()); // undefined
</code></pre><p>关于函数定义表达式和函数生命表达式的详细内容，以后在深入理解函数中再讲。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/10/19/DiveIntoJs_Events_propagation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/19/DiveIntoJs_Events_propagation/" itemprop="url">深入理解Javascript：DOM事件之事件传播</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-19T00:00:00+08:00">
                2015-10-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>客户端Javascript程序采用异步事件驱动编程模型。</p>
<p>那首先什么是异步事件驱动编程模型呢？</p>
<p>在这种设计风格下，当文档、浏览器、元素或与之相关的对象发生某些有趣的事情时，Web浏览器就会产生事件。</p>
<p>这些对象等待事件发生，然后他们相应，这就是所谓的异步驱动风格。</p>
<h2 id="1-事件是什么呢？"><a href="#1-事件是什么呢？" class="headerlink" title="1.事件是什么呢？"></a>1.事件是什么呢？</h2><p>事件就是Web浏览器通知应用程序发生了什么事情。</p>
<p>事件类型：是一个用来说明发生什么类型事件的字符串；例如‘mousemove’表示用户移动鼠标，由于事件类型只是一个字符串，有时也可称为事件名字。</p>
<p>事件目标：发生的事件或者与之相关的对象。在JS应用程序中，Windows、Document、Element对象是最常见的事件目标。</p>
<p>下面的代码就是弹出事件目标与类型的方法：</p>
<pre><code>&lt;div id=&apos;box&apos;&gt;
    &lt;button&gt;按钮&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    var bt = document.getElementsByTagName(&apos;button&apos;)[0];

    bt.addEventListener(&apos;click&apos;,function(event){
        alert(&apos;事件目标:&apos; + event.target);
        alert(&apos;事件类型：&apos; + event.type);
    })
&lt;/script&gt;
</code></pre><p>事件处理程序：处理或相应事件的函数。当在特定的事件目标上发生特定类型的事件时，浏览器会调用对应的事件处理程序。</p>
<p>事件对象：与特定事件相关且包含有关该事件详细信息的对象；例如，鼠标事件的相关对象会包含鼠标指针的坐标。</p>
<p>事件传播：浏览器决定哪个对象触发其事件处理程序的过程：</p>
<ul>
<li>对于单个对象的特定事件（比如windows的load事件），必须是不能传播的；</li>
<li>事件传播向上传播，即冒泡传播；</li>
<li>事件处理程序能够通过调用方法或者设置事件对象属性来阻止事件传播，这样就能停止冒泡；</li>
</ul>
<p>事件捕获：事件传播的另外一种形式，在容器元素上注册的特定处理程序有机会在事件传播到真实目标之前捕获它。IE8或之前的版本不支持事件捕获，所以不常用它。</p>
<h2 id="2-事件传播"><a href="#2-事件传播" class="headerlink" title="2.事件传播"></a>2.事件传播</h2><p>上面介绍了什么是事件，下面详细介绍事件的传播机制；</p>
<p>当事件目标是Windows对象或其他的一些单独对象（如XMLHTTPRequest）时，浏览器简单的通过调用对象上适当的处理程序相应事件。</p>
<p>当事件目标是文档或者文档元素时，情况不同：</p>
<p>事件传播有三个阶段：</p>
<p>捕获阶段，发生在目标处理程序调用之前，称为‘捕获’阶段，为<strong>第一阶段</strong>；</p>
<p>目标对象本身的时间处理程序调用是<strong>第二个阶段</strong>；</p>
<p>事件冒泡是事件传播的<strong>第三个阶段</strong>；</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/事件传播.jpg" alt="http://7xj29n.com1.z0.glb.clouddn.com/事件传播.jpg"></p>
<h2 id="3-事件冒泡"><a href="#3-事件冒泡" class="headerlink" title="3.事件冒泡"></a>3.事件冒泡</h2><p>事件最开始由具体的元素（即事件发生的对象）接受，然后逐级向上传播至最不具体的那个节点。</p>
<p>下面是html：</p>
<pre><code>&lt;body&gt;
    &lt;div id=&apos;box&apos;&gt;
        &lt;button&gt;按钮&lt;/button&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre><p>比如当点击上面HTML中的按钮，事件会一直向上冒泡，寻找注册了clink的事件处理程序的元素：</p>
<pre><code>button --&gt;　box --&gt;　body --&gt; html --&gt; document root
</code></pre><h2 id="4-事件捕获"><a href="#4-事件捕获" class="headerlink" title="4.事件捕获"></a>4.事件捕获</h2><p>事件捕获像反向的冒泡阶段；最先调用windows对象的捕获处理程序，然后是Document对象的捕获处理程序，接着是body对象的，再然后是DOM树向下，依次类推，直到调用事件目标的父元素的捕获事件处理程序。</p>
<p>事件捕获只能用于addEventListener()注册且第三个参数是true的事件处理程序中。意味着事件捕获无法在IE9之前的IE中使用。因为IE9之前的IE中不支持addEventListener。</p>
<pre><code>&lt;body&gt;
    &lt;div id=&apos;box&apos;&gt;
        &lt;button&gt;按钮&lt;/button&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre><p>当点击上面html的按钮时，事件捕获阶段会从上到下寻找注册了click事件捕获处理程序的元素：</p>
<pre><code>document root --&gt; html --&gt; body --&gt; box --&gt; button
</code></pre><h2 id="5-事件的取消"><a href="#5-事件的取消" class="headerlink" title="5.事件的取消"></a>5.事件的取消</h2><p>取消事件的浏览器默认操作有三种方式：</p>
<ul>
<li>设置事件处理程序的返回值为false；</li>
<li>在支持addEventListener的浏览器中，也能通过调用事件对象的preventDefault()方法取消事件的默认行为</li>
<li>在IE9之前的IE中，可以设置事件对象的returnValue属性为false</li>
</ul>
<p>取消事件的传播可以通过：</p>
<ul>
<li>在支持addEventListener的浏览器中，也能通过调用事件对象的一个stopPropagation()方法取消事件的继续传播；如果在同一对象上定义了其他处理程序，剩下的处理程序将依旧被调用，但调用stopPropagation方法之后其他任何对象的事件处理程序将不会调用</li>
<li>IE9之前不支持上一种方法的可以通过IE事件对象的cancelBubble属性设置为true能阻止事件进一步冒泡（这些版本事件传播不支持事件的捕获阶段）</li>
</ul>
<h2 id="6-综合例子"><a href="#6-综合例子" class="headerlink" title="6.综合例子"></a>6.综合例子</h2><p>下面是一个综合例子：</p>
<p>当点击按钮时，会依次弹出对话框：‘事件捕获阶段body’、‘事件捕获阶段box’、‘事件捕获阶段：button’、‘事件调用阶段：button’、‘事件冒泡阶段：box’、‘事件冒泡阶段：body’；</p>
<p>当点击box时，会依次弹出对话框：‘事件捕获阶段body’、‘事件捕获阶段box’、‘事件冒泡阶段：box’、‘事件冒泡阶段：body’；</p>
<pre><code>&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;事件流&lt;/title&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;style&gt;
            #box {height:100px;width: 100px;border: solid 1px red; text-align: center;background-color: burlywood}
            #button {border: solid 1px red;}
        &lt;/style&gt;
    &lt;/head&gt;

    &lt;body id=&quot;body&quot;&gt;
        &lt;div id=&quot;box&quot;&gt;box
            &lt;button id=&quot;button&quot;&gt;按钮&lt;/button&gt;
        &lt;/div&gt;
        &lt;script&gt;
            var bt = document.getElementById(&apos;button&apos;);
            var bx = document.getElementById(&apos;box&apos;);
            var bd = document.getElementById(&apos;body&apos;);

            bt.addEventListener(&apos;click&apos;, function(){
                alert(&quot;事件捕获阶段：button&quot;);
            }, true);
            bx.addEventListener(&apos;click&apos;, function(){
                alert(&quot;事件捕获阶段box&quot;);
            },true);
            bd.addEventListener(&apos;click&apos;, function(){
                alert(&quot;事件捕获阶段body&quot;);
                // event.stopPropagation();
            },true);

            bt.addEventListener(&apos;click&apos;, function(){
                alert(&quot;事件调用阶段：button&quot;);
            }, false);
            bx.addEventListener(&apos;click&apos;, function(){
                alert(&quot;事件冒泡阶段：box&quot;);
            },false);
            bd.addEventListener(&apos;click&apos;, function(){
                alert(&quot;事件冒泡阶段：body&quot;);
            },false);
        &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/10/19/DiveIntoJs_compare/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/19/DiveIntoJs_compare/" itemprop="url">深入理解Javascript： 比较</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-19T00:00:00+08:00">
                2015-10-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>开始这个之前我们先看几个例子</p>
<pre><code>var a = [1, 2]
var b = [1, 2]
a == [1, 2] // false
a == b // false

var c = {a: 1, b: 2}
var d = {a: 1, b: 2}
c == d // false

var str = &apos;test&apos;
str == &apos;test&apos; // true

str.toUpperCase() // &apos;TEST&apos;
str // &apos;test&apos;
</code></pre><p>为什么有这种现象发生呢？</p>
<h2 id="1-JS的原始值与对象"><a href="#1-JS的原始值与对象" class="headerlink" title="1.JS的原始值与对象"></a>1.JS的原始值与对象</h2><p>原来JS分为两种对象，一个是原始类型，有undefined、null、布尔值、数字和字符串；一个是对象类型（数组、函数等）；</p>
<p>原始类型值是不可更改的，任何方法都无法更改一个原始值，如上面例子中str经过转换大写之后还是‘test’；原始类型值的比较是值的比较；</p>
<p>对象类型值的比较并非值的比较，即使两个对象包含同样的属性及相同的值，如上例子的a与b、c与d的比较都为false；</p>
<p>对象的比较为引用的比较，当且仅当它们引用同一个基对象时，它们才相等，如下：</p>
<pre><code>var a = [1, 2]
var b = a
a == b // true
</code></pre><h2 id="2-与"><a href="#2-与" class="headerlink" title="2.== 与 ==="></a>2.<code>==</code> 与 <code>===</code></h2><p>再来看一个例子：</p>
<pre><code>1 == &apos;1&apos; // true
1 === &apos;1&apos; // false
var undefined;
undefined == null; // true
1 == true;   // true
2 == true;   // false
0 == false;  // true
0 == &apos;&apos;;     // true
NaN == NaN;  // false
[] == false; // true
[] == ![];   // true
</code></pre><p>为啥会有前面两行的结果呢？</p>
<p>原来‘==’运算符用来检测两个操作数是否相等，这里相等的定义非常宽松，可以允许进行类型转换；</p>
<p>而‘===’运算符用来检测两个操作数是否<strong>严格</strong>相等，会比较两个操作数的类型是否相同；</p>
<h3 id="运算规则"><a href="#运算规则" class="headerlink" title="===运算规则"></a><code>===</code>运算规则</h3><p>‘===’运算符首先计算其操作数的值，然后比较这两个值，比较过程没有任何类型转换；</p>
<ul>
<li><p>如果两个值类型不同，返回false；</p>
</li>
<li><p>如果两个值都为null或者undefined，返回true；</p>
</li>
<li><p>如果两个值都为布尔值true或者false，返回true；</p>
</li>
<li><p>如果其中一个为NaN,则返回false，即使另一个也为NaN；</p>
</li>
<li><p>如果两个值为数字且数值相等，则返回true，0与-0也返回true；</p>
</li>
<li><p>如果两个字符串的长度或者内容不同，则返回false；</p>
</li>
<li><p>如果两个引用值指向同一个对象，则返回true，其他对象比较都返回false；</p>
</li>
</ul>
<h3 id="运算规则-1"><a href="#运算规则-1" class="headerlink" title="==运算规则"></a><code>==</code>运算规则</h3><p>‘==’运算符跟‘===’类似，不过比较并不严格。如果两个操作数类型相同，则和上文所述的严格相等的比较规则一样；</p>
<p>如果两个操作数不是同一类型，那么相等运算符会尝试进行一些类型转换，然后进行比较：</p>
<ul>
<li><p>如果一个值为null，另一个为undefined，则它们相等；</p>
</li>
<li><p>如果一个值是数字，另一个是字符串，先将字符串转换为数字，然后使用转换后的值进行比较；</p>
</li>
<li><p>如果其中一个是true，则将其转换为1再进行比较；如果是false，则转换为0再进行比较；</p>
</li>
<li><p>如果一个值为对象，另一个值是数字或字符串，则使用下一小节要讲的类型转换规则转换为原始值，然后再进行比较；对象通过toString()方法或valueOf方法转换为原始值；JS语言核心的内置类首先尝试使用valueOf()，再尝试toString()，除了日期类，日期类只使用toString()转换。那些不是内置对象则通过各自实现中定义的方法转换为原始值；</p>
</li>
<li><p>其他不同类型之间的比较均不相等；</p>
</li>
</ul>
<p>如<code>&#39;1&#39; == true</code>返回true，其中true转换为1，‘1’转换为1，因为两个数字的值相等，所以返回true。</p>
<h2 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="3.类型转换"></a>3.类型转换</h2><p>类型转换有隐式和显式转换，下图为转换的规则：</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/类型转换.jpg" alt="http://7xj29n.com1.z0.glb.clouddn.com/类型转换.jpg"></p>
<h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><p>做显示转换最简单的方法就是使用Boolean()、Number()、String()或Object()函数；</p>
<p>注意这些函数与它们作为函数构造器是有区别的，作为函数构造器是使用new Number()，这种得出来的是属于包装对象；</p>
<p>如下：</p>
<pre><code>Number(&quot;3&quot;)
new Number(&quot;3&quot;)
typeof Number(&quot;3&quot;) // number
typeof new Number(&quot;3&quot;) // object
</code></pre><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>隐式转换是通过上下语境或者运算符来转换的；</p>
<p>例如‘+’运算符有一个操作数为字符串时，另一个操作数不为字符串时会隐式转换为字符串；’-‘运算符会隐式把两个操作数转换为数字;</p>
<p>再如一元运算符‘！’会把操作数转换为布尔值并取反；如：</p>
<pre><code>12 + &apos;1&apos; // &apos;121&apos;
new Number(&quot;3&quot;) - [1] // 2
!![] // true
</code></pre><p>对应的转换规则如上面图中所示，下面只来说说对象转换为原始值的方式（<em>这里只谈原生对象，而非宿主对象的转换，宿主对象根据各自的算法进行转换</em>）；</p>
<p>1.对象转换为字符串</p>
<ul>
<li>如果对象具有toString()方法，且调用这个方法返回一个原始值，则对象先转换为原始值，然后再通过上图的转换规则转换为字符串；</li>
<li>否则JS会调用valueOf()方法，且调用这个方法返回一个原始值，则对象先转换为原始值，然后再通过上图的转换规则转换为字符串；</li>
<li>如果对象无法从上面两个方法获得一个原始值，这时它将抛出一个类型错误异常；</li>
</ul>
<p>例如计算<code>[1, 2, 3] + &#39;abc&#39;</code>返回<code>&#39;1,2,3abc&#39;</code></p>
<p>首先<code>[1, 2, 3]</code>调用<code>toString()</code>方法返回<code>‘1,2,3’</code>然后再执行字符串的+运算，返回<code>&#39;1,2,3abc&#39;</code></p>
<p>2.对象转换为数字</p>
<p>这个与上面转换为字符串相反，先调用valueOf()，失败再尝试toString()；</p>
<ul>
<li>否则JS会调用valueOf()方法，且调用这个方法返回一个原始值，则对象先转换为原始值，然后再通过上图的转换规则转换为字符串；</li>
<li>如果对象具有toString()方法，且调用这个方法返回一个原始值，则对象先转换为原始值，然后再通过上图的转换规则转换为字符串；</li>
<li>如果对象无法从上面两个方法获得一个原始值，这时它将抛出一个类型错误异常；</li>
</ul>
<p>例如计算<code>[1, 2, 3] - 1</code>返回<code>NaN</code></p>
<p>首先<code>[1, 2, 3]</code>调用<code>valueOf()</code>方法，而此方法返回一个对象而不是原始值，则调用<code>toString()</code>方法，返回<code>‘1,2,3’</code>然后再转换为数字，根据字符串转换为数字的规则，为<code>NaN</code>,<code>NaN - 1</code>返回<code>NaN</code>。</p>
<p>注意：日期对象有点特别，通过valueOf和toString方法返回的原始值将被直接使用；</p>
<h2 id="4-后记"><a href="#4-后记" class="headerlink" title="4.后记"></a>4.后记</h2><p>通过上面的一些例子我们知道JS原始类型与对象类型的一些转换规则以及JS的内部实现，有机会再聊聊JS的常见运算符。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/09/22/css_notes_3-overflow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/22/css_notes_3-overflow/" itemprop="url">CSS：overflow</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-22T00:00:00+08:00">
                2015-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/css/" itemprop="url" rel="index">
                    <span itemprop="name">css</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-overflow基本属性"><a href="#1-overflow基本属性" class="headerlink" title="1.overflow基本属性"></a>1.overflow基本属性</h2><p>值：<code>visible、hidden、scroll、auto、inherit</code></p>
<p>初始值：<code>visible</code></p>
<p>应用于：块级元素和替换元素</p>
<p>继承值：无</p>
<p>计算值：根据指定确定</p>
<h3 id="overflow-x和overflow-y"><a href="#overflow-x和overflow-y" class="headerlink" title="overflow-x和overflow-y"></a>overflow-x和overflow-y</h3><p>当容器高宽都不足以容下图片时，<code>overflow-x:hidden</code>会把x方向的隐藏掉、y方向出现滚动条；为什么会出现这种情况呢？</p>
<p>如果<code>overflow-x</code>和<code>overflow-y</code>值相同，则等同于<code>overflow</code>；</p>
<p>如果<code>overflow-x</code>和<code>overflow-y</code>值不同，且其中一个值为<code>visible</code>，另一个值为<code>hidden、scroll、auto</code>，则<code>visible</code>会被重置为<code>auto</code>；这就是为什么上面的y方向出现滚动条；</p>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>不同浏览器滚动条的表现不一样；</p>
<p>宽度设定机制，见下面一个例子：</p>
<pre><code>&lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;content&quot;&gt;&lt;/div&gt;&lt;/div&gt;

.box { width: 400px; height: 100px; overflow: auto; }
.content { width: 100%; height: 200px; background-color: #beceeb; }
</code></pre><p>在IE7中，垂直和水平方向都出现了滚动条；这是宽度设定机制差异导致的，IE7浏览器把100%宽度算成了外部容器的400px，而垂直方向出现滚动条后，会占用宽度的，从而外部容器水平方向没有400px，从而水平方向出现了滚动条。</p>
<p>如何避免这种情况呢，直接去掉<code>width: 100%</code>就好了。</p>
<p>IE8没有这种情况；</p>
<h3 id="如何使overflow属性有效"><a href="#如何使overflow属性有效" class="headerlink" title="如何使overflow属性有效"></a>如何使overflow属性有效</h3><ul>
<li><p>非<code>display： inline</code>水平</p>
</li>
<li><p>对应方位的尺寸限制；<code>width/height/max-width/max-height/absolute</code>拉伸；</p>
</li>
<li><p>对于单元格td等，还需要table为<code>table-layout：fixed</code>状态才行；</p>
</li>
</ul>
<p>两个IE7的bug：</p>
<p>(1)IE7浏览器下，按钮里的文字越多，按钮两侧的padding留白就越大！</p>
<p>解决方案：给所有按钮添加css样式<code>overflow:visible</code></p>
<p>(2)</p>
<pre><code>.size{ max-width: 200px; max-height: 300px; overflow: auto; }
&lt;div class=&apos;size&apos;&gt;&lt;img src=&quot;mm1.jpg&quot; width=&quot;256&quot; height=&quot;191&quot;&gt;&lt;/div&gt;
</code></pre><p>按理论只有水平出现滚动条，结果垂直方向也出现了；</p>
<h2 id="2-overflow与滚动条"><a href="#2-overflow与滚动条" class="headerlink" title="2.overflow与滚动条"></a>2.overflow与滚动条</h2><h3 id="滚动条出现的条件"><a href="#滚动条出现的条件" class="headerlink" title="滚动条出现的条件"></a>滚动条出现的条件</h3><p>1.<code>overflow:auto/overflow:scroll  //&lt;html&gt;、&lt;textarea&gt;</code></p>
<p>2.当子元素的水平或者垂直方向超过容器对应方向的最大限度；</p>
<h3 id="body-html与滚动条"><a href="#body-html与滚动条" class="headerlink" title="body/html与滚动条"></a>body/html与滚动条</h3><p>无论什么浏览器，<strong>默认滚动条均来自<code>&lt;html&gt;</code></strong>而不是<code>&lt;body&gt;</code>标签；</p>
<p>原因：新建一个空白HTML页面，<code>&lt;body&gt;</code>默认<code>.5em margin</code>值，如果滚动条来自<code>&lt;body&gt;</code>，则应该滚动条与浏览器边框有边距；而事实是滚动条是紧贴着浏览器边框的；</p>
<p>IE7-浏览器默认类似： <code>html { overflow-y: scroll; }</code><br>IE8+等浏览器默认：<code>html { overflow: hidden; }</code></p>
<p>所以，如果我们想要去除页面默认滚动条，只需要：</p>
<pre><code>html { overflow: hidden; }
</code></pre><p>而没必要把<body>也拉下水：</body></p>
<pre><code>html, body { overflow: hidden; } //不需要body标签
</code></pre><h3 id="JS与滚动高度"><a href="#JS与滚动高度" class="headerlink" title="JS与滚动高度"></a>JS与滚动高度</h3><p>chrome浏览器是：<code>document.body.scrollTop</code>;</p>
<p>其他浏览器是：<code>document.documentElement.scrollTop</code>;</p>
<p>目前，两者不会同时存在，因此，有人会写成：</p>
<pre><code>var st = document.body.scrollTop +　document.documentElement.scrollTop
</code></pre><p>建议使用：</p>
<pre><code>var st = document.body.scrollTop ||　document.documentElement.scrollTop
</code></pre><h3 id="overflow的padding-bottom缺失现象"><a href="#overflow的padding-bottom缺失现象" class="headerlink" title="overflow的padding-bottom缺失现象"></a>overflow的padding-bottom缺失现象</h3><pre><code>.box { width: 400px; height: 100px; padding: 100px 0; overflow: auto; }
</code></pre><p>在chrome浏览器下面的padding-bottom可以滚动出来；而其他浏览器都不存在；</p>
<p>可能导致的： 不一样的scrollHeight(元素内容高度)</p>
<h3 id="滚动条的宽度机制"><a href="#滚动条的宽度机制" class="headerlink" title="滚动条的宽度机制"></a>滚动条的宽度机制</h3><p>滚动条会占用容器的可用宽度和高度；</p>
<p>下面这种方法可以计算滚动条的宽度：</p>
<pre><code>.box {width: 400px; overflow: scroll; }
.in {*zoom: 1; /* for IE7 */}

&lt;div class=&quot;box&quot;&gt;
    &lt;div id=&quot;in&quot; class=&quot;in&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

console.log(400 - document.getElementById(&quot;in&quot;).clientWidth);
</code></pre><p>测得的结果：IE7+/Chrome/FireFox(win7)-均是17像素；</p>
<h3 id="overflow-auto的潜在布局隐患"><a href="#overflow-auto的潜在布局隐患" class="headerlink" title="overflow:auto的潜在布局隐患"></a>overflow:auto的潜在布局隐患</h3><p>滚动条会占用容器尺寸，原本和谐的布局，滚动条出现后可能挂掉；</p>
<h3 id="水平居中跳动问题"><a href="#水平居中跳动问题" class="headerlink" title="水平居中跳动问题"></a>水平居中跳动问题</h3><pre><code>.container { width: 1150px; margin: 0 auto; }
</code></pre><p>问题的修复：</p>
<p>1.<code>html { overflow-y: scroll; }</code> // 太丑</p>
<p>2.<code>.container { padding-left: calc(100vw - 100%);}</code></p>
<h2 id="3-overflow与BFC"><a href="#3-overflow与BFC" class="headerlink" title="3.overflow与BFC"></a>3.overflow与BFC</h2><p>BFC(block formatting context) - ‘块级格式化上下面’</p>
<p>BFC有一个特点：页面之结界，内部元素再怎么翻云覆雨都不会影响外部；</p>
<h3 id="overflow与BFC"><a href="#overflow与BFC" class="headerlink" title="overflow与BFC"></a>overflow与BFC</h3><p>overflow有三种属性会触发BFC：<code>auto、scroll、hidden</code></p>
<p>有三种常用用途：</p>
<p>清楚浮动影响、避免margin穿透问题、两栏自适应布局</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/08/21/css_notes_2-float/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/21/css_notes_2-float/" itemprop="url">CSS：浮动</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-21T00:00:00+08:00">
                2015-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/css/" itemprop="url" rel="index">
                    <span itemprop="name">css</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>什么是浮动，浮动有什么作用？</p>
<h2 id="1-浮动的前世今生"><a href="#1-浮动的前世今生" class="headerlink" title="1.浮动的前世今生"></a>1.浮动的前世今生</h2><p>从Netscape1以来，就可以通过声明让图像浮动，如：</p>
<pre><code>&lt;img src=&quot;b5.gif&quot; align=&quot;right&quot;&gt;
</code></pre><p>这会导致一个图像浮动到右边，而允许其他内容如文本“围绕”该图像。</p>
<p>可见浮动的初衷是为了实现文字环绕效果；</p>
<p>过去只可能浮动图像。但CSS允许浮动任何元素，从图像到段落再到列表，所有元素都可以浮动。在CSS中，这种行为是用属性float实现。</p>
<h2 id="2-float取值"><a href="#2-float取值" class="headerlink" title="2.float取值"></a>2.float取值</h2><p>值：left、right、none、inherit</p>
<p>初始值：none</p>
<p>应用于：所有元素</p>
<p>继承值：无</p>
<p>计算值：根据指定确定</p>
<h2 id="3-浮动的特性：包裹与破坏"><a href="#3-浮动的特性：包裹与破坏" class="headerlink" title="3.浮动的特性：包裹与破坏"></a>3.浮动的特性：包裹与破坏</h2><p>什么是包裹（对本身而言）：包裹是收缩、坚挺（有高度了）、隔绝（内部内容与外界不相关）</p>
<p>具有包裹的其他小伙伴：</p>
<ul>
<li><p>display: inline-block/table-cell/…</p>
</li>
<li><p>position: absolute/fixed/sticky</p>
</li>
<li><p>overflow: hidden/scroll</p>
</li>
</ul>
<p>什么是破坏（对父元素而言）：容器被破坏，父元素的高度塌陷</p>
<p>具有破坏的其他小伙伴：</p>
<ul>
<li><p>display: none</p>
</li>
<li><p>position: absolute/fixed/sticky</p>
</li>
</ul>
<p>对于浮动元素有几点要记住。</p>
<p>首先，会以某种方式将浮动元素从文档的正常流中删除，不过它还是会影响布局。</p>
<p>采用CSS的特有方式，浮动元素几乎自成一派，不过它们还是对文档的其他元素有影响。</p>
<h2 id="4-清除浮动"><a href="#4-清除浮动" class="headerlink" title="4.清除浮动"></a>4.清除浮动</h2><p>由于浮动具有破坏性，那我们怎么清楚浮动带来的影响；有以下三种方式：</p>
<p>(1)浮动元素脚底插入clear：both</p>
<p><strong>注意：脚底插入的标签是要为block元素；</strong></p>
<p>直接把<code>&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;</code>放到当作最后一个子标签放到父标签那儿，此方法兼容性强，使用方便，但是浪费了一个标签，而且只能使用一次，而且有时候如果不注意中间多了个空格会产生一段空白高度。</p>
<p>优点：通俗易懂，容易掌握；</p>
<p>缺点：可以想象通过此方法，会添加多少无意义的空标签，有违结构与表现的分离，在后期维护中将是噩梦；<strong>只是解决了浮动，但新添加的标签会与父元素外面的元素发生margin重叠；</strong></p>
<p>(2)使用after伪对象清除浮动（与第一种方法原理相同）</p>
<p>该方法只适用于非IE浏览器，因为IE6/IE7不认识伪元素,具体写法可参照下面例;</p>
<pre><code>.fix{zoom:1;}
.fix:after{
    display:block;
    content:&apos;.&apos;;
    clear:both;
    line-height:0;
    visibility:hidden;
}
</code></pre><p>对于伪元素可以使用下面的方案，不用写太多东西：</p>
<pre><code>.clearfix:after { content: &apos;&apos;; **display: table**; clear: both; }
.clearfix { *zoom: 1; }
</code></pre><p>使用中需注意以下几点：</p>
<p>a.该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；</p>
<p>b.content属性是必须的，但其值可以为空，蓝色理想讨论该方法的时候content属性的值 设为”.”，但我发现为空亦是可以的。</p>
<p>c.line-height:0写成height:0也是可以的。不会影响任何其他样式，通用性强，覆盖面广;</p>
<p>(3)BFC/haslayout解决</p>
<p>例如给包含浮动元素的<strong>父标签</strong>添加css属性<code>.clearfix{overflow:hidden; zoom:1;}</code></p>
<p>其中<code>zoom:1</code>用于让IE6/IE7haslayout又不影响形体的神器。</p>
<p>此方法优点在于代码简洁，涵盖所有浏览器，可是对于overflow:hidden;要是里面的元素要是想来个margin负值定位或是负的绝对定位，岂不是直接被裁掉了，所以此方法是有不小的局限性的。</p>
<p>优点：不存在结构和语义化问题，代码量极少；<strong>父元素把子元素都包裹起来了，子元素不会与外层的元素发生margin重叠；</strong></p>
<p>缺点：内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。</p>
<p>BFC/haslayout通常有以下声明：</p>
<ul>
<li>float:left/right</li>
<li>position:absolute/fixed</li>
<li>overflow:hidden/scroll(IE7+)</li>
<li>display:inline-block/table-cell(IE8+)</li>
<li>width/height/zoom:1/…(IE6/IE7)</li>
</ul>
<p>(4)总结：</p>
<p>此三种方法各有利弊，使用时应择优选择，比较之下第二种方法更为可取；</p>
<p>可以使用兼容性的解决方案：</p>
<pre><code>.clearfix:after { // 解决IE8+
content: &apos;&apos;; 
display: block; 
height: 0; 
overflow: hidden; 
clear: both
}
.clearfix {*zoom: 1;} // 解决IE6/IE7
</code></pre><h2 id="5-浮动的滥用"><a href="#5-浮动的滥用" class="headerlink" title="5.浮动的滥用"></a>5.浮动的滥用</h2><p>浮动的两大特性：元素block块状化（砌砖头）、破坏造成的紧密排列特性（去空格化）</p>
<p>block化即当元素增加浮动属性，其display属性转化为block;</p>
<p>去空格化是指当元素增加浮动属性，后面的空格&amp;nbsp或者换行符\n都被移到后面了，实现了文字环绕效果；而换行符在标签的末尾没有任何表现，&amp;nbsp可以选中；</p>
<p>砌砖布局的问题：</p>
<pre><code>妙脆角-嘎吱脆； // 容错性比较糟糕，容易出问题

吝啬鬼-重用废； // 尺寸限定，模块到另外一个尺寸容器中，不配对，要重新整，完全没有重用性；

洋葱头-IE7飙泪； // 在低版本的IE有很多问题
</code></pre><h2 id="6-float与流体布局"><a href="#6-float与流体布局" class="headerlink" title="6.float与流体布局"></a>6.float与流体布局</h2><p>单侧固定（有两种方式）：</p>
<pre><code>width+float // 这一种是设置紧跟元素的width并设置为右浮动
padding-left/margin-left // 这一种是不设置width，只设置margin-left\
或者padding-left，让其自然适应
</code></pre><p>DOM与显示位置匹配的单侧固定布局：</p>
<pre><code>width:100% + float // 外层
    padding-left/margin-left //设置margin-right，以防父元素的后面元素margin-left进父元素后，内容被父元素内容覆盖
width + float + margin负值 // 设置width和margin-left负值，使其进入上面元素内
</code></pre><p>高级进化 – 智能自适应尺寸（推荐）：</p>
<pre><code>float
display: table-cell; width: 2000px;          IE8+
*display: inline-block; *width: auto;       IE7-
</code></pre><h2 id="7-浮动与兼容型"><a href="#7-浮动与兼容型" class="headerlink" title="7.浮动与兼容型"></a>7.浮动与兼容型</h2><p>IE7的浮动问题：</p>
<ul>
<li><p>含clear的浮动元素包裹不正确的问题</p>
</li>
<li><p>浮动元素倒数两个莫名垂直间距问题</p>
</li>
<li><p>浮动元素最后一个字符重复问题</p>
</li>
<li><p>浮动元素楼梯排列问题</p>
</li>
<li><p>浮动元素和文本不在同一行的问题</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/08/13/css_notes_1-layout/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/13/css_notes_1-layout/" itemprop="url">CSS：网页布局</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-13T00:00:00+08:00">
                2015-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/css/" itemprop="url" rel="index">
                    <span itemprop="name">css</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>三大布局：标准文档流、浮动布局、定位布局</p>
<h3 id="标准文档流（flow）"><a href="#标准文档流（flow）" class="headerlink" title="标准文档流（flow）"></a>标准文档流（flow）</h3><ul>
<li><p>块级元素（block）：从左到右撑满页面，独占行，从上到下</p>
</li>
<li><p>内联元素、或行级元素（inline）：行内显示，从左到右</p>
</li>
<li><p>块级内联元素（inline-block）：行内，但可以像块级元素一样编辑高度、宽度、行高以及顶和底边距</p>
</li>
</ul>
<p><em>注：块级元素和行级元素都是盒子模型</em></p>
<h3 id="浮动布局（float）"><a href="#浮动布局（float）" class="headerlink" title="浮动布局（float）"></a>浮动布局（float）</h3><ul>
<li><p>设置了浮动的元素，仍旧处于标准文档流中</p>
</li>
<li><p>左浮动、右浮动，对紧邻后面的元素有影响</p>
</li>
<li><p>清除浮动：</p>
<ol>
<li>clear：both(left、right）  </li>
<li>同时设置：width:100%（或固定宽度）+ overflow：hidden</li>
</ol>
</li>
</ul>
<h3 id="定位布局（position）"><a href="#定位布局（position）" class="headerlink" title="定位布局（position）"></a>定位布局（position）</h3><p>三种定位方式：静态定位、相对定位、绝对定位</p>
<p>四个属性值：static、relative、absolute、fixed</p>
<ul>
<li><p>相对定位(relative)</p>
<p>  相对于自身位置进行偏移(<strong>原先位置仍然存在，对兄弟模块有影响，占了位置</strong>)、<strong>仍处于标准文档流中</strong>、随即拥有偏移属性和<strong>Z-index属性</strong></p>
</li>
<li><p>绝对定位（absolute）</p>
<p>  （1）建立了以包含块为基准的定位、<strong>完全脱离了标准文档流（对兄弟模块无影响）</strong>、随即拥有偏移属性和<strong>Z-index属性</strong></p>
<p>  （2）未设置偏移量：无论是否存在已定位祖先元素，都保持在元素初始位置。</p>
<p>  （3）设置了偏移量：a.无已定位祖先元素，以<html>为偏移参考基准；b.有已定位祖先元素，以距其最近的已定位祖先元素为偏移参考基准。</html></p>
</li>
<li><p>绝对定位（fixed） </p>
<p>  (1) 与absolute定位类型类似，完全脱离了标准文档流（对兄弟模块无影响），但它的<strong>相对移动的坐标是视图（屏幕内的网页窗口）本身</strong></p>
<p>  (2) 未设置偏移量时，有已定位祖先元素，以祖先元素为基准定位；无已定位元素，以浏览器窗口为基准定位；</p>
<p>  (3)    设置偏移量时，有、无已定位祖先元素，都以浏览器可视窗口为基准偏移；</p>
<p>  <strong>注意：上面设置偏移量的时候，可以根据需求设置，只设置top，只有top方向才会跟已定位的祖先元素偏移，left是不会相对已定位的祖先偏移的</strong></p>
<p>  不过遇到一个问题一直想不明白，两个盒子box1、box2，box1在box2之前，并列关系，box1设置fixed之后，box2设置margin-top为50px，结果box1也跟着下来50px了？？？？</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/06/12/life_shanqiu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/06/12/life_shanqiu/" itemprop="url">山丘</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-06-12T00:00:00+08:00">
                2015-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/life/" itemprop="url" rel="index">
                    <span itemprop="name">life</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>《山丘》</p>
<p><img src="http://7xj29n.com1.z0.glb.clouddn.com/shanqiu.jpg" alt="山丘"></p>
<p>想说却还没说的 还很多</p>
<p>攒着是因为想写成歌</p>
<p>让人轻轻地唱着 淡淡地记着</p>
<p>就算终于忘了 也值了</p>
<p>说不定我一生涓滴意念</p>
<p>侥幸汇成河</p>
<p>然后我俩各自一端</p>
<p>望着大河弯弯 终于敢放胆</p>
<p>嘻皮笑脸 面对 人生的难</p>
<p>也许我们从未成熟</p>
<p>还没能晓得 就快要老了</p>
<p>尽管心里活着的还是那个</p>
<p>年轻人</p>
<p>因为不安而频频回首</p>
<p>无知地索求 羞耻于求救</p>
<p>不知疲倦地翻越 每一个山丘</p>
<p>越过山丘 虽然已白了头</p>
<p>喋喋不休 时不我予的哀愁</p>
<p>还未如愿见着不朽</p>
<p>就把自己先搞丢</p>
<p>越过山丘 才发现无人等候</p>
<p>喋喋不休 再也唤不回温柔</p>
<p>为何记不得上一次是谁给的拥抱</p>
<p>在什么时候</p>
<p>我没有刻意隐藏 也无意让你感伤</p>
<p>多少次我们无醉不欢</p>
<p>咒骂人生太短 唏嘘相见恨晚</p>
<p>让女人把妆哭花了 也不管</p>
<p>遗憾我们从未成熟</p>
<p>还没能晓得 就已经老了</p>
<p>尽力却仍不明白</p>
<p>身边的年轻人</p>
<p>给自己随便找个理由</p>
<p>向情爱的挑逗 命运的左右</p>
<p>不自量力地还手 直至死方休</p>
<p>越过山丘 虽然已白了头</p>
<p>喋喋不休 时不我予的哀愁</p>
<p>还未如愿见着不朽</p>
<p>就把自己先搞丢</p>
<p>越过山丘 才发现无人等候</p>
<p>喋喋不休 再也唤不回了温柔</p>
<p>为何记不得上一次是谁给的拥抱</p>
<p>在什么时候</p>
<p>越过山丘 虽然已白了头</p>
<p>喋喋不休 时不我予的哀愁</p>
<p>还未如愿见着不朽</p>
<p>就把自己先搞丢</p>
<p>越过山丘 才发现无人等候</p>
<p>喋喋不休 再也唤不回了温柔</p>
<p>为何记不得上一次是谁给的拥抱</p>
<p>在什么时候</p>
<p>喋喋不休 时不我予的哀愁</p>
<p>向情爱的挑逗 命运的左右</p>
<p>不自量力地还手 直至死方休</p>
<p>为何记不得上一次是谁给的拥抱</p>
<p>在什么时候</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/05/24/js_journey_0105-Objects/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/24/js_journey_0105-Objects/" itemprop="url">JS之旅（启程）：对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-24T00:00:00+08:00">
                2015-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>下面代码都在node.js测试</strong></p>
<p>这一次我们来谈谈对象。</p>
<h2 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h2><p>对象是一种复合值。</p>
<p>对象是属性的无序集合，每个属性都是一个名/值对。</p>
<p>对象不仅仅是字符串到值的映射，除了可以保持自有的属性，还可以从原型对象继承属性。这种原型式继承是JS的核心特征。</p>
<p>对象是动态的，可以新增属性也可以删除属性。对象是可变，我们通过引用而非值来操作对象，如：</p>
<pre><code>var x = {a:1, b:2};
var y = x;
y; // {a:1, b:2}
y.b = 3;
y; // {a:1, b:3}
x; // {a:1, b:3}
</code></pre><p>对象常见方法有：创建、设置、查找、删除、检测和枚举它的属性，接下来一一解析这些方法。</p>
<p>对象属性特性（property attribute）：可写、可枚举、可配置。</p>
<p>对象自身还拥有三个相关的对象特性（attribute）：原型、类、扩展标记。</p>
<p>对象分类：内置对象、宿主对象、自定义对象。</p>
<p>对象属性分类：自有属性、继承属性。</p>
<h3 id="对象的KEY"><a href="#对象的KEY" class="headerlink" title="对象的KEY"></a>对象的KEY</h3><p>对象的key为字符串，即使不为字符串，也会转换为字符串类型。如：</p>
<pre><code>var obj = {};
obj[1] = 1;
obj[&apos;1&apos;] = 2;
obj; // Object {1: 2}

obj[{}] = true; // {}会转换为字符串&apos;[object Object]&apos;
obj[{x : 1}] = true; // {x: 1}会转换为字符串&apos;[object Object]&apos;
obj; // Object {1: 2, [object Object]: true}
</code></pre><p>对象中不能存在两个同名的属性，如：</p>
<pre><code>var obj = {a: 1, a: 2};
obj; // {a:2}
</code></pre><h3 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h3><p>对象的属性有五个特征：</p>
<p>writable、enumerable、configurable、value、get/set</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>可以通过对象直接量、关键字new和Object.create()函数来创建。</p>
<h3 id="字面量创建"><a href="#字面量创建" class="headerlink" title="字面量创建"></a>字面量创建</h3><pre><code>var obj1 = {x: 1, y: 2};
</code></pre><p>在ES5中，保留字可以用作不带引号的属性名；而ES3使用保留字作为属性名必须使用引号引起来。</p>
<p>在ES5中，对象直接量最后一个属性后的逗号将忽略；且在ES3的大部分实现中也可以忽略这个逗号，而在IE中则报错。</p>
<p><strong>注意</strong>：所有通过对象直接量创建的对象都具有同一个原型，原型指向<code>Object.prototype</code></p>
<h3 id="new以及原型链"><a href="#new以及原型链" class="headerlink" title="new以及原型链"></a>new以及原型链</h3><p>通过关键字new和构造函数调用创建的对象的原型就是构造函数的prototype属性的值。通过new Array()创建的对象的原型就是Array.prototype,通过new Date()创建的对象原型就是Date.prototype。</p>
<p>所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自Object.prototype的原型。因此由new Date()创建的对象同时继承Array.prototype和Object.prototype。这一系列链接的原型对象就是所谓的原型链。</p>
<h3 id="Object-create-ES5定义"><a href="#Object-create-ES5定义" class="headerlink" title="Object.create() ES5定义"></a>Object.create() ES5定义</h3><p>直接在花括号里传入所需的原型对象即可：</p>
<pre><code>var obj = Object.create({x : 1});
obj.x // 1
typeof obj.toString // &quot;function&quot;
obj.hasOwnProperty(&apos;x&apos;);// false
</code></pre><p>可以通过传入参数null来创建一个没有原型的新对象，但通过这种方法创建的对象不会继承任何东西，甚至包括基础方法，如：</p>
<pre><code>var obj = Object.create(null);
obj.toString // undefined，注意与上面例子的比较
</code></pre><p><strong>注意</strong>：obj原型为{x:1}，而{x:1}原型为Object.prototype，所以obj可以访问到toString方法</p>
<p>如果想通过Object.create()来创建一个空对象，可以通过下面方法来创建：（也可以通过{}和new Object()来创建）</p>
<pre><code>Object.create(Object.prototype)
</code></pre><p>ES3模拟原型继承，不过inherit不能完全替代Object.create()，因为前者不能传入null来创建对象，也不能接受可选的第二个参数，下面为inherit的实现：</p>
<pre><code>function inherit(p){
    if(p == null){
        throw TypeError();
    }
    if(Object.create){
        return Object.create(p);
    }
    var t = typeof p;
    if (t !== &quot;object&quot; &amp;&amp; t !== &quot;function&quot;){
        throw TypeError();
    }
    function f(){};
    f.prototype = p;
    return new f();
}
</code></pre><h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h2><h3 id="属性的查询和设置"><a href="#属性的查询和设置" class="headerlink" title="属性的查询和设置"></a>属性的查询和设置</h3><p>可以通过.运算符或者方括号[]访问属性。对于.运算符来说，右侧必须是一个以属性名称命名的简单标识符；对于方括号来说，方括号内必须是一个计算结果为字符串的表达式（严格地讲，表达式必须返回字符串或返回一个可以转换为字符串的值），如：</p>
<pre><code>var obj = {&apos;5&apos;: &quot;abc&quot;, &apos;7&apos;: &quot;cdf&quot;, c: 100};
obj.c; // 100
obj[&apos;c&apos;]; // 100
obj[c]; // Error：c is not defined
obj[1]; //  undefined,因为1会转换为字符串&apos;1&apos;
obj[&apos;5&apos;]; // &apos;abc&apos;
obj[1+4]; // &apos;abc&apos;
</code></pre><p>在ES3中，点.后面的标识符不能是保留字，ES5放宽了，可以直接在.运算符后面直接使用保留字。</p>
<h4 id="关联数组的对象"><a href="#关联数组的对象" class="headerlink" title="关联数组的对象"></a>关联数组的对象</h4><p>使用.运算符来访问对象的属性时，属性名用一个标识符来表示，由于标识符不是数据类型，因此程序无法修改它们。</p>
<p>而通过[]来访问时，属性名通过字符串来表示，在程序运行时，可以修改和创建他们，如：</p>
<pre><code>var addr = &quot;&quot;
for(i=0; i&lt;4; i++){
    addr += customer[&quot;address&quot; + i] + &apos;\n&apos;;
}
</code></pre><p>可以看见关联数组的方式来实现更强大、更灵活，推荐。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>属性访问细节：</p>
<p>假如要查询对象o的属性x，如果o中不存在x，那么将会继续在o的原型对象中查询属性x。如果原型对象中也没有x，但这个原型也有原型，那么继续在这个原型对象的原型上执行查询，直到找到x或者查找到一个原型是null的对象为止。如：</p>
<pre><code>var o = {};
o.x = 1;
var p = Object.create(o);
p.y = 2;
var q = Object.create(p);
q.z = 3;
q.x + q.y //3 ，x和y分别继承自o和p
</code></pre><p>属性赋值细节：</p>
<p>1.假如对象o已经有属性x（这个属性不是继承来的），那么这个赋值操作只改变这个已有属性x的值。</p>
<p>2.如果o不存在x，接着判断：</p>
<p>(1)现在如果原型上有属性x且为可写，则会为o创建一个x属性；</p>
<p>(2)如果原型上有属性x且不可写，则赋值失败；</p>
<p>如：</p>
<pre><code>var obj1 = {};
Object.defineProperty(obj1, &apos;z&apos;, {value:1, writable:false, enumerable: true, configurable:true});
obj1.z; // 1
Object.keys(obj1); // [&apos;z&apos;]
obj2 = Object.create(obj1);
obj2.z; // 1
obj2.z=2; // 赋值失败，则有下面的结果
obj2.z; // 1
obj2.hasOwnProperty(&apos;z&apos;); // false
Object.defineProperty(obj1, &apos;z&apos;, {value:1, writable:true, enumerable: true, configurable:true});
obj2.z=2; // 赋值成功，则有下面的结果
obj2.z; // 2
obj2.hasOwnProperty(&apos;z&apos;); // true
</code></pre><p><strong>注意</strong>：如果原型上有属性x，而这个属性是一个具有setter方法的accessor属性，那么这时将调用setter方法而不是给o创建一个属性x。且setter是对象o调用的，因此setter方法的操作只是针对o本身，并不会修改原型链。（此处例子见下面set/get介绍）</p>
<p><strong>注意</strong>：只有在查询属性时才会体会到继承的存在，而设置属性则和继承无关。</p>
<h4 id="属性访问错误"><a href="#属性访问错误" class="headerlink" title="属性访问错误"></a>属性访问错误</h4><p>查询一个不存在的属性并不会报错，如：</p>
<pre><code>var obj = {x : 1};
obj.y; // undefined
</code></pre><p>但是，如果对象不存在，那么试图查询这个不存在的对象的属性就会报错，如：</p>
<pre><code>var yz = obj.y.z; // TypeError: Cannot read property &apos;z&apos; of undefined
obj.y.z = 2; // TypeError: Cannot set property &apos;z&apos; of undefined
</code></pre><p>处理方式：</p>
<pre><code>var yz;
    if (obj.y) {
    yz = obj.y.z;
}
</code></pre><p>更简练的方式，可以使用&amp;&amp;的短路行为：</p>
<pre><code>var yz = obj &amp;&amp; obj.y &amp;&amp; obj.y.z
</code></pre><p>给null和undefined设置属性也会报类型错误。设置属性的失败操作都会抛出一个类型错误异常，除了一些对象例外，如：</p>
<pre><code>Object.prototype = 1; 
Object.prototype // {},赋值失败，但上面没有报错
</code></pre><p>这是一个历史遗留bug，在严格模式下，任何设置属性的失败操作都会抛出一个类型错误异常。</p>
<h3 id="属性的删除"><a href="#属性的删除" class="headerlink" title="属性的删除"></a>属性的删除</h3><p>delete可以删除对象的属性，如</p>
<pre><code>var person = {age : 28, title : &apos;fe&apos;};
delete person.age; // true
delete person[&apos;title&apos;]; // true
person.age; // undefined
delete person.age; // true
</code></pre><p>需要注意，delete只是断开属性和宿主对象的联系，而不会去操作属性中的属性，由于已经删除的属性的引用依然存在，可能因为这种不严谨的代码而造成内存泄露，如</p>
<pre><code>var a = {p: {x:1}};
var b = a.p;
b; // {x:1}
delete a.p;
b; // {x:1}
</code></pre><p>delete只能删除自有属性，而不能删除继承属性。</p>
<p>delete不能删除那些可配置性为false的属性，在严格模式下，删除一个不可配置属性会报一类型错误，在非严格模式下，这些情况下的delete操作会返回一个false：</p>
<pre><code>delete Object.prototype; // false,

var descriptor = Object.getOwnPropertyDescriptor(Object, &apos;prototype&apos;);
descriptor.configurable; // false
</code></pre><p>另外，用var定义的全局变量或者局部变量也不能删除，全局函数或者局部函数也不能删除，如：</p>
<pre><code>var globalVal = 1;
delete globalVal; // false

(function() {
       var localVal = 1;
    return delete localVal;
}()); // false


function fd() {}
delete fd; // false

(function() {
    function fd() {};
    return delete fd;
}()); // false
</code></pre><p>隐式定义的全局变量可以删除，如</p>
<pre><code>ohNo = 1;
ohNo; // 1
delete ohNo; // true
</code></pre><p><strong>注意</strong>：属性的删除由属性的特性configurable值来控制。</p>
<h3 id="属性的检测"><a href="#属性的检测" class="headerlink" title="属性的检测"></a>属性的检测</h3><p>三种方法：in运算符、hasOwnProperty(是否是自有属性)、propertyIsEnumerable(检测是否为自有属性且可枚举)，如：</p>
<pre><code>var cat = new Object;
cat.legs = 4; // leg属性自有且可枚举
Object.defineProperty(cat, &apos;age&apos;, {value:1, writable:true, enumerable: false, configurable:true}); // age属性为自有但不可枚举

&apos;legs&apos; in cat; // true
&apos;age&apos; in cat; // true
&apos;abc&apos; in cat; // false
&quot;toString&quot; in cat; // true, inherited property!!!

cat.hasOwnProperty(&apos;legs&apos;); // true
cat.hasOwnProperty(&apos;age&apos;); // true
cat.hasOwnProperty(&apos;toString&apos;); // false

cat.propertyIsEnumerable(&apos;legs&apos;); // true
cat.propertyIsEnumerable(&apos;age&apos;); // false
cat.propertyIsEnumerable(&apos;toString&apos;); // false

Object.keys(cat); //legs
</code></pre><p>属性设置方法（用defineProperty设置的属性默认是不可枚举）：</p>
<pre><code>Object.defineProperty(cat, &apos;price&apos;, {value : 1000});
Object.getOwnPropertyDescriptor(cat, &apos;price&apos;); // {value: 1000, writable: false, enumerable: false, configurable: false}
cat.propertyIsEnumerable(&apos;price&apos;); // false
cat.hasOwnProperty(&apos;price&apos;); // true
</code></pre><p>除了使用in运算符外，另一种更简单的方法是使用“!==”判断一个属性是否是undefined，但当一个属性值刚好为undefined时无效，这时用in运算符才准确，如：</p>
<pre><code>var o = {x:1}
o.x !== undefined; // true
o.y !== undefined; // false

var o = {x: undefined}
o.x !== undefined; // false
o.y !== undefined; // false
&quot;x&quot; in o; // true
&quot;y&quot; in o; // false
</code></pre><p><strong>注意</strong>：!=不是严格等于，undefined与null相等，所以有下面的：</p>
<pre><code>if (cat.legs != undefined) {
    // !== undefined, or, !== null
}
</code></pre><h3 id="属性的枚举"><a href="#属性的枚举" class="headerlink" title="属性的枚举"></a>属性的枚举</h3><p>对象继承的内置方法不可枚举，但在代码中给对象添加的属性都是可枚举的（除了defineProperty这类情况），见例子：</p>
<pre><code>var o = {x : 1, y : 2, z : 3};
&apos;toString&apos; in o; // true
o.propertyIsEnumerable(&apos;toString&apos;); // false
var key;
for (key in o) {
    console.log(key); // x, y, z
}
</code></pre><p>for..in..会去原型链上枚举所有特征Enumerable为true的属性，如：</p>
<pre><code>var obj = Object.create(o);
obj.a = 4;
var key;
for (key in obj) {
    console.log(key); // a, x, y, z
}
</code></pre><p>只枚举出是自己属性的：</p>
<pre><code>var obj = Object.create(o);
obj.a = 4;
var key;
for (key in obj) {
    if (obj.hasOwnProperty(key)) {
        console.log(key); // a
    }
}
</code></pre><p>ES5增加了两个用于枚举属性名称的函数，Object.keys()和Object.getOwnPropertyNames(),如：</p>
<pre><code>Object.defineProperty(obj, &apos;b&apos;, {value:1}) // 属性b不可枚举
Object.keys(obj); // [&apos;a&apos;],枚举出特性为可枚举的自有属性
Object.getOwnPropertyNames(obj); // [&apos;a&apos;, &apos;b&apos;]，所有自有属性，不管特性是否可枚举
</code></pre><h3 id="get、set方法"><a href="#get、set方法" class="headerlink" title="get、set方法"></a>get、set方法</h3><p>对象的属性分为数据属性和存取器属性，存取器属性就是属性值可以用一个或两个方法替代，这两个方法就是setter、getter</p>
<p>读取存取器属性的值是，调用getter方法（无参数），这个方法的返回值就是存取器属性的值；当程序设置一个存取器属性的值时，JS调用setter方法，将赋值表达式右侧的值当做参数传入setter，可以忽略setter的返回值。</p>
<p>读取只写属性总是返回undefined，如：</p>
<pre><code>var o = { set a(value){}};
o.a; // undefined
</code></pre><p>先看一个例子：</p>
<pre><code>var man = {
    name : &apos;cauil&apos;,
    weibo : &apos;@cauil&apos;,
    get age() {
        return new Date().getFullYear() - 1989;
    },
    set age(val) {
        console.log(&apos;Age can\&apos;t be set to &apos; + val);
    }
}

console.log(man.age); // 
man.age = 100; // Age can&apos;t be set to 100
console.log(man.age); // still 27
</code></pre><p>再来看一个例子：</p>
<pre><code>var man = {
    weibo : &apos;@cauil&apos;,
    $age : null,
    get age() {
        if (this.$age == undefined) {
            return new Date().getFullYear() - 1989;
        } else {
            return this.$age;
        }
    },
    set age(val) {
        val = +val;
        if (!isNaN(val) &amp;&amp; val &gt; 0 &amp;&amp; val &lt; 150) {
            this.$age = val;
        } else {
            throw new Error(&apos;Incorrect val = &apos; + val);
        }
    }
}

console.log(man.age); // 27
man.age = 100;
console.log(man.age); // 100;
man.age = &apos;abc&apos;; // error:Incorrect val = NaN
</code></pre><p>get/set与原型链, 本身对象属性不存在时，会去原型上查找，尝试赋值时，会去读取原型链上的set方法，是原型调用：</p>
<pre><code>function foo(){};

Object.defineProperty(foo.prototype, &apos;z&apos;, 
    {get: function(){return 1;}});
var obj = new foo();

obj.z; // 1
obj.z = 10;
obj.z; // still 1

Object.defineProperty(obj, &apos;z&apos;, 
{value : 100, configurable: true});
obj.z; // 100;
delete obj.z;
obj.z; //back to 1
</code></pre><p>如果o继承自一个只读属性x，那么赋值操作是不允许的，如果允许属性赋值，它也只是在原始对象上创建属性或对已有的属性赋值，而不会去修改原型链，如：</p>
<pre><code>var o = {};
Object.defineProperty(o, &apos;x&apos;, {value : 1}); // writable=false, configurable=false
var obj = Object.create(o);
obj.x; // 1
obj.x = 200;
obj.x; // still 1, can&apos;t change it

Object.defineProperty(obj, &apos;x&apos;, {writable:true, configurable:true, value : 100});
obj.x; // 100
obj.x = 500;
obj.x; // 500
</code></pre><h2 id="属性特性"><a href="#属性特性" class="headerlink" title="属性特性"></a>属性特性</h2><p>数据属性具有四个特性：value、writable、enumerable、configurable</p>
<p>存取器属性具有四个特性：set、get、enumerable、configurable</p>
<h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h3><p>可以获取某个对象特定属性的属性描述符,如：</p>
<pre><code>var o = {x:1, get y(){}, set y(value){}}
// { value: 1, writable: true, enumerable: true, configurable: true }
Object.getOwnPropertyDescriptor(o, &quot;x&quot;); 

// { get: [Function: y], set: [Function: y], enumerable: true, configurable: true } 
Object.getOwnPropertyDescriptor(o, &quot;y&quot;);
</code></pre><p>对于不存在和继承的属性，返回undefined，如：</p>
<pre><code>Object.getOwnPropertyDescriptor(o, &quot;z&quot;); // undefined
Object.getOwnPropertyDescriptor(o, &quot;toString&quot;); // undefined
</code></pre><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><p>此方法是设置属性的特性，或者让新建对象具有某种特性，使用这种方法设置的属性，如果没有定义的特性，则默认为false，先看一个例子：</p>
<pre><code>Object.getOwnPropertyDescriptor({pro : true}, &apos;pro&apos;);
// Object {value: true, writable: true, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor({pro : true}, &apos;a&apos;); // undefined
</code></pre><p>再看一个例子：</p>
<pre><code>var person = {};
Object.defineProperty(person, &apos;name&apos;, {
    configurable : false,
    writable : false,
    enumerable : true,
    value : &quot;Bosn Ma&quot;
});

person.name; // Bosn Ma
person.name = 1;
person.name; // still Bosn Ma
delete person.name; // false，因为name特性为不可配置
</code></pre><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>Object.keys(person)获取person的所有可枚举自有属性，如：</p>
<pre><code>Object.defineProperty(person, &apos;type&apos;, {
    configurable : true,
    writable : true,
    enumerable : false,
    value : &quot;Object&quot;
});

Object.keys(person); // 只有[&quot;name&quot;]
</code></pre><h3 id="Object-defineProperties-定义多个对象"><a href="#Object-defineProperties-定义多个对象" class="headerlink" title="Object.defineProperties()定义多个对象"></a>Object.defineProperties()定义多个对象</h3><pre><code>Object.defineProperties(person, {
    title : {value : &apos;fe&apos;, enumerable : true},
    corp : {value : &apos;BABA&apos;, enumerable : true},
    salary : {value : 50000, enumerable : true, writable : true}
});

Object.getOwnPropertyDescriptor(person, &apos;salary&apos;);
// Object {value: 50000, writable: true, enumerable: true, configurable: false}
</code></pre><h3 id="特征定义"><a href="#特征定义" class="headerlink" title="特征定义"></a>特征定义</h3><p>configurable主要控制是否可以delete、是否可以修改get/set方法，是否可以修改特征值（如writable和configurable）的属性。</p>
<p>writable主要控制属性值是否可以修改值。</p>
<p><strong>注意</strong>：有一个特例，当configurable为false时，writable可以从true修改为false，其他情况都不能配置特征的值。</p>
<h2 id="对象本身特征与序列化（待整理修改）"><a href="#对象本身特征与序列化（待整理修改）" class="headerlink" title="对象本身特征与序列化（待整理修改）"></a>对象本身特征与序列化（待整理修改）</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>获取对象的原型，使用Object.getPrototypeOf(),只会返回原型，不会返回原型链，如</p>
<pre><code>var o = { x:1, y:2};
var p = new Array();
var q = Object.create(o);

Object.getPrototypeOf(o); // {}
Object.getPrototypeOf(p); // []
Object.getPrototypeOf(q); // {x:1, y:2}
</code></pre><p>判断x是否为y的原型，使用x.isPrototypeof(y)</p>
<pre><code>var o = {x:1}
var p = Object.create(o);

o.isPrototypeOf(p); // true
Object.prototype.isPrototypeOf(p); // true
</code></pre><h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>对象的类属性是一个字符串，用以表示对象的类型信息，如：</p>
<pre><code>var toString = Object.prototype.toString;
function getType(o){return toString.call(o).slice(8,-1);};


toString.call(null); // &quot;[object Null]&quot;
getType(null); // &quot;Null&quot;
getType(undefined); // &quot;Undefined&quot;
getType(1); // &quot;Number&quot;
getType(new Number(1)); // &quot;Number&quot;
typeof new Number(1); // &quot;object&quot;
getType(true); // &quot;Boolean&quot;
getType(new Boolean(true)); // &quot;Boolean&quot;
</code></pre><p>其中new Number(1)为Object Number</p>
<h3 id="extensible"><a href="#extensible" class="headerlink" title="extensible"></a>extensible</h3><p>Object.preventExtensions会设置对象是否不可扩展，如：</p>
<pre><code>var obj = {x : 1, y : 2};
Object.isExtensible(obj); // true
Object.preventExtensions(obj);
Object.isExtensible(obj); // false
obj.z = 1;
obj.z; // undefined, add new property failed
Object.getOwnPropertyDescriptor(obj, &apos;x&apos;);
// Object {value: 1, writable: true, enumerable: true, configurable: true}
</code></pre><p><code>Object.seal</code>会在<code>preventExtensions</code>基础上添加<code>configurable:false</code>特征，如：</p>
<pre><code>Object.seal(obj);
Object.getOwnPropertyDescriptor(obj, &apos;x&apos;);
// Object {value: 1, writable: true, enumerable: true, configurable: false}
Object.isSealed(obj); // true
</code></pre><p><code>Object.freeze</code>会在<code>preventExtensions</code>基础上添加<code>configurable:false，writable:false</code>特征，如：</p>
<pre><code>Object.freeze(obj);
Object.getOwnPropertyDescriptor(obj, &apos;x&apos;);
// Object {value: 1, writable: false, enumerable: true, configurable: false}
Object.isFrozen(obj); // true
</code></pre><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>对象系列化可以使用<code>JSON.stringfy(obj)</code>,如：</p>
<pre><code>var obj = {x : 1, y : true, z : [1, 2, 3], nullVal : null};
JSON.stringify(obj); // &quot;{&quot;x&quot;:1,&quot;y&quot;:true,&quot;z&quot;:[1,2,3],&quot;nullVal&quot;:null}&quot;
</code></pre><p>序列化的一个属性值为<code>undefined</code>时，会忽略；时间对象会转化为UTC格式；<code>NaN/infinity</code>会转化为<code>null</code>，如：</p>
<pre><code>obj = {val : undefined, a : NaN, b : Infinity, c : new Date()};
JSON.stringify(obj); // &quot;{&quot;a&quot;:null,&quot;b&quot;:null,&quot;c&quot;:&quot;2015-01-20T14:15:43.910Z&quot;}&quot;
</code></pre><p>JSON转化为javascipt对象，需要用引号引起来，如：</p>
<pre><code>obj = JSON.parse(&apos;{&quot;x&quot; : 1}&apos;);
obj.x; // 1
</code></pre><p>自定义：</p>
<pre><code>var obj = {
    x : 1,
    y : 2,
    o : {
        o1 : 1,
        o2 : 2,
        toJSON : function () {
            return this.o1 + this.o2;
        }
    }
};
JSON.stringify(obj); // &quot;{&quot;x&quot;:1,&quot;y&quot;:2,&quot;o&quot;:3}&quot;
</code></pre><p>定义自己对象上的toString方法和valueOf方法，如：</p>
<pre><code>var obj = {x : 1, y : 2};
obj.toString(); // &quot;[object Object]&quot;
obj.toString = function() {return this.x + this.y};
&quot;Result &quot; + obj; // &quot;Result 3&quot;, by toString

+obj; // 3, from toString

obj.valueOf = function() {return this.x + this.y + 100;};
+obj; // 103, from valueOf

&quot;Result &quot; + obj; // still &quot;Result 3&quot;
</code></pre><p>如果运算的对象的<code>valueof</code>和<code>toString</code>都存在，当进行一元‘+’和二元‘+’运算的时候，会进行转换字符串的操作；</p>
<p>如果<code>valueOf</code>方法存在返回的是基本类型的值，以<code>valueOf</code>的值为结果，反之，valueOf不存在或者返回的是对象，则会去找<code>toString</code>方法，如果两者都不存在或者返回对象，就会报错。</p>
<p>不过一般都会继承<code>Object.prototype.toString</code>的方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2015/04/16/life_Epitaph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/16/life_Epitaph/" itemprop="url">伦敦威斯敏斯特教堂一墓志铭</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-16T00:00:00+08:00">
                2015-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书/" itemprop="url" rel="index">
                    <span itemprop="name">读书</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在伦敦威斯敏斯特教堂旁，矗立着一块墓碑上书：</p>
<p>“当我年轻时，我梦想改变这个世界；<br>当我成熟后，我发现我不能改变这个世界，我决定只改变我的国家；<br>当我进入暮年，我发现我不能改变我们的国家，我的最后愿望仅仅是改变一下我的家庭，但是，这也不可能。</p>
<p>当我现在躺在床上，行将就木，我突然意识到：如果一开始我仅仅去改变我自己，然后，我可能改变我的家庭；<br>在家人的帮助和鼓励下，我可能为国家做一些事情；<br>然后，谁知道呢？我甚至可能改变这个世界。” </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/abu.jpg"
                alt="cauil" />
            
              <p class="site-author-name" itemprop="name">cauil</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/cauil" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/cauil" target="_blank" title="Weibo">
                    
                      <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://douban.com/people/cauil" target="_blank" title="DouBan">
                    
                      <i class="fa fa-fw fa-douban"></i>DouBan</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cauil</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
