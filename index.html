<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Cauil&#39;s Blog">
<meta property="og:url" content="http://cauil.github.io/index.html">
<meta property="og:site_name" content="Cauil&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cauil&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://cauil.github.io/"/>





  <title>Cauil's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cauil's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">陌上花开，可缓缓归矣</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/27/2017-11-27-ES6之Set与Map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/27/2017-11-27-ES6之Set与Map/" itemprop="url">ES6之Set与Map</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-27T00:00:00+08:00">
                2017-11-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为啥引入Set与Map"><a href="#为啥引入Set与Map" class="headerlink" title="为啥引入Set与Map"></a>为啥引入Set与Map</h2><p>在ES6之前，当想使用非数值型索引，就会用非数组对象创建所需的数据结构；</p>
<p>ES5中set集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var set = Object.create(null);</div><div class="line">set.foo = true;</div><div class="line">// checking for existence</div><div class="line">if (set.foo) &#123;</div><div class="line">    // code to execute</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Map集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var map = Object.create(null);</div><div class="line">map.foo = &quot;bar&quot;;</div><div class="line">// retrieving a value</div><div class="line">var value = map.foo;</div><div class="line">console.log(value);         // &quot;bar&quot;</div></pre></td></tr></table></figure>
<p>用这种方法的确可以模拟Set集合与Map集合，但这种<strong>所有对象的属性名必须是字符串类型，必须确保每个键名都是字符串类型且在对象中是唯一的</strong>。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var map = Object.create(null);</div><div class="line">map[5] = &quot;foo&quot;;</div><div class="line">console.log(map[&quot;5&quot;]);      // &quot;foo&quot;</div><div class="line"></div><div class="line">var map = Object.create(null),</div><div class="line">    key1 = &#123;&#125;,</div><div class="line">    key2 = &#123;&#125;;</div><div class="line">map[key1] = &quot;foo&quot;;</div><div class="line">console.log(map[key2]); // &quot;foo&quot;</div></pre></td></tr></table></figure>
<p>对于Map集合中，如果它的属性值是假值，则要求使用布尔值的情况下，会被自动转换成false。当在判断Map结合中是否有某些属性场景会有问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var map = Object.create(null);</div><div class="line">map.count = 0;</div><div class="line">// checking for the existence of &quot;count&quot; or for a nonzero value?</div><div class="line">if (map.count) &#123;</div><div class="line">   // code to execute</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ES6中Set"><a href="#ES6中Set" class="headerlink" title="ES6中Set"></a>ES6中Set</h2><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let set = new Set();</div><div class="line">set.add(5);</div><div class="line">set.add(&quot;5&quot;);</div><div class="line">console.log(set.size);</div></pre></td></tr></table></figure>
<h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let set = new Set();</div><div class="line">set.add(5);</div><div class="line">set.add(&quot;5&quot;);</div><div class="line">console.log(set.has(5)); // true</div><div class="line">set.delete(5);</div><div class="line">console.log(set.has(5)); // false</div><div class="line">console.log(set.size);   // 1</div><div class="line">set.clear();</div><div class="line">console.log(set.has(&quot;5&quot;));  // false</div><div class="line">console.log(set.size);      // 0</div></pre></td></tr></table></figure>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>需要注意的是回调函数中的前两个参数value与key是一样的；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let set = new Set([1, 2]);</div><div class="line">set.forEach(function(value, key, ownerSet) &#123;</div><div class="line">    console.log(key + &quot; &quot; + value);</div><div class="line">    console.log(ownerSet === set);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="转换为数组"><a href="#转换为数组" class="headerlink" title="转换为数组"></a>转换为数组</h4><p>在前面的迭代器中有讲到可迭代对象可以展开，同样Set可以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let set = new Set([1, 2, 3, 3, 3, 4, 5]),</div><div class="line">    array = [...set];</div><div class="line">console.log(array);  // [1, 2, 3, 4, 5]</div></pre></td></tr></table></figure>
<h4 id="Weak-Set集合"><a href="#Weak-Set集合" class="headerlink" title="Weak Set集合"></a>Weak Set集合</h4><p>为啥要引入Weak Set？先看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let set = new Set(),</div><div class="line">    key = &#123;&#125;;</div><div class="line">set.add(key);</div><div class="line">console.log(set.size);      // 1</div><div class="line">// eliminate original reference</div><div class="line">key = null;</div><div class="line">console.log(set.size);      // 1</div><div class="line">// get the original reference back</div><div class="line">key = [...set][0];</div></pre></td></tr></table></figure>
<p>上面例子将变量key设置null时消除了对初识对象的引用，但是Set集合却保留了这个引用；</p>
<p>有时我们希望当其他所有引用都不再存在时，让Set集合的这些引用随之消失；为了解决这个问题，ES6额外引入了一个类型：Weak Set集合（弱引用Set集合）。</p>
<p>Weak Set集合只存储对象的弱引用，并且不可以存储原始值；集合中的弱引用如果是对象唯一的引用，则会被回收并释放相应内存；</p>
<p>Weak Set支持add has和delete方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let set = new WeakSet(),</div><div class="line">    key = &#123;&#125;;</div><div class="line">// add the object to the set</div><div class="line">set.add(key);</div><div class="line">console.log(set.has(key));</div><div class="line">set.delete(key);</div><div class="line">console.log(set.has(key));</div></pre></td></tr></table></figure>
<p>Weak Set与Set区别：</p>
<ul>
<li>Weak Set实例中，只能含有对象参数；非对象参数会报错</li>
<li>Weak Set不可迭代；</li>
<li>Weak Set不暴露任何迭代器</li>
<li>Weak Set不支持forEach方法</li>
<li>Weak Set不支持size属性</li>
<li><strong>最大区别是Weak Set保存的是对象的弱引用</strong></li>
</ul>
<h2 id="ES6中Map"><a href="#ES6中Map" class="headerlink" title="ES6中Map"></a>ES6中Map</h2><h4 id="支持的方法has-delete-clear"><a href="#支持的方法has-delete-clear" class="headerlink" title="支持的方法has delete clear"></a>支持的方法has delete clear</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">let map = new Map();</div><div class="line">map.set(&quot;name&quot;, &quot;Nicholas&quot;);</div><div class="line">map.set(&quot;age&quot;, 25);</div><div class="line">console.log(map.size); // 2</div><div class="line">console.log(map.has(&quot;name&quot;)); // true</div><div class="line">console.log(map.get(&quot;name&quot;)); // &apos;Nicholas&apos;</div><div class="line">console.log(map.has(&quot;age&quot;)); // true</div><div class="line">console.log(map.get(&quot;age&quot;)); // 25</div><div class="line">map.delete(&quot;name&quot;);</div><div class="line">console.log(map.has(&quot;name&quot;)); // false</div><div class="line">console.log(map.get(&quot;name&quot;)); // undefined</div><div class="line">console.log(map.size); // 1</div><div class="line">map.clear();</div><div class="line">console.log(map.has(&quot;name&quot;)); // false</div><div class="line">console.log(map.get(&quot;name&quot;)); // undefined</div><div class="line">console.log(map.has(&quot;age&quot;)); // false</div><div class="line">console.log(map.get(&quot;age&quot;)); // undefined</div><div class="line">console.log(map.size); // 0</div></pre></td></tr></table></figure>
<h4 id="Map集合初始化"><a href="#Map集合初始化" class="headerlink" title="Map集合初始化"></a>Map集合初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let map = new Map([[&quot;name&quot;, &quot;Nicholas&quot;], [&quot;age&quot;, 25]]);</div><div class="line">console.log(map.has(&quot;name&quot;)); // true</div><div class="line">console.log(map.get(&quot;name&quot;)); // &apos;Nicholas&apos;</div><div class="line">console.log(map.has(&quot;age&quot;)); // true</div><div class="line">console.log(map.get(&quot;age&quot;)); // 25</div><div class="line">console.log(map.size); // 2</div></pre></td></tr></table></figure>
<h4 id="Map集合的forEach"><a href="#Map集合的forEach" class="headerlink" title="Map集合的forEach"></a>Map集合的forEach</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let map = new Map([[&quot;name&quot;, &quot;Nicholas&quot;], [&quot;age&quot;, 25]]);</div><div class="line">map.forEach(function(value, key, ownerMap) &#123;</div><div class="line">    console.log(key + &quot; &quot; + value);</div><div class="line">    console.log(ownerMap === map);</div><div class="line">&#125;);</div><div class="line">// name Nicholas</div><div class="line">// true</div><div class="line">// age 25</div><div class="line">// true</div></pre></td></tr></table></figure>
<h4 id="Weak-Map"><a href="#Weak-Map" class="headerlink" title="Weak Map"></a>Weak Map</h4><p>Weak Map与Map的不同之处和Weak Set与Set的不同类似</p>
<ul>
<li>Weak Map实例中，只能含有对象参数；非对象参数会报错</li>
<li>Weak Map不可迭代；</li>
<li>Weak Map不暴露任何迭代器</li>
<li>Weak Map不支持forEach方法</li>
<li>Weak Map不支持size属性,不支持clear</li>
<li><strong>最大区别是Weak Map保存的是对象的弱引用</strong></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/26/2017-11-26-ES6之迭代器与生成器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/26/2017-11-26-ES6之迭代器与生成器/" itemprop="url">ES6之迭代器与生成器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-26T00:00:00+08:00">
                2017-11-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>之前写过一篇文章关于可迭代对象-<a href="http://cauil.github.io/2017/09/07/2017-09-07-%E8%B0%88%E8%B0%88%E9%81%8D%E5%8E%86%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE/">谈谈遍历与迭代协议</a>， 并讲述了可迭代协议(iterable protocal);</p>
<p>还遗留了一个迭代器协议(iterator)没有讲述，这次我们就来说一说迭代器协议；</p>
<h4 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h4><p>MDN上是这样定义iterator protocal的：</p>
<p>The iterator protocol defines a standard way to produce a sequence of values (either finite or infinite).</p>
<p>An object is an iterator when it implements a next() method with the following semantics:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>next</td>
<td>A zero arguments function that returns an object with two properties:</td>
</tr>
</tbody>
</table>
<ul>
<li>done (boolean)<ul>
<li>Has the value true if the iterator is past the end of the iterated sequence. In this case value optionally specifies the return value of the iterator. The return values are explained here.</li>
<li>Has the value false if the iterator was able to produce the next value in the sequence. This is equivalent of not specifying the done property altogether.</li>
</ul>
</li>
<li>value - any JavaScript value returned by the iterator. Can be omitted when done is true.</li>
</ul>
<p>The next method always has to return an object with appropriate properties including done and value. If a non-object value gets returned (such as false or undefined), a TypeError (“iterator.next() returned a non-object value”) will be thrown. |</p>
<p>其实就是迭代器拥有一个next方法，每次调用返回含有value和done两个属性的对象，value表示下一个将要返回的值；done是一个布尔值，当没有更多返回数据时返回true；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var someArray = [1, 5];</div><div class="line">var someArrayEntries = someArray.entries();</div><div class="line"></div><div class="line">someArrayEntries.toString();   // &quot;[object Array Iterator]&quot;</div><div class="line">someArrayEntries === someArrayEntries[Symbol.iterator](); // true</div><div class="line">someArrayEntries.next(); // &#123;value: Array(2), done: false&#125;</div><div class="line">someArrayEntries.next(); // &#123;value: Array(2), done: false&#125;</div><div class="line">someArrayEntries.next(); // &#123;value: undefined, done: true&#125;</div></pre></td></tr></table></figure>
<p>上个例子中someArray.entries()生成了一个迭代器，每次调用next返回一个对象；当迭代到最后，返回{value: undefined, done: true}；<strong>并且特殊的是someArrayEntries也是一个符合iterable协议的可迭代对象，当调用<code>someArrayEntries[Symbol.iterator])</code>的时候返回一个迭代器对象就是其本身；</strong></p>
<h4 id="迭代器与可迭代对象的联系"><a href="#迭代器与可迭代对象的联系" class="headerlink" title="迭代器与可迭代对象的联系"></a>迭代器与可迭代对象的联系</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iterableObj[Symbol.iterator]() ===&gt; iteratorObj;</div><div class="line">for （let v of iterableObj）&#123;</div><div class="line">  console.log(v);</div><div class="line">&#125;</div><div class="line">iteratorObj.next(); //&#123;value: v, done: false&#125;</div><div class="line">...</div><div class="line">iteratorObj.next(); //&#123;value: undefined, done: true&#125;</div></pre></td></tr></table></figure>
<p>以上介绍生成迭代器的方法还是针对具有Symbol.iterator属性的常见对象（如数组，map等）来的，怎么更通用的生成一个迭代器呢？</p>
<h4 id="内建迭代器"><a href="#内建迭代器" class="headerlink" title="内建迭代器"></a>内建迭代器</h4><p>1.集合对象迭代器</p>
<p>ES6中有三种类型集合对象： 数组、Map集合与Set集合。为了更好的访问对象中的内容，都内建了以下三种迭代器：</p>
<ul>
<li>entries() 返回一个迭代器，其值为多个键值对</li>
<li>values() 返回一个迭代器，其值为集合中的值</li>
<li>keys() 返回一个迭代器，其值为集合中的所有键名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</div><div class="line">for (let entry of colors.entries()) &#123;</div><div class="line">    console.log(entry);</div><div class="line">&#125;</div><div class="line">//[0, &quot;red&quot;]</div><div class="line">//[1, &quot;green&quot;]</div><div class="line">//[2, &quot;blue&quot;]</div><div class="line"></div><div class="line">let tracking = new Set([1234, 5678, 9012]);</div><div class="line">for (let value of tracking.values()) &#123;</div><div class="line">    console.log(value);</div><div class="line">&#125;</div><div class="line">// 1234</div><div class="line">// 5678</div><div class="line">// 9012</div><div class="line"></div><div class="line">let data = new Map();</div><div class="line">for (let key of data.keys()) &#123;</div><div class="line">    console.log(key);</div><div class="line">&#125;</div><div class="line">// &quot;title&quot;</div><div class="line">// &quot;format&quot;</div></pre></td></tr></table></figure>
<p>在for-of循环中，如果没有显式指定则使用默认的迭代器。数组和Set集合的默认迭代器是values()方法，Map默认迭代器是entries方法。</p>
<p>2.字符串迭代器和NodeList迭代器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var message = &quot;A 𠮷 B&quot;;</div><div class="line">for (let c of message) &#123;</div><div class="line">    console.log(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>NodeList迭代器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var divs = document.getElementsByTagName(&quot;div&quot;);</div><div class="line">    for (let div of divs) &#123;</div><div class="line">        console.log(div.id);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>上面的例子中生成迭代器的方法还是针对具有Symbol.iterator属性的常见对象（如数组，map等）来的，怎么更通用的生成一个迭代器呢？</p>
<p>ES6中引入了生成器；生成器是一种返回迭代器的函数，通过function关键字后的*号来表示，函数中会用到新的关键字yield。星号可以紧挨着function关键字，也可以在中间添加一个空格，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function *createIterator() &#123;</div><div class="line">    yield 1;</div><div class="line">    yield 2;</div><div class="line">    yield 3;</div><div class="line">&#125;</div><div class="line">// generators are called like regular functions but return an iterator</div><div class="line">let iterator = createIterator();</div><div class="line">console.log(iterator);              // [object Generator]</div><div class="line">console.log(iterator.next().value); // 1</div><div class="line">console.log(iterator.next().value); // 2</div><div class="line">console.log(iterator.next().value); // 3</div></pre></td></tr></table></figure>
<p>上面的例子createIterator就是一个生成器，生成器执行返回的是一个生成器对象，<strong>生成器对象既是一个迭代器也是一个可迭代对象。</strong></p>
<h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>生成器函数最有趣的部分是：每当执行完一条yield语句后函数就会自动停止执行。</p>
<p>**yield关键字只可以在生成器内部使用，在其他地方使用会导致程序抛出语法错误，即便在生成器内部的函数里使用也是如此：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function *createIterator(items) &#123;</div><div class="line">        items.forEach(function(item) &#123;</div><div class="line">            // syntax error</div><div class="line">            yield item + 1;</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从字面量上看，yield关键字确实在createIterator函数内部，但是它与return关键字一样，二者都不能穿透函数边界。嵌套函数中的return语句不能用做外部函数的返回语句，而此处嵌套函数中的yield语句会导致程序抛出语法错误。</p>
<h4 id="生成器函数表达式"><a href="#生成器函数表达式" class="headerlink" title="生成器函数表达式"></a>生成器函数表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let createIterator = function *(items) &#123;</div><div class="line">    for (let i = 0; i &lt; items.length; i++) &#123;</div><div class="line">        yield items[i];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">let iterator = createIterator([1, 2, 3]);</div><div class="line">console.log(iterator.next()); // &quot;&#123; value: 1, done: false &#125;&quot;</div><div class="line">console.log(iterator.next()); // &quot;&#123; value: 2, done: false &#125;&quot;</div><div class="line">console.log(iterator.next()); // &quot;&#123; value: 3, done: false &#125;&quot;</div><div class="line">console.log(iterator.next()); // &quot;&#123; value: undefined, done: true &#125;&quot;</div></pre></td></tr></table></figure>
<p><strong>不能用箭头函数来创建生成器</strong></p>
<h4 id="生成器对象的方法"><a href="#生成器对象的方法" class="headerlink" title="生成器对象的方法"></a>生成器对象的方法</h4><p>由于生成器对象本身就是函数，因而可以将她们添加到对象中。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let o = &#123;</div><div class="line">    createIterator: function *(items) &#123;</div><div class="line">        for (let i = 0; i &lt; items.length; i++) &#123;</div><div class="line">            yield items[i];</div><div class="line">        &#125;</div><div class="line">&#125; &#125;;</div><div class="line">let iterator = o.createIterator([1, 2, 3]);</div></pre></td></tr></table></figure>
<p>也可以用ES6对象方法的简写方式来创建生成器；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let o = &#123;</div><div class="line">    *createIterator(items) &#123;</div><div class="line">        for (let i = 0; i &lt; items.length; i++) &#123;</div><div class="line">            yield items[i];</div><div class="line">        &#125;</div><div class="line">&#125; &#125;;</div><div class="line">let iterator = o.createIterator([1, 2, 3]);</div></pre></td></tr></table></figure>
<h2 id="高级生成器"><a href="#高级生成器" class="headerlink" title="高级生成器"></a>高级生成器</h2><p>生成器根据需求计算它们的产出值，这使得它们能够有效地表示计算成本高的序列，或者甚至如上所述的无限序列。</p>
<h4 id="给迭代器传递参数"><a href="#给迭代器传递参数" class="headerlink" title="给迭代器传递参数"></a>给迭代器传递参数</h4><p>The next() 方法也接受可用于修改生成器内部状态的值。传递给next()的值将被视为暂停生成器的最后一个yield表达式的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">function* fibonacci() &#123;</div><div class="line">  var fn1 = 0;</div><div class="line">  var fn2 = 1;</div><div class="line">  while (true) &#123;  </div><div class="line">    var current = fn1;</div><div class="line">    fn1 = fn2;</div><div class="line">    fn2 = current + fn1;</div><div class="line">    var reset = yield current;</div><div class="line">    if (reset) &#123;</div><div class="line">        fn1 = 0;</div><div class="line">        fn2 = 1;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var sequence = fibonacci();</div><div class="line">console.log(sequence.next().value);     // 0</div><div class="line">console.log(sequence.next().value);     // 1</div><div class="line">console.log(sequence.next().value);     // 1</div><div class="line">console.log(sequence.next().value);     // 2</div><div class="line">console.log(sequence.next().value);     // 3</div><div class="line">console.log(sequence.next().value);     // 5</div><div class="line">console.log(sequence.next().value);     // 8</div><div class="line">console.log(sequence.next(true).value); // 0</div><div class="line">console.log(sequence.next().value);     // 1</div><div class="line">console.log(sequence.next().value);     // 1</div><div class="line">console.log(sequence.next().value);     // 2</div></pre></td></tr></table></figure>
<h4 id="在迭代器中抛出错误"><a href="#在迭代器中抛出错误" class="headerlink" title="在迭代器中抛出错误"></a>在迭代器中抛出错误</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function *createIterator() &#123;</div><div class="line">    let first = yield 1;</div><div class="line">    let second = yield first + 2;</div><div class="line">    yield second + 3;</div><div class="line">&#125;</div><div class="line">let iterator = createIterator();</div><div class="line">console.log(iterator.next()); // &#123;value: 1, done: false&#125;</div><div class="line">console.log(iterator.next(4)); // &#123;value: 6, done: false&#125;</div><div class="line">console.log(iterator.throw(new Error(&quot;Boom&quot;)));</div></pre></td></tr></table></figure>
<h4 id="生成器返回语句"><a href="#生成器返回语句" class="headerlink" title="生成器返回语句"></a>生成器返回语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function *createIterator() &#123;</div><div class="line">    yield 1;</div><div class="line">    return 42;</div><div class="line">&#125;</div><div class="line">let iterator = createIterator();</div><div class="line">console.log(iterator.next()); // &quot;&#123; value: 1, done: false &#125;&quot;</div><div class="line">console.log(iterator.next()); // &quot;&#123; value: 42, done: true &#125;&quot;</div><div class="line">console.log(iterator.next()); // &quot;&#123; value: undefined, done: true &#125;&quot;</div></pre></td></tr></table></figure>
<p>上面例子中return语句返回一个值，该值被赋值给返回对象的value属性，本来第二条是返回<code>{ value: undefined, done: true }</code>的最终返回<code>{ value: 42, done: true }</code></p>
<h4 id="委托生成器"><a href="#委托生成器" class="headerlink" title="委托生成器"></a>委托生成器</h4><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yield* [[expression]];</div><div class="line">expression</div><div class="line">  返回一个可迭代对象的表达式。</div></pre></td></tr></table></figure>
<p><code>yield*</code> 表达式迭代操作数，并产生它返回的每个值。<code>yield*</code> 表达式本身的值是当迭代器关闭时返回的值（即done为true时）;</p>
<p>1.委托给其他生成器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function* g1() &#123;</div><div class="line">  yield 2;</div><div class="line">  yield 3;</div><div class="line">  yield 4;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function* g2() &#123;</div><div class="line">  yield 1;</div><div class="line">  yield* g1();</div><div class="line">  yield 5;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var iterator = g2();</div><div class="line"></div><div class="line">console.log(iterator.next()); // &#123; value: 1, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: 2, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: 3, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: 4, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: 5, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure>
<p>2.委托给其他可迭代对象</p>
<p>除了生成器对象这一种可迭代对象，yield* 还可以 yield 其它任意的可迭代对象，比如说数组、字符串、arguments 对象等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function* g3() &#123;</div><div class="line">  yield* [1, 2];</div><div class="line">  yield* &quot;34&quot;;</div><div class="line">  yield* arguments;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var iterator = g3(5, 6);</div><div class="line"></div><div class="line">console.log(iterator.next()); // &#123; value: 1, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: 2, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: &quot;3&quot;, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: &quot;4&quot;, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: 5, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: 6, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure>
<p>3.<code>yield*</code> 表达式的值</p>
<p><code>yield*</code> 是一个表达式，不是语句，所以它会有自己的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function* g4() &#123;</div><div class="line">  yield* [1, 2, 3];</div><div class="line">  return &quot;foo&quot;;</div><div class="line">&#125;</div><div class="line">var result;</div><div class="line">function* g5() &#123;</div><div class="line">  result = yield* g4();</div><div class="line">&#125;</div><div class="line">var iterator = g5();</div><div class="line"></div><div class="line">console.log(iterator.next()); // &#123; value: 1, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: 2, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: 3, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: undefined, done: true &#125;, 此时 g4() 返回了 &#123; value: &quot;foo&quot;, done: true &#125;</div><div class="line">console.log(result);          // &quot;foo&quot;</div></pre></td></tr></table></figure>
<p>koa1源码中就有用到委托生成器语法；</p>
<h2 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h2><p>ES6中，所有的集合对象（数组、Set集合、Map集合）和字符串都是可迭代对象，这些对象中都有默认的迭代器；</p>
<p>之前的文章谈过可迭代对象，这里就总结一下：</p>
<h4 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for-of循环"></a>for-of循环</h4><p>可迭代对象可用于for-of循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let values = [1, 2, 3];</div><div class="line">for (let num of values) &#123;</div><div class="line">    console.log(num);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="spread-syntax-…"><a href="#spread-syntax-…" class="headerlink" title="spread syntax (…)"></a>spread syntax (…)</h4><p>可迭代对象可用于…语法：</p>
<p><code>[...&#39;abc&#39;]; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></p>
<h4 id="用于yield"><a href="#用于yield" class="headerlink" title="用于yield *"></a>用于yield *</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function* gen() &#123;</div><div class="line">  yield* [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="用于解构"><a href="#用于解构" class="headerlink" title="用于解构"></a>用于解构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let [a, b, c] = new Set([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/24/2017-11-24-ES6之类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/24/2017-11-24-ES6之类/" itemprop="url">ES6之class</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-24T00:00:00+08:00">
                2017-11-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><p>cheat sheet:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class PersonClass &#123;</div><div class="line">    // equivalent of the PersonType constructor</div><div class="line">    constructor(name) &#123;</div><div class="line">        this.name = name;</div><div class="line">                 &#125;</div><div class="line">    // equivalent of PersonType.prototype.sayName</div><div class="line">    sayName() &#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let person = new PersonClass(&quot;Nicholas&quot;);</div><div class="line">person.sayName();   // outputs &quot;Nicholas&quot;</div><div class="line">console.log(person instanceof PersonClass); // true</div><div class="line">console.log(person instanceof Object);      // true</div><div class="line">console.log(typeof PersonClass);            // function</div><div class="line">console.log(typeof PersonClass.prototype.sayName); // function</div></pre></td></tr></table></figure></p>
<p>类属性不可被赋予新值，在之前的实例中，PersonClass.prototype就是这样一个只可读的类属性；</p>
<h2 id="类语法"><a href="#类语法" class="headerlink" title="类语法"></a>类语法</h2><p>类与ES5类型（new Person）之间有诸多相识之初，但也有差异：</p>
<ol>
<li>函数声明可以被提升，而类声明与let声明类似，不能被提升；真正执行声明语句之前，它们会一直存在于临时死区</li>
<li>类声明中的所有代码将自动运行在严格模式下，而且无法强行让代码脱离严格模式执行；</li>
<li>在自定义类型中，需要通过Object.defineProperty方法手工指定某个方法不可枚举；而在类中，所有方法都是不可枚举的；</li>
<li>每个类都有一个名为[[Construct]]内部方法，通过关键字new调用那些不含有[[Construct]]的方法会导致程序抛出错误；</li>
<li>使用除关键字new以外的方法调用类的构造函数会导致程序抛出错误；</li>
<li>在类中修改类名会导致程序报错；</li>
</ol>
<p>下面是ES5来实现上面例子类PersonClass的等价代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">let PersonType2 = (function() &#123; // 1 临时死区</div><div class="line">  &apos;use strict&apos;; // 2 严格模式</div><div class="line">  </div><div class="line">  const PersonType2 = function(name) &#123; // 6 内部类名不可修改</div><div class="line">    if(typeof new.target === &apos;undefined&apos;) &#123; // 5 只能使用new</div><div class="line">      throw new Error(&apos;必须通过关键字new来调用构造函数&apos;);</div><div class="line">    &#125;</div><div class="line">    this.name = name;</div><div class="line">  &#125;</div><div class="line">  Object.defineProperty(PersonType2.prototype, sayName, &#123;</div><div class="line">    value: function() &#123;</div><div class="line">      if(typeof new.target !== &apos;undefined&apos;) &#123; // 4 不能使用new</div><div class="line">        throw Error(&apos;不能使用关键字new来调用该方法&apos;);</div><div class="line">      &#125;</div><div class="line">      console.log(this.name);</div><div class="line">    &#125;,</div><div class="line">    enumerable: false,// 3 不可枚举</div><div class="line">    writable: true,</div><div class="line">    configurable: true,</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line">  return Persontype2;</div><div class="line">&#125;())</div></pre></td></tr></table></figure>
<p>上述1和6可以看下面这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Foo &#123;</div><div class="line">   constructor() &#123;</div><div class="line">Foo = &quot;bar&quot;;// throws an error when executed...</div><div class="line">&#125; &#125;</div><div class="line">// but this is okay after the class declaration</div><div class="line">Foo = &quot;baz&quot;;</div></pre></td></tr></table></figure></p>
<h2 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h2><h4 id="声明表达式"><a href="#声明表达式" class="headerlink" title="声明表达式"></a>声明表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let PersonClass = class &#123;</div><div class="line"> ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="命名表达式"><a href="#命名表达式" class="headerlink" title="命名表达式"></a>命名表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let PersonClass = class PersonClass2 &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在JS引擎中，类表达式的实现与类声明稍有不同。对于类声明来说，通过let定义的外部绑定与通过const定义的内部绑定具有相同的名称；而命名表达式通过const定义名称，从而PersonClass2只能在类的内部使用；</p>
<h2 id="一等公民的类"><a href="#一等公民的类" class="headerlink" title="一等公民的类"></a>一等公民的类</h2><p>在程序中，一等公民是指一个可以传入函数，可以从函数返回，并且可以复制给变量的值。JS函数是一等公民，ES6中把类也设计为一等公民。</p>
<p>作为参数传入函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function createObject(classDef) &#123;</div><div class="line">  return new classDef();</div><div class="line">&#125;</div><div class="line"></div><div class="line">let obj = createObject(class &#123;...&#125;);</div></pre></td></tr></table></figure>
<p>立即调用类构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let person = new class &#123;</div><div class="line">  ...</div><div class="line">&#125;(&apos;Hi&apos;);</div></pre></td></tr></table></figure></p>
<h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><p>类也支持直接在原型上定义访问器属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class CustomHTMLElement &#123;</div><div class="line">    constructor(element) &#123;</div><div class="line">        this.element = element;</div><div class="line">&#125;</div><div class="line">    get html() &#123;</div><div class="line">        return this.element.innerHTML;</div><div class="line">&#125;</div><div class="line">    set html(value) &#123;</div><div class="line">        this.element.innerHTML = value;</div><div class="line">&#125; &#125;</div><div class="line">var descriptor = Object.getOwnPropertyDescriptor(CustomHTMLElement.prototype, &quot;html&quot;);</div><div class="line">console.log(&quot;get&quot; in descriptor);</div><div class="line">console.log(&quot;set&quot; in descriptor);</div><div class="line">console.log(descriptor.enumerable);</div><div class="line">// true</div><div class="line">// true</div><div class="line">// false</div></pre></td></tr></table></figure></p>
<h2 id="可计算成员名称"><a href="#可计算成员名称" class="headerlink" title="可计算成员名称"></a>可计算成员名称</h2><p>类方法和访问器属性也支持使用可计算名称；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let methodName = &quot;sayName&quot;;</div><div class="line">class PersonClass &#123;</div><div class="line">    constructor(name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    [methodName]() &#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125; </div><div class="line">&#125;;</div><div class="line">let me = new PersonClass(&quot;Nicholas&quot;);</div><div class="line">me.sayName();           // &quot;Nicholas&quot;</div></pre></td></tr></table></figure></p>
<h2 id="生成器方法"><a href="#生成器方法" class="headerlink" title="生成器方法"></a>生成器方法</h2><p>在类中可以在方法名称前附加一个星号来定义生成器；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">    *createIterator() &#123;</div><div class="line">        yield 1;</div><div class="line">        yield 2;</div><div class="line">        yield 3;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let instance = new MyClass();</div><div class="line">let iterator = instance.createIterator();</div></pre></td></tr></table></figure>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>ES6中类简化了创建静态成员的工程，在方法或访问器属性前面使用正式的静态注释即可；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class PersonClass &#123;</div><div class="line">  constructor() &#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125;  </div><div class="line">  static create() &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不可在实例中访问静态成员，必须要直接在类中访问静态成员</p>
<h2 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h2><p>ES6中使用extends关键字可以创造继承类；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Rectangle &#123;</div><div class="line">    constructor(length, width) &#123;</div><div class="line">        this.length = length;</div><div class="line">        this.width = width;</div><div class="line">    &#125;</div><div class="line">    getArea() &#123;</div><div class="line">        return this.length * this.width;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Square extends Rectangle &#123;</div><div class="line">    constructor(length) &#123;</div><div class="line">        // equivalent of Rectangle.call(this, length, length)</div><div class="line">        super(length, length);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var square = new Square(3);</div><div class="line">console.log(square.getArea());// 9</div><div class="line">console.log(square instanceof Square);// true</div><div class="line">console.log(square instanceof Rectangle);// true</div></pre></td></tr></table></figure>
<p>上述代码创造了一个Square继承Rectangle类；Square被称为派生类；注意：<strong>如果在派生类中指定了构造函数则必须要调用super，如果不这样做程序就会报错；如果不使用构造函数，则当创建新的类实例时会自动调用super并传入所有参数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Square extends Rectangle &#123;</div><div class="line">    // no constructor</div><div class="line">&#125;</div><div class="line">// is equivalent to</div><div class="line">class Square extends Rectangle &#123;</div><div class="line">    constructor(...args) &#123;</div><div class="line">        super(...args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用super要注意：</p>
<ul>
<li>只可在派生类的构造函数中使用super(),如果尝试在非派生类或者函数中使用会抛出错误</li>
<li>在构造函数中访问this前一定要调用super，它负责初试化this，如果在调用super之前尝试访问this会报错</li>
<li>如果不想调用super()，则唯一的方法是让类的构造函数返回一个对象</li>
</ul>
<h4 id="类方法遮蔽"><a href="#类方法遮蔽" class="headerlink" title="类方法遮蔽"></a>类方法遮蔽</h4><p>派生类如果跟父类有同名函数，派生类的方法会覆盖父类的同名方法；如果想在派生类中调用父类的方法，可以<code>super.funcName()</code>这样来调用；</p>
<h4 id="静态成员继承"><a href="#静态成员继承" class="headerlink" title="静态成员继承"></a>静态成员继承</h4><p>如果基类有静态成员，那么这些静态成员在派生类中也可调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Rectangle &#123;</div><div class="line">    constructor(length, width) &#123;</div><div class="line">        this.length = length;</div><div class="line">        this.width = width;</div><div class="line">    &#125;</div><div class="line">    getArea() &#123;</div><div class="line">        return this.length * this.width;</div><div class="line">&#125;</div><div class="line">    static create(length, width) &#123;</div><div class="line">        return new Rectangle(length, width);</div><div class="line">&#125; &#125;</div><div class="line">class Square extends Rectangle &#123;</div><div class="line">    constructor(length) &#123;</div><div class="line">        // equivalent of Rectangle.call(this, length, length)</div><div class="line">         super(length, length);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var rect = Square.create(3, 4);</div><div class="line">console.log(rect instanceof Rectangle); // true</div><div class="line">console.log(rect.getArea());            // 12</div><div class="line">console.log(rect instanceof Square);    // false</div></pre></td></tr></table></figure></p>
<p>新的静态方法create被添加到Rectangle中，继承后的Square.create()与Rectangle.create()行为类似；</p>
<h4 id="派生自表达式的类"><a href="#派生自表达式的类" class="headerlink" title="派生自表达式的类"></a>派生自表达式的类</h4><p>ES6最强大的一面或许是从表达式导出类的功能了；只要表达式可以被解析为一个函数并且具有[[Construct]]属性和原型，那么就可以用extends进行派生；<strong>extends强大的功能使得类可以继承自任意类型的表达式，从而可以创造更多可能性</strong>，例如动态的确定类的继承目标：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">let SerializableMixin = &#123;</div><div class="line">    serialize() &#123;</div><div class="line">        return JSON.stringify(this);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">let AreaMixin = &#123;</div><div class="line">    getArea() &#123;</div><div class="line">        return this.length * this.width;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">function mixin(...mixins) &#123;</div><div class="line">    var base = function() &#123;&#125;;</div><div class="line">    Object.assign(base.prototype, ...mixins);</div><div class="line">    return base;</div><div class="line">&#125;</div><div class="line">class Square extends mixin(AreaMixin, SerializableMixin) &#123;</div><div class="line">    constructor(length) &#123;</div><div class="line">         super();</div><div class="line">        this.length = length;</div><div class="line">        this.width = length;</div><div class="line">&#125; &#125;</div><div class="line">var x = new Square(3);</div><div class="line">console.log(x.getArea());   // 9</div><div class="line">console.log(x.serialize()); // &quot;&#123;&quot;length&quot;:3,&quot;width&quot;:3&#125;&quot;</div></pre></td></tr></table></figure>
<h4 id="内建对象的继承"><a href="#内建对象的继承" class="headerlink" title="内建对象的继承"></a>内建对象的继承</h4><p>在ES6之前，几乎不可能通过继承方式创建属于自己的数组，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var colors = [];</div><div class="line">colors[0] = &quot;red&quot;;</div><div class="line">console.log(colors.length); // 1</div><div class="line">colors.length = 0;</div><div class="line">console.log(colors[0]);     // undefined</div><div class="line"></div><div class="line">// trying to inherit from array in ES5</div><div class="line">function MyArray() &#123;</div><div class="line">    Array.apply(this, arguments);</div><div class="line">&#125;</div><div class="line">MyArray.prototype = Object.create(Array.prototype, &#123;</div><div class="line">    constructor: &#123;</div><div class="line">        value: MyArray,</div><div class="line">        writable: true,</div><div class="line">        configurable: true,</div><div class="line">        enumerable: true</div><div class="line">&#125; &#125;);</div><div class="line">var colors = new MyArray();</div><div class="line">colors[0] = &quot;red&quot;;</div><div class="line">console.log(colors.length); // 0</div><div class="line">colors.length = 0;</div><div class="line">console.log(colors[0])      // red</div></pre></td></tr></table></figure>
<p>通过上面的代码，可以看出MyArray的行为与内建数组行为不一致；</p>
<p>ES6中可以通过extends来创建自定义数组；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class MyArray extends Array &#123;</div><div class="line">    // empty</div><div class="line">&#125;</div><div class="line">var colors = new MyArray();</div><div class="line">colors[0] = &quot;red&quot;;</div><div class="line">console.log(colors.length); // 1</div><div class="line">colors.length = 0;</div><div class="line">console.log(colors[0]);     // undefined</div></pre></td></tr></table></figure></p>
<h2 id="在类的构造函数中使用new-target"><a href="#在类的构造函数中使用new-target" class="headerlink" title="在类的构造函数中使用new.target"></a>在类的构造函数中使用new.target</h2><p>类中new.targe一般就等于类本身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Rectangle &#123;</div><div class="line">    constructor(length, width) &#123;</div><div class="line">        console.log(new.target === Rectangle);</div><div class="line">        this.length = length;</div><div class="line">        this.width = width;</div><div class="line"> &#125; &#125;</div><div class="line">// new.target is Rectangle</div><div class="line">var obj = new Rectangle(3, 4); // outputs true</div></pre></td></tr></table></figure>
<p>但有时其值会不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Rectangle &#123;</div><div class="line">    constructor(length, width) &#123;</div><div class="line">        console.log(new.target === Rectangle);</div><div class="line">        this.length = length;</div><div class="line">        this.width = width;</div><div class="line">&#125; &#125;</div><div class="line">class Square extends Rectangle &#123;</div><div class="line">    constructor(length) &#123;</div><div class="line">         super(length, length)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// new.target is Square</div><div class="line">var obj = new Square(3); // outputs false</div></pre></td></tr></table></figure>
<p>Square调用Rectangle的构造函数，所以当调用发生时new.target等于Square;每个构造函数都可以根据自身被调用的方式改变自己的行为；例如构造一个抽象基类；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Shape &#123;</div><div class="line">    constructor() &#123;</div><div class="line">        if (new.target === Shape) &#123;</div><div class="line">            throw new Error(&quot;This class cannot be instantiated directly.&quot;)</div><div class="line">        &#125;</div><div class="line"> &#125; &#125;</div><div class="line">class Rectangle extends Shape &#123;</div><div class="line">    constructor(length, width) &#123;</div><div class="line">        super();</div><div class="line">        this.length = length;</div><div class="line">        this.width = width;</div><div class="line">&#125; &#125;</div><div class="line">var x = new Shape(); // throws an error</div><div class="line">var y = new Rectangle(3, 4); // no error</div><div class="line">console.log(y instanceof Shape); // true</div></pre></td></tr></table></figure>
<p>上例子中抽象基类Shape不能直接被实例化，只能通过派生的类来继承；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/22/2017-11-22-ES6之Symbol/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/22/2017-11-22-ES6之Symbol/" itemprop="url">ES6之Symbol</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T00:00:00+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ES6引入了第6种原始类型：Symbol。起初，人们用它来创建对象的私有成员；在Symbol出现之前，人们一直通过属性名来访问所有属性，无论属性名由什么元素构成，全部通过一个字符串类型的名称来访问。</p>
<p>私有名称原本是为了让开发者<strong>创建非字符串属性名称而设计</strong>的，但是<strong>一般的技术无法检测这些属性的私有名称</strong>。</p>
<h2 id="创建Symbol"><a href="#创建Symbol" class="headerlink" title="创建Symbol"></a>创建Symbol</h2><p>可以通过全局的Symbol函数创建一个Symbol：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let firstName = Symbol();</div><div class="line">let person = &#123;&#125;;</div><div class="line">person[firstName] = &quot;Nicholas&quot;;</div><div class="line">console.log(person[firstName]);</div></pre></td></tr></table></figure>
<p>由于Symbol是原始值，因此调用new Symbol()会导致程序抛出错误。</p>
<p>Symbol接受一个可选参数，其可以添加一段文本描述即将创建的Symbol，这段描述不可以用作属性访问，只是为了便于阅读和调试Symbol程序；symbol的描述被存储在内部的[[Description]]属性中，只有当调用Symbol的toString()方法时才可以读取这个属性；</p>
<p>检测一个Symbol：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let name = Symbol(&apos;hi&apos;);</div><div class="line">console.log(typeof name); // symbol</div></pre></td></tr></table></figure></p>
<h2 id="Symbol的使用方法"><a href="#Symbol的使用方法" class="headerlink" title="Symbol的使用方法"></a>Symbol的使用方法</h2><p><strong>所有使用可计算属性名的地方，都可以使用Symbol</strong>。如Object.defineProperty等:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let firstName = Symbol(&quot;first name&quot;);</div><div class="line">// use a computed object literal property</div><div class="line">let person = &#123;</div><div class="line">    [firstName]: &quot;Nicholas&quot;</div><div class="line">&#125;;</div><div class="line">// make the property read only</div><div class="line">Object.defineProperty(person, firstName, &#123; writable: false &#125;);</div><div class="line">let lastName = Symbol(&quot;last name&quot;);</div><div class="line">Object.defineProperties(person, &#123;</div><div class="line">    [lastName]: &#123;</div><div class="line">        value: &quot;Zakas&quot;,</div><div class="line">        writable: false</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="Symbol共享体系"><a href="#Symbol共享体系" class="headerlink" title="Symbol共享体系"></a>Symbol共享体系</h2><p>在不同的代码中共享同一个Symbol，ES6提供了一个可以随时访问的全局Symbol注册表；如果要创建一个共享的Symbol，要使用Symbol.for方法，它只接受一个参数，也就是即将创建的Symbol的字符串标示，这个参数同样也被用作Symbol的描述；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let uid = Symbol.for(&quot;uid&quot;);</div><div class="line">let object = &#123;&#125;;</div><div class="line">object[uid] = &quot;12345&quot;;</div><div class="line">console.log(object[uid]); // &apos;12345&apos;</div><div class="line">console.log(uid);         // &apos;Symbol(uid)&apos;</div></pre></td></tr></table></figure>
<p>Symbol.for首先在全局Symbol注册表中搜索键为’uid’的Symbol，如果存在，直接返回已存在的，否则创建一个新的Symbol，并使用这个键在Symbol全局注册表中注册，随机返回新创建的Symbol。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let uid = Symbol.for(&quot;uid&quot;);</div><div class="line">let uid2 = Symbol.for(&quot;uid&quot;);</div><div class="line">console.log(uid === uid2); // true</div><div class="line">console.log(uid2);         // &apos;Symbol(uid)&apos;</div></pre></td></tr></table></figure>
<p>还有一个与Symbol共享有关的特性，Symbol.keyFor方法在Symbol全局注册表中检索与Symbol有关的键；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let uid = Symbol.for(&quot;uid&quot;);</div><div class="line">console.log(Symbol.keyFor(uid)); // uid</div><div class="line">let uid2 = Symbol.for(&quot;uid&quot;);</div><div class="line">console.log(Symbol.keyFor(uid2));// uid</div><div class="line">let uid3 = Symbol(&quot;uid&quot;);</div><div class="line">console.log(Symbol.keyFor(uid3));// undefined</div></pre></td></tr></table></figure>
<p>Symbol全局注册表中不存在uid3这个Symbol(没有通过Symbol.for注册)，返回undefined；</p>
<h2 id="Symbol与类型强制转换"><a href="#Symbol与类型强制转换" class="headerlink" title="Symbol与类型强制转换"></a>Symbol与类型强制转换</h2><p>不能将Symbol强制转换为字符串和数字类型；Symbol在需要逻辑判断表达式中为真；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var uid = Symbol.for(&quot;uid&quot;),</div><div class="line">          desc = uid + &quot;&quot;;  // Cannot convert a Symbol value to a string</div><div class="line">var sum = uid / 1; // Cannot convert a Symbol value to a number</div><div class="line">!!uid; // true</div></pre></td></tr></table></figure>
<h2 id="Symbol属性检索"><a href="#Symbol属性检索" class="headerlink" title="Symbol属性检索"></a>Symbol属性检索</h2><p>Object.keys和Object.getOwnpropertyNames不能检索出Symbol属性，ES6中Object.getOwnpropertySymbols来支持这个功能，返回对象中的所有Symbol属性的数组；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let uid = Symbol.for(&quot;uid&quot;);</div><div class="line">let object = &#123;</div><div class="line">    [uid]: &quot;12345&quot;</div><div class="line">&#125;;</div><div class="line">let symbols = Object.getOwnPropertySymbols(object);</div><div class="line">console.log(symbols.length); // 1</div><div class="line">console.log(symbols[0]);     // &apos;Symbol(uid)&apos;</div><div class="line">console.log(object[symbols[0]]);// &apos;12345&apos;</div></pre></td></tr></table></figure>
<h2 id="通过well-known-Symbol暴露内部操作"><a href="#通过well-known-Symbol暴露内部操作" class="headerlink" title="通过well-known Symbol暴露内部操作"></a>通过well-known Symbol暴露内部操作</h2><p>ES6通过在原型链上定义与Symbol相关的属性来暴露更多的语言内部逻辑；开放了以前JS中常见的内部操作，并通过预定义一些well-known Symbol来表示。每一个这类Symbol都是symbol对象的一个属性，例如Symbol.match</p>
<h4 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h4><p>一个在执行instanceof时调用的内部方法，用于检测对象的继承信息；</p>
<p>Function.prototype中有一个Symbol.hasInstance方法，每一个函数都继承了这个方法，用于确定对象是否是函数的实例。该方法被定义为不可写，不可配置并且不可枚举。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertyDescriptor(Function.prototype, Symbol.hasInstance); // &#123;writable: false, enumerable: false, configurable: false, value: ƒ&#125;</div></pre></td></tr></table></figure>
<p>看一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Array.hasOwnProperty(Symbol.hasInstance);              // false</div><div class="line">Function.prototype.hasOwnProperty(Symbol.hasInstance); // true</div><div class="line">Array instanceof Function;                             // true</div></pre></td></tr></table></figure></p>
<p>从上面可以看出Array是Function的实例；Function.prototype具有自有属性Symbol.hasInstance，Array没有Symbol.hasInstance;</p>
<p><code>obj instanceof Array</code>实际等价于<code>Array[Symbol.hasInstance](obj)</code>，由于Array没有<code>Symbol.hasInstance</code>，所以会从原型链中寻找，最终在<code>Function.prototype</code>中找到，最终实际执行的就是<code>Function.prototype[Symbol.hasInstance](obj)</code>。</p>
<p>明白了instanceof的实际调用过程，就可以按我们的意愿来定制一些内容，例如定义一个无实例的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function MyObject() &#123;</div><div class="line">    // empty</div><div class="line">&#125;</div><div class="line">Object.defineProperty(MyObject, Symbol.hasInstance, &#123;</div><div class="line">    value: function(v) &#123;</div><div class="line">             return false;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">let obj = new MyObject();</div><div class="line">console.log(obj instanceof MyObject); // false</div></pre></td></tr></table></figure>
<h4 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h4><p>concat元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let colors1 = [ &quot;red&quot;, &quot;green&quot; ],</div><div class="line">    colors2 = colors1.concat([ &quot;blue&quot;, &quot;black&quot; ]);</div><div class="line">console.log(colors2.length);    // 4</div><div class="line">console.log(colors2); [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;black&quot;]</div></pre></td></tr></table></figure></p>
<p>concat数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let colors1 = [ &quot;red&quot;, &quot;green&quot; ],</div><div class="line">    colors2 = colors1.concat([ &quot;blue&quot;, &quot;black&quot; ], &quot;brown&quot;);</div><div class="line">console.log(colors2.length);    // 5</div><div class="line">console.log(colors2);           // [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;black&quot;,&quot;brown&quot;]</div></pre></td></tr></table></figure></p>
<p>JS规范声明，concat凡是传入了数组参数，就会自动将它们分解成独立元素，在ES6之前，我们根本无法调整这个特性；</p>
<p>Symbol.isConcatSpreadable属性是一个布尔值，如果该属性为true，则表示对象由length属性和数字键，故它的数值型属性应该被独立添加到cancat()调用结果中；与其他well-known Symbol属性不同的是，这个Symbol属性默认情况下不会出现标准对象，它只是一个可选对象，用于增强作用于特定对象类型的concat()方法的功能，有效简化其默认特性；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">let collection = &#123;</div><div class="line">    0: &quot;Hello&quot;,</div><div class="line">    1: &quot;world&quot;,</div><div class="line">    length: 2,</div><div class="line">    [Symbol.isConcatSpreadable]: true</div><div class="line">&#125;;</div><div class="line">let messages = [ &quot;Hi&quot; ].concat(collection);</div><div class="line">console.log(messages.length);    // 3</div><div class="line">console.log(messages);           // [&quot;Hi&quot;,&quot;Hello&quot;,&quot;world&quot;]</div><div class="line"></div><div class="line">let collection1 = &#123;</div><div class="line">    0: &quot;Hello&quot;,</div><div class="line">    1: &quot;world&quot;,</div><div class="line">    length: 2,</div><div class="line">    [Symbol.isConcatSpreadable]: true</div><div class="line">&#125;;</div><div class="line">let messages = [ &quot;Hi&quot; ].concat(collection1);</div><div class="line">console.log(messages.length);    // 2</div><div class="line">console.log(messages);           // [&quot;Hi&quot;,&#123;...&#125;]</div></pre></td></tr></table></figure>
<h4 id="Symbol-match-Symbol-replace-Symbol-search-Symbol-split"><a href="#Symbol-match-Symbol-replace-Symbol-search-Symbol-split" class="headerlink" title="Symbol.match Symbol.replace Symbol.search Symbol.split"></a>Symbol.match Symbol.replace Symbol.search Symbol.split</h4><p>这四个Symbol用在String对应的四个方法String.match/replace/search/split中且当参数为正则表达式时。</p>
<p>可以定义一个对象的这四个Symbol属性方法，这对象就可以代替正则表达式来应用在上面的对应场景中；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">// effectively equivalent to /^.&#123;10&#125;$/ </div><div class="line">let hasLengthOf10 = &#123;</div><div class="line">  [Symbol.match]: function(value) &#123;</div><div class="line">    return value.length === 10 ? [value.substring(0, 10)] : null;</div><div class="line">  &#125;,</div><div class="line">  [Symbol.replace]: function(value, replacement) &#123;</div><div class="line">    return value.length === 10 ? replacement + value.substring(10) : value;</div><div class="line">  &#125;,</div><div class="line">  [Symbol.search]: function(value) &#123;</div><div class="line">    return value.length === 10 ? 0 : -1;</div><div class="line">  &#125;,</div><div class="line">  [Symbol.split]: function(value) &#123;</div><div class="line">    return value.length === 10 ? [&quot;&quot;, &quot;&quot;] : [value];</div><div class="line">  &#125; </div><div class="line">&#125;;</div><div class="line"></div><div class="line">let message1 = &quot;Hello world&quot;, // 11 characters </div><div class="line">message2 = &quot;Hello John&quot;; // 10 characters</div><div class="line">let match1 = message1.match(hasLengthOf10), </div><div class="line">match2 = message2.match(hasLengthOf10);</div><div class="line">console.log(match1); // null </div><div class="line">console.log(match2); // [&quot;Hello John&quot;]</div><div class="line">let replace1 = message1.replace(hasLengthOf10), </div><div class="line">replace2 = message2.replace(hasLengthOf10);</div><div class="line">console.log(replace1); // &quot;Hello world&quot; </div><div class="line">console.log(replace2); // &quot;Hello John&quot;</div><div class="line">let search1 = message1.search(hasLengthOf10), </div><div class="line">search2 = message2.search(hasLengthOf10);</div><div class="line">console.log(search1); // -1 </div><div class="line">console.log(search2); // 0</div><div class="line">let split1 = message1.split(hasLengthOf10), </div><div class="line">split2 = message2.split(hasLengthOf10);</div><div class="line">console.log(split1); // [&quot;Hello world&quot;] </div><div class="line">console.log(split2); // [&quot;&quot;, &quot;&quot;]</div></pre></td></tr></table></figure>
<h4 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h4><p>JS引擎中，经常会尝试将对象转换到相应的原始值，例如比较一个对象与字符串；对象被转换为原始值，会有三种选择：数字，字符串或无类型偏好的值。对于大多数标准对象，当对象被转换为数字时：</p>
<ol>
<li>调用valueOf方法，如果结果为原始值，则返回</li>
<li>否则，调用toString方法，如果结果值为原始值，则返回</li>
<li>如果再无可选值，则抛出异常</li>
</ol>
<p>当对象被转换为字符串时：</p>
<ol>
<li>调用toSring方法，如果结果为原始值，则返回</li>
<li>否则，调用valueOf方法，如果结果值为原始值，则返回</li>
<li>如果再无可选值，则抛出异常</li>
</ol>
<p><strong>大多数情况下，标准对象会将默认模式按数字模式处理（除了Date对象）；默认模式只用于==运算，+运算及给Date构造函数传递一个参数时。</strong></p>
<p>在ES6标准中，通过Symbol.toPrimitive方法可以更改那个暴露出来的原始值；Symbol.toPrimitive被定义在每一个标准类型的原型上，并且规定了当对象被转换为原始值时应该执行的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Temperature(degrees) &#123;</div><div class="line">              this.degrees = degrees;</div><div class="line">&#125;</div><div class="line">Temperature.prototype[Symbol.toPrimitive] = function(hint) &#123;</div><div class="line">switch (hint) &#123;</div><div class="line">    case &quot;string&quot;:</div><div class="line">        return this.degrees + &quot;\u00b0&quot;; // degrees symbol</div><div class="line">    case &quot;number&quot;:</div><div class="line">        return this.degrees;</div><div class="line">    case &quot;default&quot;:</div><div class="line">        return this.degrees + &quot; degrees&quot;;</div><div class="line">&#125; &#125;;</div><div class="line">var freezing = new Temperature(32);</div><div class="line">console.log(freezing + &quot;!&quot;);    // &quot;32 degrees!&quot;</div><div class="line">console.log(freezing / 2);      // 16</div><div class="line">console.log(String(freezing));  // &quot;32°&quot;</div></pre></td></tr></table></figure>
<h4 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h4><p>当检测一个数据的类型时，可能会用instanceof,这样在使用iframe标签情况下会有一定问题，不同的iframe代表不同的领域，不同领域的构造函数是不同的，当数据传递到不同的领域时，使用instanceof会得不到预期的结果；</p>
<p>这时我们可能会用Object.prototype.toString.call来处理；</p>
<p>如区分原生JSON对象和自建对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function supportsNativeJSON() &#123;</div><div class="line">    return typeof JSON !== &quot;undefined&quot; &amp;&amp;</div><div class="line">        Object.prototype.toString.call(JSON) === &quot;[object JSON]&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在ES6中重新定义了原生对象过去的状态，通过Symbol.toStringTag改变了调用Object.prototype.toString方法时返回的身份标示；这个Symbol所代表的属性在每一个对象中都存在，其定义了调用对象的Object.prototype.toString.call方法时返回的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line">Person.prototype[Symbol.toStringTag] = &quot;Person&quot;;</div><div class="line">var me = new Person(&quot;Nicholas&quot;);</div><div class="line">console.log(me.toString());                     // [object Person]</div><div class="line">console.log(Object.prototype.toString.call(me)); // [object Person]</div></pre></td></tr></table></figure>
<h4 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h4><p>The Symbol.unscopables well-known symbol is used to specify an object value of whose own and inherited property names are excluded from the with environment bindings of the associated object.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var keys = [];</div><div class="line"></div><div class="line">with (Array.prototype) &#123;</div><div class="line">  keys.push(&apos;something&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Object.keys(Array.prototype[Symbol.unscopables]); </div><div class="line">// [&quot;copyWithin&quot;, &quot;entries&quot;, &quot;fill&quot;, &quot;find&quot;, &quot;findIndex&quot;, &quot;includes&quot;, &quot;keys&quot;, &quot;values&quot;]</div></pre></td></tr></table></figure>
<p>也可以改变对象的Symbol.unscopables属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var obj = &#123; </div><div class="line">  foo: 1, </div><div class="line">  bar: 2 </div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj[Symbol.unscopables] = &#123; </div><div class="line">  foo: false, </div><div class="line">  bar: true </div><div class="line">&#125;;</div><div class="line"></div><div class="line">with (obj) &#123;</div><div class="line">  console.log(foo); // 1</div><div class="line">  console.log(bar); // ReferenceError: bar is not defined</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/21/2017-11-21-ES6之解构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/21/2017-11-21-ES6之解构/" itemprop="url">ES6之解构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-21T00:00:00+08:00">
                2017-11-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为何使用解构功能"><a href="#为何使用解构功能" class="headerlink" title="为何使用解构功能"></a>为何使用解构功能</h2><p>在编码过程中，我们经常定义许多对象和数组，然后有组织地从中提取相关的信息片段；如果对象跟数组结构复杂，我们就需要深入挖掘整个数据结构才能找到所需数据。</p>
<p>所以ES6位对象与数组都添加了结构功能，将数据结构打散的过程变得更加简单；许多语言都通过极少量的语法实现了结构功能，以简化获取信息的过程；而ES6实际上利用了你早已熟悉的语法：对象和数组字面量的语法。</p>
<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>对象解构的语法形式是在一个赋值操作符左边放置一个对象字面量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;foo&quot;</div><div class="line">&#125;;</div><div class="line">let &#123; type, name &#125; = node;</div><div class="line">console.log(type);      // &quot;Identifier&quot;</div><div class="line">console.log(name);      // &quot;foo&quot;</div></pre></td></tr></table></figure>
<p>使用var let或const解构声明变量，必须要提供初始化程序。下面几行代码全部都会导致抛出语法错误，它们都缺少了初始化程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// syntax error!</div><div class="line">var &#123; type, name &#125;;</div><div class="line">// syntax error!</div><div class="line">let &#123; type, name &#125;;</div><div class="line">// syntax error!</div><div class="line">const &#123; type, name &#125;;</div></pre></td></tr></table></figure>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>如果在定义变量之后想要修改它们的值，需要用小括号包裹解构赋值语句，因为JS引擎将一对开放的花括号视为一个代码块，而语法规定，代码块语句不允许出现在赋值语句左侧，添加小括号后可以将块语句转化为一个表达式，从而实现解构赋值的过程。如下面的<code>({ type, name } = node)</code>语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;foo&quot;</div><div class="line">&#125;,</div><div class="line">type = &quot;Literal&quot;,</div><div class="line">name = 5;</div><div class="line">// assign different values using destructuring</div><div class="line">(&#123; type, name &#125; = node);</div><div class="line">console.log(type);      // &quot;Identifier&quot;</div><div class="line">console.log(name);</div></pre></td></tr></table></figure>
<p>解构赋值表达式（=号右侧）如果为null或者undefined会导致程序抛出错误；<code>let {hello} = null</code>会抛出错误<code>Cannot destructure property</code>hello<code>of &#39;undefined&#39; or &#39;null&#39;.</code></p>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>当指定的局部变量名称在对象中不存在的时候，会被赋值为undefined，我们可以设置一个默认值，来处理这种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;foo&quot;</div><div class="line">&#125;;</div><div class="line">let &#123; type, name, value = true &#125; = node;</div><div class="line">console.log(type); // &quot;Identifier&quot;</div><div class="line">console.log(name); // &quot;foo&quot;</div><div class="line">console.log(value);// true</div></pre></td></tr></table></figure>
<h4 id="为非同名局部变量赋值"><a href="#为非同名局部变量赋值" class="headerlink" title="为非同名局部变量赋值"></a>为非同名局部变量赋值</h4><p>也可以使用非同名的局部变量来解构对象，并且可以指定默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;foo&quot;</div><div class="line">&#125;;</div><div class="line">let &#123; type: localType, name: localName, first_name: firstName=&apos;hi&apos; &#125; = node;</div><div class="line">console.log(localType);     // &quot;Identifier&quot;</div><div class="line">console.log(localName);     // &quot;foo&quot;</div><div class="line">console.log(firstName);     // &quot;hi&quot;</div></pre></td></tr></table></figure>
<h4 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;foo&quot;,</div><div class="line">    loc: &#123;</div><div class="line">        start: &#123;</div><div class="line">            line: 1,</div><div class="line">column: 1 &#125;,</div><div class="line">        end: &#123;</div><div class="line">            line: 1,</div><div class="line">column: 4 &#125;</div><div class="line">&#125; &#125;;</div><div class="line">let &#123; loc: &#123; start &#125;&#125; = node;</div><div class="line">console.log(start.line);   // 1</div><div class="line">console.log(start.column); // 1</div></pre></td></tr></table></figure>
<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>数组解构语法比对象解构更简单，使用的是数组字面量，且解构操作全部在数组内完成，而不是像对象字面量语法一样使用对象的命名属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</div><div class="line">let [ firstColor, ,thirdColor ] = colors;</div><div class="line">console.log(firstColor);        // &quot;red&quot;</div><div class="line">console.log(thirdColor);        // &quot;blue&quot;</div></pre></td></tr></table></figure>
<p>当通过var let或者const声明数组解构的绑定时，必须要提供一个初始化程序；</p>
<h4 id="解构赋值-1"><a href="#解构赋值-1" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>数组解构也可用于赋值上下文，不需要用小括号包裹， 因为[]跟{}不一样，后者有块级的功能；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ],</div><div class="line">    firstColor = &quot;black&quot;,</div><div class="line">    secondColor = &quot;purple&quot;;</div><div class="line">[ firstColor, secondColor ] = colors;</div><div class="line">console.log(firstColor);        // &quot;red&quot;</div><div class="line">console.log(secondColor);       // &quot;green&quot;</div></pre></td></tr></table></figure>
<p>数组也可用来交换两个变量的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let a = 1,</div><div class="line">b = 2;</div><div class="line">[ a, b ] = [ b, a ];</div><div class="line">console.log(a);     // 2</div><div class="line">console.log(b);     // 1</div></pre></td></tr></table></figure>
<p>与对象解构一样，如果右侧为null或者undefined，抛出错误；</p>
<h4 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let colors = [ &quot;red&quot; ];</div><div class="line">let [ firstColor, secondColor = &quot;green&quot; ] = colors;</div><div class="line">console.log(firstColor);        // &quot;red&quot;</div><div class="line">console.log(secondColor);       // &quot;green&quot;</div></pre></td></tr></table></figure>
<h4 id="嵌套解构-1"><a href="#嵌套解构-1" class="headerlink" title="嵌套解构"></a>嵌套解构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let colors = [ &quot;red&quot;, [ &quot;green&quot;, &quot;lightgreen&quot; ], &quot;blue&quot; ];</div><div class="line">// later</div><div class="line">let [ firstColor, [ secondColor ] ] = colors;</div><div class="line">console.log(firstColor);        // &quot;red&quot;</div><div class="line">console.log(secondColor);       // &quot;green&quot;</div></pre></td></tr></table></figure>
<h4 id="不定元素"><a href="#不定元素" class="headerlink" title="不定元素"></a>不定元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</div><div class="line">let [ firstColor, ...restColors ] = colors;</div><div class="line">console.log(firstColor);        // &quot;red&quot;</div><div class="line">console.log(restColors.length); // 2</div><div class="line">console.log(restColors[0]);     // &quot;green&quot;</div><div class="line">console.log(restColors[1]);     // &quot;blue&quot;</div></pre></td></tr></table></figure>
<p>通过上面这个语法，可以用来实现生成数组的副本；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// cloning an array in ECMAScript 6</div><div class="line">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</div><div class="line">let [ ...clonedColors ] = colors;</div><div class="line">console.log(clonedColors);      // &quot;[red,green,blue]&quot;</div></pre></td></tr></table></figure>
<p><strong>被解构的数组中，不定元素必须为最后一个条目，在后面继续添加逗号会导致程序抛出语法错误</strong></p>
<h2 id="混合解构"><a href="#混合解构" class="headerlink" title="混合解构"></a>混合解构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;foo&quot;,</div><div class="line">    loc: &#123;</div><div class="line">        start: &#123;</div><div class="line">            line: 1,</div><div class="line">column: 1 &#125;,</div><div class="line">        end: &#123;</div><div class="line">            line: 1,</div><div class="line">column: 4 &#125;</div><div class="line">&#125;,</div><div class="line">    range: [0, 3]</div><div class="line">&#125;;</div><div class="line">let &#123;</div><div class="line">    loc: &#123; start &#125;,</div><div class="line">    range: [ startIndex ]</div><div class="line">&#125; = node;</div><div class="line">console.log(start.line);   // 1</div><div class="line">console.log(start.column); // 1</div><div class="line">console.log(startIndex);   // 0</div></pre></td></tr></table></figure>
<h2 id="解构参数"><a href="#解构参数" class="headerlink" title="解构参数"></a>解构参数</h2><p>ES5解析参数可能会这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// properties on options represent additional parameters</div><div class="line">function setCookie(name, value, options) &#123;</div><div class="line">    options = options || &#123;&#125;;</div><div class="line">    let secure = options.secure,</div><div class="line">    path = options.path,</div><div class="line">    domain = options.domain,</div><div class="line">    expires = options.expires;</div><div class="line">    // code to set the cookie</div><div class="line">&#125;</div><div class="line">// third argument maps to options</div><div class="line">setCookie(&quot;type&quot;, &quot;js&quot;, &#123;</div><div class="line">    secure: true,</div><div class="line">    expires: 60000</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>利用解构我们可以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function setCookie(name, value, &#123; secure, path, domain, expires &#125;) &#123;</div><div class="line">    // code to set the cookie</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="必须传值的解构参数"><a href="#必须传值的解构参数" class="headerlink" title="必须传值的解构参数"></a>必须传值的解构参数</h4><p>解构参数在默认情况下，如果调用函数时不提供被解构的参数会导致程序抛出错误；如果这样调用上面的setCookie函数<code>setCookie(&#39;type&#39;, &#39;js&#39;)</code>会抛出错误；</p>
<p>实际上JS是这样解析的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function setCookie(name, value, options) &#123;</div><div class="line">    let &#123; secure, path, domain, expires &#125; = options;</div><div class="line">    // code to set the cookie</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当第三个参数不传值时，实际options被赋值为undefined，根据前面讨论过的解构赋值表达式=号右边的值不能为undefined或者null，所以第三个参数是必须传值的；</p>
<p>可以设置默认值来避免必须传值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function setCookie(name, value, &#123; secure, path, domain, expires &#125; = &#123;&#125;) &#123;</div><div class="line">// empty</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="解构参数默认值"><a href="#解构参数默认值" class="headerlink" title="解构参数默认值"></a>解构参数默认值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function setCookie(name, value,</div><div class="line">    &#123;</div><div class="line">        secure = false,</div><div class="line">        path = &quot;/&quot;,</div><div class="line">        domain = &quot;example.com&quot;,</div><div class="line">        expires = new Date(Date.now() + 360000000)</div><div class="line">&#125; = &#123;&#125; )&#123;</div><div class="line">// empty </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以为第三个参数设置一个默认对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">const cookieDefault = &#123;</div><div class="line">  secure: false,</div><div class="line">  path: &apos;/&apos;,</div><div class="line">  domain: &apos;example.com&apos;,</div><div class="line">  expires: new Date(Date.now() + 360000000)</div><div class="line">&#125;;</div><div class="line">function setCookie(name, value,</div><div class="line">    &#123;</div><div class="line">        secure = cookieDefault.secure,</div><div class="line">        path = cookieDefault.path,</div><div class="line">        domain = cookieDefault.domain,</div><div class="line">        expires = cookieDefault.expires</div><div class="line">&#125; = cookieDefault )&#123;</div><div class="line">// empty </div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/21/2017-11-21-ES6之对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/21/2017-11-21-ES6之对象/" itemprop="url">ES6之对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-21T00:00:00+08:00">
                2017-11-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="对象字面量语法扩展"><a href="#对象字面量语法扩展" class="headerlink" title="对象字面量语法扩展"></a>对象字面量语法扩展</h2><h4 id="属性初始值的简写"><a href="#属性初始值的简写" class="headerlink" title="属性初始值的简写"></a>属性初始值的简写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function createPerson(name, age) &#123;</div><div class="line">  return &#123;</div><div class="line">    name: name,</div><div class="line">    age: age </div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>属性与为属性赋值的变量是重复的，可以简写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function createPerson(name, age) &#123;</div><div class="line">  return &#123;</div><div class="line">    name,</div><div class="line">    age </div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样可以避免命名错误以及不小心的拼写错误。</p>
<h4 id="对象方法的简写"><a href="#对象方法的简写" class="headerlink" title="对象方法的简写"></a>对象方法的简写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    sayName: function() &#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以简写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    sayName() &#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>简写方法sayName里面可以使用super关键字；</p>
<h4 id="可计算属性名"><a href="#可计算属性名" class="headerlink" title="可计算属性名"></a>可计算属性名</h4><p>ES5及早期版本的对象实例中，如果想要通过计算得到属性名，就需要用方括号代替点记法。并且有空格的字符串不能直接作为属性名，也需要方括号代替；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var person = &#123;&#125;,</div><div class="line">    lastName = &quot;last name&quot;;</div><div class="line">person[&quot;first name&quot;] = &quot;Nicholas&quot;;</div><div class="line">person[lastName] = &quot;Zakas&quot;;</div><div class="line">console.log(person[&quot;first name&quot;]);</div><div class="line">console.log(person[lastName]);</div></pre></td></tr></table></figure>
<p>ES6中，可在对象字面量中使用可计算属性名称，其语法与引用对象实例的可计算属性名称相同，也是使用方括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let lastName = &quot;last name&quot;;</div><div class="line">let person = &#123;</div><div class="line">    &quot;first name&quot;: &quot;Nicholas&quot;,</div><div class="line">    [lastName]: &quot;Zakas&quot;</div><div class="line">&#125;;</div><div class="line">console.log(person[&quot;first name&quot;]);</div><div class="line">console.log(person[lastName]);</div></pre></td></tr></table></figure>
<h2 id="新增方法"><a href="#新增方法" class="headerlink" title="新增方法"></a>新增方法</h2><h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a>Object.is</h4><p>在JS中比较两个值，使用===跟==比较多，但是===在有些情况也不完全准确；+0与-0在JS引擎中是两个完全不同的实体，<code>NaN === NaN</code> 返回值为false，需要用isNaN()才能检测出NaN;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">console.log(+0 == -0);              // true</div><div class="line">console.log(+0 === -0);             // true</div><div class="line">console.log(Object.is(+0, -0));     // false</div><div class="line">console.log(NaN == NaN);            // false</div><div class="line">console.log(NaN === NaN);           // false</div><div class="line">console.log(Object.is(NaN, NaN));   // true</div><div class="line">console.log(5 == 5);                // true</div><div class="line">console.log(5 == &quot;5&quot;);              // true</div><div class="line">console.log(5 === 5);               // true</div><div class="line">console.log(5 === &quot;5&quot;);             // false</div><div class="line">console.log(Object.is(5, 5));       // true</div><div class="line">console.log(Object.is(5, &quot;5&quot;));     // false</div></pre></td></tr></table></figure>
<h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var receiver = &#123;&#125;;</div><div class="line">var test = &#123;name: &apos;zakas&apos;&#125;;</div><div class="line">Object.assign(receiver,</div><div class="line">    &#123;</div><div class="line">      type: &quot;js&quot;,</div><div class="line">        name: &quot;file.js&quot;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      type: &quot;css&quot;,</div><div class="line">      data: test,</div><div class="line">    &#125; </div><div class="line">);</div><div class="line">console.log(receiver.type); // css</div><div class="line">console.log(receiver.name); // file.js</div><div class="line">console.log(receiver.data); // &#123;name: &apos;zakas&apos;&#125;</div><div class="line">test.name = &apos;hi&apos;;</div><div class="line">console.log(receiver.data); // &#123;name: &apos;hi&apos;&#125;</div></pre></td></tr></table></figure>
<p>Object.assign参数后面的对象会覆盖前面的对象，并且为浅复制；</p>
<p>Object.assign会把访问器属性复制为数据属性；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var receiver = &#123;&#125;,</div><div class="line">  supplier = &#123;</div><div class="line">    get name() &#123;</div><div class="line">      return &quot;file.js&quot;</div><div class="line">    &#125; </div><div class="line">  &#125;;</div><div class="line">Object.assign(receiver, supplier);</div><div class="line">var descriptor = Object.getOwnPropertyDescriptor(receiver, &quot;name&quot;);</div><div class="line">console.log(descriptor.value);      // &quot;file.js&quot;</div><div class="line">console.log(descriptor.get);        // undefined</div></pre></td></tr></table></figure>
<h2 id="重复的对象字面量属性"><a href="#重复的对象字面量属性" class="headerlink" title="重复的对象字面量属性"></a>重复的对象字面量属性</h2><p>ES5严格模式重复字面量属性会报错；ES6无论严格或者非严格模式下，重复属性都会选取最后一个取值；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line">var person = &#123;</div><div class="line">  name: &quot;Nicholas&quot;,</div><div class="line">  name: &quot;Greg&quot;        // no error in ES6 strict mode</div><div class="line">&#125;;</div><div class="line">console.log(person.name); // Greg</div></pre></td></tr></table></figure></p>
<h2 id="自有属性枚举顺序"><a href="#自有属性枚举顺序" class="headerlink" title="自有属性枚举顺序"></a>自有属性枚举顺序</h2><ol>
<li>所有数字键按升序排列</li>
<li>所有字符串键按照它们被加入对象的顺序排序</li>
<li>所有symbol按照它们被加入的顺序排序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">    a: 1,</div><div class="line">    0: 1,</div><div class="line">    c: 1,</div><div class="line">    2: 1,</div><div class="line">    b: 1,</div><div class="line">    1: 1</div><div class="line">&#125;;</div><div class="line">obj.d = 1;</div><div class="line">console.log(Object.getOwnPropertyNames(obj).join(&quot;&quot;));</div><div class="line">// 012acbd</div></pre></td></tr></table></figure>
<h2 id="增强对象原型"><a href="#增强对象原型" class="headerlink" title="增强对象原型"></a>增强对象原型</h2><h4 id="改变对象的原型setPrototypeOf"><a href="#改变对象的原型setPrototypeOf" class="headerlink" title="改变对象的原型setPrototypeOf"></a>改变对象的原型setPrototypeOf</h4><p>对象原型的真实值被储存在内部的专用属性[[Prototype]]中，调用Object.getPrototypeOf返回储存在其中的值，调用Object.setPrototypeOf方法改变其中的值；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">let person = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        return &quot;Hello&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">let dog = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        return &quot;Woof&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">// prototype is person</div><div class="line">let friend = Object.create(person);</div><div class="line">console.log(friend.getGreeting()); // Hello</div><div class="line">console.log(Object.getPrototypeOf(friend) === person); // true</div><div class="line">// set prototype to dog</div><div class="line">Object.setPrototypeOf(friend, dog);</div><div class="line">console.log(friend.getGreeting()); // &quot;Woof&quot;</div><div class="line">console.log(Object.getPrototypeOf(friend) === dog); // true</div></pre></td></tr></table></figure>
<h4 id="简化原型访问的Super引用"><a href="#简化原型访问的Super引用" class="headerlink" title="简化原型访问的Super引用"></a>简化原型访问的Super引用</h4><p>ES6引入了super关键字，super引用相当于指向对象原型的指针，实际上也就是Object.getPrototypeOf()的效果；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let friend = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        // in the previous example, this is the same as:</div><div class="line">        // Object.getPrototypeOf(this).getGreeting.call(this)</div><div class="line">        return super.getGreeting() + &quot;, hi!&quot;;</div><div class="line">&#125; &#125;;</div></pre></td></tr></table></figure>
<p>super关键字必须要在使用简写方法的对象中使用super引用，如果在其他方法声明中使用会导致语法错误；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let friend = &#123;</div><div class="line">    getGreeting: function() &#123;// syntax error</div><div class="line">        return super.getGreeting() + &quot;, hi!&quot;; // &apos;super&apos; keyword unexpected here</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="正式的方法定义"><a href="#正式的方法定义" class="headerlink" title="正式的方法定义"></a>正式的方法定义</h2><p>ES6正式将方法定义为一个函数，它会由一个内部的[[HomeObject]]属性来容纳这个方法从属的对象；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let person = &#123;</div><div class="line">    // method</div><div class="line">    getGreeting() &#123;</div><div class="line">        return &quot;Hello&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">// not a method</div><div class="line">function shareGreeting() &#123;</div><div class="line">    return &quot;Hi!&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上段代码的getGreeting方法的[[HomeObject]]属性值为person，而创建shareGreeting函数时，由于未将其赋值给一个对象，因为该方法没有明确定义[[HomeObject]]属性。</p>
<p>super的所有引用都通过[[HomeObject]]属性调用Object.getPrototypeOf方法来检索原型的引用；然后搜寻原型找到同名函数；最后，设置this绑定并且调用相应的方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let person = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        return &quot;Hello&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">// prototype is person</div><div class="line">let friend = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        return super.getGreeting() + &quot;, hi!&quot;;</div><div class="line">&#125; &#125;;</div><div class="line">Object.setPrototypeOf(friend, person);</div><div class="line">console.log(friend.getGreeting());</div></pre></td></tr></table></figure>
<p><code>friend.getGreeting()</code>方法的[[HomeObject]]的属性值时friend,friend的原型是person，所以<code>super.getGreeting()</code>等价于<code>person.getGreeting.call(this)</code>;</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/19/2017-11-19-ES6之函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/19/2017-11-19-ES6之函数/" itemprop="url">ES6之函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-19T00:00:00+08:00">
                2017-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="函数形参默认值"><a href="#函数形参默认值" class="headerlink" title="函数形参默认值"></a>函数形参默认值</h2><h4 id="ES5默认形参"><a href="#ES5默认形参" class="headerlink" title="ES5默认形参"></a>ES5默认形参</h4><p>ES5中模拟默认形参<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function makeRequest(url, timeout, callback) &#123;</div><div class="line">  timeout = timeout || 2000;</div><div class="line">  callback = callback || function() &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是这种方法也有缺陷，如果第二个值我们传0，会被视为一个假值，函数timeout最后取值却为2000。</p>
<p>更好的做法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function makeRequest(url, timeout, callback) &#123;</div><div class="line">  timeout = typeof timeout !== undefined ? timeout : 2000;</div><div class="line">  callback = typeof callback !== undefined ? callback : function() &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="ES6默认形参"><a href="#ES6默认形参" class="headerlink" title="ES6默认形参"></a>ES6默认形参</h4><p>ES6做法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function makeRequest(url, timeout=2000, callback=function()&#123;&#125;) &#123;</div><div class="line">// do something</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>: 当timeout传值为undefined时，最终取值为默认值2000；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function makeRequest(url, timeout = 2000, callback) &#123;</div><div class="line">    console.log(timeout)</div><div class="line">&#125;</div><div class="line">makeRequest(&apos;/foo&apos;, undefined); // 2000</div></pre></td></tr></table></figure></p>
<h4 id="对arguments影响"><a href="#对arguments影响" class="headerlink" title="对arguments影响"></a>对arguments影响</h4><p>ES5非严格模式下，形参值被改变，arguments对应的也跟着改变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function mixArgs(first, second) &#123;</div><div class="line">    console.log(first === arguments[0]);</div><div class="line">    console.log(second === arguments[1]);</div><div class="line">    first = &quot;c&quot;;</div><div class="line">    second = &quot;d&quot;;</div><div class="line">    console.log(first === arguments[0]);</div><div class="line">    console.log(second === arguments[1]);</div><div class="line">&#125;</div><div class="line">mixArgs(&quot;a&quot;, &quot;b&quot;);</div><div class="line">// true</div><div class="line">// true</div><div class="line">// true</div><div class="line">// true</div></pre></td></tr></table></figure></p>
<p>严格模式下，无论形参如何被赋值，arguments不再跟着改变；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function mixArgs(first, second) &#123;</div><div class="line">    &apos;use strict&apos;;</div><div class="line">    console.log(first === arguments[0]);</div><div class="line">    console.log(second === arguments[1]);</div><div class="line">    first = &quot;c&quot;;</div><div class="line">    second = &quot;d&quot;;</div><div class="line">    console.log(first === arguments[0]);</div><div class="line">    console.log(second === arguments[1]);</div><div class="line">&#125;</div><div class="line">mixArgs(&quot;a&quot;, &quot;b&quot;);</div><div class="line">// true</div><div class="line">// true</div><div class="line">// false</div><div class="line">// false</div></pre></td></tr></table></figure></p>
<p>ES6中，如果使用了默认参数，则无论是否显式定义了严格模式，arguments行为与ES5严格模式下保持一致；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function mixArgs(first, second = &quot;b&quot;) &#123;</div><div class="line">    console.log(arguments.length);</div><div class="line">    console.log(first === arguments[0]);</div><div class="line">    console.log(second === arguments[1]);</div><div class="line">    first = &quot;c&quot;;</div><div class="line">    second = &quot;d&quot;</div><div class="line">    console.log(first === arguments[0]);</div><div class="line">    console.log(second === arguments[1]);</div><div class="line">&#125;</div><div class="line">mixArgs(&quot;a&quot;);</div><div class="line">// 1</div><div class="line">// true</div><div class="line">// false</div><div class="line">// false</div><div class="line">// false</div></pre></td></tr></table></figure></p>
<h4 id="默认参数表达式"><a href="#默认参数表达式" class="headerlink" title="默认参数表达式"></a>默认参数表达式</h4><p>默认参数也可以使用表达式；</p>
<p>默认参数表达式求值条件：当调用函数不传入默认参数对应位置的值时才会调用；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let value = 5;</div><div class="line">function getValue() &#123;</div><div class="line">    return value++;</div><div class="line">&#125;</div><div class="line">function add(first, second = getValue()) &#123;</div><div class="line">    return first + second;</div><div class="line">   &#125;</div><div class="line">console.log(add(1, 1)); // 2</div><div class="line">console.log(add(1)); // 6</div><div class="line">console.log(add(1)); // 7</div></pre></td></tr></table></figure>
<h4 id="默认参数临时死区（TDZ）"><a href="#默认参数临时死区（TDZ）" class="headerlink" title="默认参数临时死区（TDZ）"></a>默认参数临时死区（TDZ）</h4><p>默认参数也类似let有默认死区，后面的参数不能用在之前参数的默认值上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function add(first = second, second) &#123;</div><div class="line">    return first + second;</div><div class="line">&#125;</div><div class="line">console.log(add(1, 1));         // 2</div><div class="line">console.log(add(undefined, 1)); // Uncaught ReferenceError: second is not defined</div></pre></td></tr></table></figure></p>
<h2 id="无命名参数"><a href="#无命名参数" class="headerlink" title="无命名参数"></a>无命名参数</h2><p>由于之前当有多个无命名参数时，我们需要利用arguments参数来处理，有一个问题是需要记录从哪个索引开始，比较麻烦；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function pick(object) &#123;</div><div class="line">                 let result = Object.create(null);</div><div class="line">                 // start at the second parameter</div><div class="line">                 for (let i = 2, len = arguments.length; i &lt; len; i++) &#123;</div><div class="line">                     result[arguments[i]] = object[arguments[i]];</div><div class="line">                 &#125;</div><div class="line">                 return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ES6做法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function pick(object, ...keys) &#123;</div><div class="line">                 let result = Object.create(null);</div><div class="line">                 // start at the second parameter</div><div class="line">                 for (let i = 0, len = keys.length; i &lt; len; i++) &#123;</div><div class="line">                     result[keys[i]] = object[keys[i]];</div><div class="line">                 &#125;</div><div class="line">                 return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不定参数使用限制：<strong>最多只能一个不定参数，而且一定要放在所有参数的最后；</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function pick(object, ...keys, last) &#123;</div><div class="line">    let result = Object.create(null);</div><div class="line">    for (let i = 0, len = keys.length; i &lt; len; i++) &#123;</div><div class="line">        result[keys[i]] = object[keys[i]];</div><div class="line">&#125;</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line">pick() // error</div></pre></td></tr></table></figure>
<h2 id="增强的Function构造函数"><a href="#增强的Function构造函数" class="headerlink" title="增强的Function构造函数"></a>增强的Function构造函数</h2><p>Function构造函数也可以使用默认参数和无命名参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var add = new Function(&quot;first&quot;, &quot;second = first&quot;, &quot;...rest&quot;, &quot;return first + second&quot;);</div></pre></td></tr></table></figure>
<h2 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let values = [-25, -50, -75, -100];</div><div class="line">console.log(Math.max(...values, 0));</div></pre></td></tr></table></figure>
<h2 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var doSomething = function doSomethingElse() &#123;</div><div class="line">    // empty</div><div class="line">&#125;;</div><div class="line">var person = &#123;</div><div class="line">    get firstName() &#123;</div><div class="line">        return &quot;Nicholas&quot;</div><div class="line">    &#125;,</div><div class="line">    sayName: function() &#123;</div><div class="line">        console.log(this.name);</div><div class="line">&#125; &#125;</div><div class="line">console.log(doSomething.name); // doSomethingElse</div><div class="line">console.log(person.sayName.name); // sayName</div><div class="line">console.log(person.firstName.name); // get firstName</div><div class="line">console.log(doSomething.bind().name); // bound doSomethingElse</div><div class="line">console.log((new Function()).name); // anonymous</div></pre></td></tr></table></figure>
<p>注意:</p>
<ol>
<li>命名函数(doSomethingElse)并且赋值了一个变量(doSomething)，取命名的名字doSomethingElse;</li>
<li>get属性的函数前面会有一个get； // chrome是返回undefined，需要确认是不是实现不一致;</li>
<li>利用bind生成的新函数前面有一个bound</li>
<li>Function构造函数生成的函数为anonymous</li>
</ol>
<h2 id="明确函数的多重用途"><a href="#明确函数的多重用途" class="headerlink" title="明确函数的多重用途"></a>明确函数的多重用途</h2><p>JS函数有两个不同的内部方法： [[Call]]和[[Construct]]。当通过new关键字调用函数时，执行的是[[Construct]]，它负责创建一个通常被称为实例的新对象，然后再执行函数体，将this绑定到新实例上；如果不通过new关键字调用函数，则执行[[Call]]函数，从而直接执行代码中的函数体。具有[[Construct]]方法的函数被统称为构造函数。</p>
<p>注意：<strong>不是所有的函数都有[[Construct]]方法，例如箭头函数就没有[[Construct]]方法，所以箭头函数不能使用new关键字调用；</strong></p>
<p>之前ES5判断一个函数是不是通过’new’调用会判断this的原型, 但是这也有问题，函数执行没有用new但使用call来改变this同样可以不报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">    if (this instanceof Person) &#123;</div><div class="line">        this.name = name;   // using new</div><div class="line">    &#125; else &#123;</div><div class="line">        throw new Error(&quot;You must use new with Person.&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var person = new Person(&quot;Nicholas&quot;);</div><div class="line">var notAPerson = Person(&quot;Nicholas&quot;);</div><div class="line">var notAPerson = Person.call(person, &quot;Michael&quot;); // works</div></pre></td></tr></table></figure></p>
<h4 id="元属性new-target"><a href="#元属性new-target" class="headerlink" title="元属性new.target"></a>元属性new.target</h4><p>为了解决判断函数是否通过new关键字调用的问题，ES6引入了new.target这个元属性；</p>
<p>元属性是指非对象的属性，其可以提供非对象目标的补充信息；当调用函数的[[Construct]]方法时，new.target被赋值为new操作符的目标，通常是新创建对象实例，也就是函数体内this的构造函数，如果调用[[Call]]方法，则new.target的值为undefined。则判断一个函数是否是通过new关键字调用的，可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">    if (new.target === Person) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125; else &#123;</div><div class="line">        throw new Error(&quot;You must use new with Person.&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">function AnotherPerson(name) &#123;</div><div class="line">    Person.call(this, name);</div><div class="line">&#125;</div><div class="line">var person = new Person(&quot;Nicholas&quot;);</div><div class="line">var person = Person(&quot;Zakas&quot;); //Uncaught Error: You must use new with Person.</div><div class="line">var anotherPerson = new AnotherPerson(&quot;Nicholas&quot;);// Uncaught Error: You must use new with Person.</div></pre></td></tr></table></figure>
<p><strong>在函数体外使用new.target是一个语法错误</strong></p>
<h2 id="块级函数"><a href="#块级函数" class="headerlink" title="块级函数"></a>块级函数</h2><p>ES5严格模式下声明块级函数会抛出错误；ES6中，会将块级函数视作一个块级声明，从而在代码块内可以访问和调用；<strong>但是块级函数会被提升至顶部；</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">    console.log(typeof doSomething);</div><div class="line">    function doSomething() &#123;</div><div class="line">        // empty</div><div class="line">    &#125;</div><div class="line">    doSomething();</div><div class="line">&#125;</div><div class="line">console.log(typeof doSomething); // function</div></pre></td></tr></table></figure>
<p>如果要真正的定义块级函数，可以使用let表达式，这样函数表达式就不会提升了；并且有临时死区的情况，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">    console.log(typeof doSomething); // error</div><div class="line">    let doSomething = function () &#123;</div><div class="line">        // empty</div><div class="line">    &#125;</div><div class="line">    doSomething();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ol>
<li>无this super arguments和new.target绑定</li>
</ol>
<p>这些值由外围最近一层非箭头函数决定；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let PageHandler = &#123;</div><div class="line">    id: &quot;123456&quot;,</div><div class="line">    init: function() &#123;</div><div class="line">        document.addEventListener(&quot;click&quot;,</div><div class="line">                event =&gt; this.doSomething(event.type), false);</div><div class="line">    &#125;,</div><div class="line">    doSomething: function(type) &#123;</div><div class="line">        console.log(&quot;Handling &quot; + type  + &quot; for &quot; + this.id);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<ol>
<li>不能通过new关键字调用</li>
</ol>
<p>正如之前提到过的箭头函数没有[[Constructor]]方法，不能通过new关键字调用，；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var MyType = () =&gt; &#123;&#125;,</div><div class="line">object = new MyType(); // MyType is not a constructor</div></pre></td></tr></table></figure>
<ol>
<li>没有原型</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var MyType = () =&gt; &#123;&#125;;</div><div class="line">var test = function() &#123;&#125;;</div><div class="line">console.log(MyType.prototype); // undefined</div><div class="line">console.log(test.prototype.toString()); // [object Object]</div></pre></td></tr></table></figure>
<ol>
<li>不可以改变this的绑定</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var MyType = () =&gt; &#123;console.log(this)&#125;;</div><div class="line">MyType.bind(&#123;name: &apos;hi&apos;&#125;)(); // Window</div><div class="line">var test = function() &#123;console.log(this)&#125;;</div><div class="line">test.bind(&#123;name: &apos;hi&apos;&#125;)(); // &#123;name: &apos;hi&apos;&#125;</div></pre></td></tr></table></figure>
<ol>
<li>不支持arguments对象<br>绑定的arguments是外围非箭头函数的arguments</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function createArrowFunctionReturningFirstArg() &#123;</div><div class="line">    return () =&gt; arguments[0];</div><div class="line">&#125;</div><div class="line">var arrowFunction = createArrowFunctionReturningFirstArg(5);</div><div class="line">console.log(arrowFunction());</div></pre></td></tr></table></figure>
<ol>
<li>不支持重复的命名参数</li>
</ol>
<p>传统函数，只有严格模式不能使用重名的参数；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function test(name, name)&#123;&#125;;</div><div class="line">&apos;use strict&apos;;</div><div class="line">function test(name, name)&#123;&#125;; //Duplicate parameter name not allowed in this context</div></pre></td></tr></table></figure></p>
<p>箭头函数中，不支持重复的命名参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var test = (name, name) =&gt; &#123;console.log(this)&#125; // Duplicate parameter name not allowed in this context</div></pre></td></tr></table></figure></p>
<h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>ES6缩减了严格模式下尾调用栈的大小（非严格模式下不影响），如果满足以下条件，尾调用不再创建新的栈帧，而是清楚并重用当前栈帧：</p>
<ul>
<li>尾调用不访问当前栈帧的变量；（函数不是一个闭包）</li>
<li>在函数内部，尾调用是最后一条语句；</li>
<li>尾调用的结果作为函数值返回；</li>
</ul>
<p>满足条件的尾调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line">function doSomething() &#123;</div><div class="line">    // optimized</div><div class="line">    return doSomethingElse();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不满足第一个条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line">function doSomething() &#123;</div><div class="line">    var num = 1,</div><div class="line">        func = () =&gt; num;</div><div class="line">    // not optimized - function is a closure</div><div class="line">    return func();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不满足第二个条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line">function doSomething() &#123;</div><div class="line">    // not optimized - call isn&apos;t in tail position</div><div class="line">    var result = doSomethingElse();</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不满足第三个条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line">function doSomething() &#123;</div><div class="line">    // not optimized - must add after returning</div><div class="line">    return 1 + doSomethingElse();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/15/2017-11-15-ES6之let与const 字符串和正则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/15/2017-11-15-ES6之let与const 字符串和正则/" itemprop="url">ES6之let与const 字符串和正则</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-15T00:00:00+08:00">
                2017-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="let-const"><a href="#let-const" class="headerlink" title="let const"></a>let const</h2><p>let与const其实没什么特别的，主要就是提供的块级作用域，存在于函数内部和块中（字符{和}之间的区域），没有var的变量提升；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num = 1 + num1; // throw error</div><div class="line">let num1 = 5;</div></pre></td></tr></table></figure></p>
<p>需要注意的点：</p>
<h4 id="禁止重声明"><a href="#禁止重声明" class="headerlink" title="禁止重声明"></a>禁止重声明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var msg = &apos;hi&apos;;</div><div class="line">let msg = &apos;test&apos;; // Uncaught SyntaxError: Identifier &apos;msg&apos; has already been declared</div></pre></td></tr></table></figure>
<h4 id="临时死区TDZ（Temporal-Dead-Zone）"><a href="#临时死区TDZ（Temporal-Dead-Zone）" class="headerlink" title="临时死区TDZ（Temporal Dead Zone）"></a>临时死区TDZ（Temporal Dead Zone）</h4><p>使用let和const定义的变量在定义处到块级作用域开始之间是不能使用定义的变量的，使用会报错；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var msg = &apos;hi&apos;;</div><div class="line">if(true) &#123;</div><div class="line">  typeof msg; // Uncaught ReferenceError: msg is not defined</div><div class="line">  let msg = &apos;hello&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>由于词法作用域的缘故，执行<code>console.log(i)</code>指向的都市同一个i，最后值是10<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var funcs = [];</div><div class="line">for (var i = 0; i &lt; 10; i++) &#123;</div><div class="line">    funcs.push(function() &#123;</div><div class="line">        console.log(i);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">funcs.forEach(function(func) &#123;</div><div class="line">    func();     // outputs the number &quot;10&quot; ten times</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>let声明每次迭代循环会创建一个新变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var funcs = [];</div><div class="line">for (var i = 0; i &lt; 10; i++) &#123;</div><div class="line">    funcs.push((function(value) &#123;</div><div class="line">        return function() &#123;</div><div class="line">            console.log(value);</div><div class="line">&#125; &#125;(i)));</div><div class="line">&#125;</div><div class="line">funcs.forEach(function(func) &#123;</div><div class="line">    func();     // outputs 0, then 1, then 2, up to 9</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="全局作用域行为"><a href="#全局作用域行为" class="headerlink" title="全局作用域行为"></a>全局作用域行为</h4><p>var在全局作用域定义的是window的一个属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var msg = &quot;Hello!&quot;;</div><div class="line">console.log(window.msg); // &apos;Hello!&apos;</div><div class="line">console.log(window.msg === msg); // true</div></pre></td></tr></table></figure></p>
<p>而let和const创建了一个绑定并遮蔽了全局的msg变量；let和const比较安全；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let msg1 = &quot;Hello!&quot;;</div><div class="line">console.log(window.msg1); // undefined</div><div class="line">console.log(window.msg1 === msg1); // false</div></pre></td></tr></table></figure>
<h4 id="const绑定的是引用"><a href="#const绑定的是引用" class="headerlink" title="const绑定的是引用"></a>const绑定的是引用</h4><p>const绑定是引用，只要引用不变，不报错；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const obj = &#123;msg: 1&#125;;</div><div class="line">obj.msg = 2;</div><div class="line">console.log(obj); // &#123;msg: 2&#125;</div><div class="line">obj = &#123;msg: 2&#125; // Uncaught TypeError: Assignment to constant variable.</div></pre></td></tr></table></figure></p>
<p>块级绑定最佳实践是尽量用const，只有确实需要改变变量的值时用let。</p>
<h2 id="字符串变动"><a href="#字符串变动" class="headerlink" title="字符串变动"></a>字符串变动</h2><h4 id="Unicode支持"><a href="#Unicode支持" class="headerlink" title="Unicode支持"></a>Unicode支持</h4><p>ES6出现之前，JS字符一直基于16位字符编码(UTF-16)进行构建。每16位的序列是一个编码单元，代表一个字符。length\chatAt等属性与方法都是基于这种编码单元构成的。</p>
<p>UTF-16编码中：</p>
<ul>
<li>前2**16个码位均以16位的编码单元表示，这个范围被称作BMP</li>
<li>但是如果超出16位编码范围之外的码位，就无法仅用16位来表示，UTF-16引入了<strong>代理对</strong>，用两个16位编码单元来表示；</li>
</ul>
<p>“𠮷”这个字符就是超出16位表示范围的，使用了代理对来表示的，在ES5中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let text = &quot;𠮷&quot;; </div><div class="line">console.log(text.length); // 2</div><div class="line">console.log(/^.$/.test(text)); // false</div><div class="line">console.log(text.charAt(0)); // &quot;&quot;</div><div class="line">console.log(text.charAt(1)); // &quot;&quot;</div><div class="line">console.log(text.charCodeAt(0)); // 55362</div><div class="line">console.log(text.charCodeAt(1)); // 57271</div></pre></td></tr></table></figure>
<h4 id="codePointAt-fromCodePoint"><a href="#codePointAt-fromCodePoint" class="headerlink" title="codePointAt / fromCodePoint"></a>codePointAt / fromCodePoint</h4><p>ES6引入了codePointAt与fromcodePoint来支持超出16位码元，这两个方法接受编码单元的位置而非字符位置作为参数；如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let text = &quot;𠮷a&quot;;</div><div class="line">console.log(text.charCodeAt(0)); // 55362</div><div class="line">console.log(text.charCodeAt(1));  // 57271</div><div class="line">console.log(text.charCodeAt(2)); // 97</div><div class="line">console.log(text.codePointAt(0)); // 134071 超出0xffff</div><div class="line">console.log(text.codePointAt(1)); // 57271</div><div class="line">console.log(text.codePointAt(2)); // 97</div><div class="line">console.log(String.fromCodePoint(134071)); // &apos;𠮷&apos;</div></pre></td></tr></table></figure>
<p>注意charCodeAt与codePointAt的区别，如上面的text.codePointAt(0)计算了’𠮷’的完整码位-两个编码单元，超出0xffff；</p>
<h4 id="新增字符串方法includes-startWith-endWith-repeat"><a href="#新增字符串方法includes-startWith-endWith-repeat" class="headerlink" title="新增字符串方法includes / startWith / endWith / repeat"></a>新增字符串方法includes / startWith / endWith / repeat</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let msg = &quot;Hello world!&quot;;</div><div class="line">console.log(msg.startsWith(&quot;Hello&quot;)); // true</div><div class="line">console.log(msg.endsWith(&quot;!&quot;)); // true</div><div class="line">console.log(msg.includes(&quot;o&quot;)); // true</div><div class="line">console.log(msg.startsWith(&quot;o&quot;)); // false</div><div class="line">console.log(msg.endsWith(&quot;world!&quot;)); // true</div><div class="line">console.log(msg.includes(&quot;x&quot;)); // false</div><div class="line">console.log(msg.startsWith(&quot;o&quot;, 4)); // true</div><div class="line">console.log(msg.endsWith(&quot;o&quot;, 8)); // true</div><div class="line">console.log(msg.includes(&quot;o&quot;, 8));  // false</div></pre></td></tr></table></figure>
<p>这里需要注意的是endsWith是从用第二个参数减去搜索字符的长度得到的数字位置开始搜索的；如<code>msg.endsWith(&quot;o&quot;, 8)</code>是从<code>8-len(&#39;o&#39;)=7</code>开始搜索的；以此类推如果是<code>msg.endsWith(&quot;orl&quot;, 8)</code>则是从<code>8-len(&#39;orl&#39;)=5</code>开始搜索返回false；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;hello&apos;.repeat(2)); // hellohello</div><div class="line">console.log(&apos;a&apos;.repeat(2)); // aa</div><div class="line">console.log(&apos;bc&apos;.repeat(3)); // bcbcbc</div></pre></td></tr></table></figure>
<h4 id="模版字面量"><a href="#模版字面量" class="headerlink" title="模版字面量"></a>模版字面量</h4><p>ES6引入了模版字面量语法支持更丰富的字符串功能：</p>
<ul>
<li>多行字符串</li>
<li>基本的字符串格式化，支持嵌套</li>
<li>HTLM转义</li>
</ul>
<p>看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let message = `hello world!`</div><div class="line">console.log(message) // &apos;hello world&apos;</div><div class="line">console.log(typeof message) // 12</div><div class="line"></div><div class="line">// 多行字符串</div><div class="line">var msg = `Multiline</div><div class="line">string`;</div><div class="line">console.log(msg); // &apos;Multiline</div><div class="line">                  // string&apos;</div><div class="line">console.log(message.length); // 16</div><div class="line"></div><div class="line">// 字符串占位</div><div class="line">let name = &apos;world&apos;,</div><div class="line">    msg1 = `Hello, $&#123;name&#125;`;</div><div class="line">console.log(message); // &quot;Hello, world!&quot;</div></pre></td></tr></table></figure>
<p>除了上面的功能之外，还有一个标签模版的功能；标签可以是一个函数，第一个参数是一个数组，包含JS解释过后的字面量字符串，之后的所有参数都是每一个占位符的解释值；如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function tag(literals, ...substitutions) &#123;</div><div class="line">	console.log(literals);</div><div class="line">	console.log(literals.raw)</div><div class="line">	console.log(substitutions);</div><div class="line">	return &apos;hello world!&apos;;</div><div class="line">&#125;</div><div class="line">var name1 = &apos;lili&apos;;</div><div class="line">var name2 = &apos;lucy&apos;;</div><div class="line">var msg = tag`abc$&#123;name1&#125;def$&#123;name2&#125;\n`;</div><div class="line">//  [&quot;abc&quot;, &quot;def&quot;, &quot;↵&quot;, raw: Array(3)]</div><div class="line">//  [&quot;abc&quot;, &quot;def&quot;, &quot;\n&quot;]</div><div class="line">//  [&quot;lili&quot;, &quot;lucy&quot;]</div><div class="line">console.log(msg); // &apos;hello world!&apos;</div></pre></td></tr></table></figure>
<p>特别要说明的是literals.raw是对应literals的原生字符串信息；如<code>\n</code>为<code>\\n</code>;</p>
<h2 id="正则变动"><a href="#正则变动" class="headerlink" title="正则变动"></a>正则变动</h2><h4 id="u修饰符"><a href="#u修饰符" class="headerlink" title="u修饰符"></a>u修饰符</h4><p>上面我们看到”𠮷”匹配不到/^.$/正则表达式；这是因为正则是通过编码单元来匹配字符串的，而”𠮷”是由两个编码单元组成的，所以/^.$/是匹配不成功的；</p>
<p>为了解决这种问题，ES6引入了一个支持Unicode的u修饰符；当使用了修饰符u，正则表达式就从编码单元模式切换为字符模式，如此一来正则表达式就不会视代理对为两个字符，从而安全按照我们预期正常运行；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let text = &quot;𠮷&quot;;</div><div class="line">console.log(text.length); // 2</div><div class="line">console.log(/^.$/.test(text)); // false</div><div class="line">console.log(/^.$/u.test(text)); // true</div></pre></td></tr></table></figure>
<p>检测是否支持修饰符u：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function hasRegExpU() &#123;</div><div class="line">    try &#123;</div><div class="line">        var pattern = new RegExp(&quot;.&quot;, &quot;u&quot;);</div><div class="line">        return true;</div><div class="line">    &#125; catch (ex) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="修饰符y"><a href="#修饰符y" class="headerlink" title="修饰符y"></a>修饰符y</h4><p>ES6新增了一个正则表达式扩展：修饰符y，主要是影响正则表达式搜索过程中的sticky属性；当在字符串开始匹配时，会通知搜索从正则表达式的lastIndex属性开始进行，如果在指定位置没能匹配成功，则停止继续匹配；看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">let text = &quot;hello1 hello2 hello3&quot;,</div><div class="line">    pattern = /hello\d\s?/,</div><div class="line">    result = pattern.exec(text),</div><div class="line">    globalPattern = /hello\d\s?/g,</div><div class="line">    globalResult = globalPattern.exec(text),</div><div class="line">    stickyPattern = /hello\d\s?/y,</div><div class="line">    stickyResult = stickyPattern.exec(text);</div><div class="line">console.log(result[0]);// &quot;hello1 &quot;</div><div class="line">console.log(globalResult[0]);// &quot;hello1 &quot;</div><div class="line">console.log(stickyResult[0]);// &quot;hello1 &quot;</div><div class="line">pattern.lastIndex = 1;</div><div class="line">globalPattern.lastIndex = 1;</div><div class="line">stickyPattern.lastIndex = 1;</div><div class="line"></div><div class="line">result = pattern.exec(text);</div><div class="line">globalResult = globalPattern.exec(text);</div><div class="line">stickyResult = stickyPattern.exec(text);</div><div class="line">console.log(result[0]); // &quot;hello1 &quot;</div><div class="line">console.log(globalResult[0]);// &quot;hello2 &quot;</div><div class="line">console.log(stickyResult[0]);// throws an error!</div></pre></td></tr></table></figure>
<p>当指定lastIndex设置为1的时候，stickyPattern没有匹配成功，stickyResult返回null，<code>console.log(stickyResult[0])</code>就报错；</p>
<p>需要注意以下几点：</p>
<ol>
<li>y和g修饰符如果匹配失败，lastIndex会被重置为0；</li>
<li>y是<strong>严格</strong>从lastIndex开始匹配，而g从lastIndex匹配失败可以继续往后匹配；</li>
<li>只有调用exec和test这些正则表达式对象的方法时才会涉及lastIndex属性；调用字符串的方法是不会有效果的；</li>
</ol>
<p>检测是否支持y修饰符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function hasRegExpY() &#123;</div><div class="line">    try &#123;</div><div class="line">        var pattern = new RegExp(&quot;.&quot;, &quot;y&quot;);</div><div class="line">        return true;</div><div class="line">    &#125; catch (ex) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="正则表达式复制"><a href="#正则表达式复制" class="headerlink" title="正则表达式复制"></a>正则表达式复制</h4><p>ES5可以通过给RegExp构造函数传递正则表达式作为参数来复制这个表达式, 但是如果第二个参数传递修饰符参数则会报错；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var re1 = /ab/i</div><div class="line">var re2 = new RegExp(re1) //</div><div class="line">var re3 = new RegExp(re1, &apos;g&apos;) //报错</div></pre></td></tr></table></figure></p>
<p>ES6修改了这个行为，可以传递修饰符<code>var re4 = new RegExp(re1, &#39;g&#39;)</code>;但是会把之前的修饰符替换掉，re4变成了<code>/ab/g</code>.</p>
<h4 id="正则表达式flags属性"><a href="#正则表达式flags属性" class="headerlink" title="正则表达式flags属性"></a>正则表达式flags属性</h4><p>ES6在正则表达式中新增了flags属性，会输出正则的修饰符；如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let reg = /ab/igu;</div><div class="line">console.log(reg.flags); // &apos;igu&apos;</div><div class="line">console.log(reg.source); // &apos;ab&apos;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/11/2017-11-11-递归/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/11/2017-11-11-递归/" itemprop="url">递归</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-11T00:00:00+08:00">
                2017-11-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>// 留个坑 </p>
<p>减而治之 通过不断蚕食不断削减问题有效规模的策略</p>
<p>为求解一个大规模的问题，可以将其划分为若干（通常两个）子问题，规模大体相当，分别求解子问题，由子问题的解，得到原问题的解。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/06/2017-11-06-mediaSource/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/06/2017-11-06-mediaSource/" itemprop="url">MSE</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T00:00:00+08:00">
                2017-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/html5/" itemprop="url" rel="index">
                    <span itemprop="name">html5</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是MSE"><a href="#什么是MSE" class="headerlink" title="什么是MSE"></a>什么是MSE</h2><p>MSE是一个允许在支持html5-video的浏览器中发送字节流的w3c标准, 全称是Media Souce Extensions. </p>
<p><img src="/images/media_pipleline.svg" alt=""></p>
<h2 id="MSE来由"><a href="#MSE来由" class="headerlink" title="MSE来由"></a>MSE来由</h2><p>要先知道MSE的来由，先要知道没有MSE之前浏览器对video的支持情况。</p>
<p>Html5发布后浏览器支持video标签, 但是只是基本支持了播放一个完整单轨道，无法支持视频arraybuffer的分隔与组合；由于现在社会多媒体技术的发展，<br>人们对视频观看方式的需求日益剧增，如视频点播, 代表为国内的youku/souhu/iqiyi等视频网站，国外的youtube netflix hulu等；到现在的各种直播网站，<br>国内的斗鱼国外的twitch等；之前浏览器的video功能已经不能支持，所以MSE标准应运而生。</p>
<h2 id="MSE特点"><a href="#MSE特点" class="headerlink" title="MSE特点"></a>MSE特点</h2><p>MSE首先提供了MediaSource对象，作为一个容器，内部包含了一系列视频信息，如要被播放的media资源的状态, 指向组成播放流的多个轨道的SouceBuffer对象，<br>除此之外，MSE还提供了对视频内容获取的多少与速度的把控，以及一些内存的管理；</p>
<p>但是，MSE也有一些不足之处，因为浏览器处理视频解码转码方面性能消耗很大，这些功能只能放在浏览器之外处理，所以浏览器只接受主流的一些媒体格式，如<br>H.264 video codec, AAC audio codec, and MP4 container format; 还有一点就是各浏览器对MSE的支持程度不太一致，实现也有一些差别，导致现在html5播放器<br>在浏览器使用上没有普及开来，需要各方的协作.</p>
<h2 id="主要对象"><a href="#主要对象" class="headerlink" title="主要对象"></a>主要对象</h2><h4 id="1-MediaSouce"><a href="#1-MediaSouce" class="headerlink" title="1.MediaSouce"></a>1.MediaSouce</h4><p><strong>构造函数</strong></p>
<p>MediaSource() // 构造并且返回一个新的MediaSource的空对象</p>
<p><strong>属性</strong></p>
<p>MediaSource.sourceBuffers / MediaSource.activeSourceBuffers / MediaSource.readyState /MediaSource.duration</p>
<p><strong>方法</strong></p>
<p>MediaSource.addSourceBuffer() / MediaSource.removeSourceBuffer() / MediaSource.endOfStream() / MediaSource.isTypeSupported()</p>
<h4 id="2-SouceBuffer"><a href="#2-SouceBuffer" class="headerlink" title="2.SouceBuffer"></a>2.SouceBuffer</h4><p><strong>构造</strong></p>
<p>可以通过MediaSource.addSourceBuffer()来构造</p>
<p><strong>属性</strong></p>
<p>mode / updating / buffered / timestampOffset / audioTracks / videoTracks / textTracks / appendWindowStart / trackDefaults</p>
<p><strong>方法</strong></p>
<p>appendBuffer() / appendStream() / abort() / remove()</p>
<p><strong>事件</strong></p>
<p>onabort / onerror / onupdate / onupdateend / onupdatestart</p>
<h4 id="3-URL-Object-Extensions"><a href="#3-URL-Object-Extensions" class="headerlink" title="3.URL Object Extensions"></a>3.URL Object Extensions</h4><p><strong>构造方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var video = document.querySelector(&apos;#video&apos;)</div><div class="line">var m = new MediaSource</div><div class="line">var l = URL.createObjectURL(m)</div><div class="line">video.src = l</div></pre></td></tr></table></figure>
<h4 id="4-HTMLMediaElement-Extensions"><a href="#4-HTMLMediaElement-Extensions" class="headerlink" title="4.HTMLMediaElement Extensions"></a>4.HTMLMediaElement Extensions</h4><p>HTMLMediaElement.seekable -&gt;  normalized TimeRanges object</p>
<p>HTMLMediaElement.buffered -&gt;  normalized TimeRanges objec</p>
<h2 id="一个简单例子"><a href="#一个简单例子" class="headerlink" title="一个简单例子"></a>一个简单例子</h2><p>下面是从MDN上摘录下来的一个栗子, 这个栗子可以在<a href="https://github.com/nickdesaulniers/netfix/tree/gh-pages/demo" target="_blank" rel="external">这里</a>下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">var video = document.querySelector(&apos;video&apos;);</div><div class="line"></div><div class="line">var assetURL = &apos;frag_bunny.mp4&apos;;</div><div class="line">// Need to be specific for Blink regarding codecs</div><div class="line">// ./mp4info frag_bunny.mp4 | grep Codec</div><div class="line">var mimeCodec = &apos;video/mp4; codecs=&quot;avc1.42E01E, mp4a.40.2&quot;&apos;;</div><div class="line"></div><div class="line">if (&apos;MediaSource&apos; in window &amp;&amp; MediaSource.isTypeSupported(mimeCodec)) &#123;</div><div class="line">  var mediaSource = new MediaSource();</div><div class="line">  //console.log(mediaSource.readyState); // closed</div><div class="line">  video.src = URL.createObjectURL(mediaSource);</div><div class="line">  mediaSource.addEventListener(&apos;sourceopen&apos;, sourceOpen);</div><div class="line">&#125; else &#123;</div><div class="line">  console.error(&apos;Unsupported MIME type or codec: &apos;, mimeCodec);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function sourceOpen (_) &#123;</div><div class="line">  //console.log(this.readyState); // open</div><div class="line">  var mediaSource = this;</div><div class="line">  var sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);</div><div class="line">  fetchAB(assetURL, function (buf) &#123;</div><div class="line">    sourceBuffer.addEventListener(&apos;updateend&apos;, function (_) &#123;</div><div class="line">      mediaSource.endOfStream();</div><div class="line">      video.play();</div><div class="line">      //console.log(mediaSource.readyState); // ended</div><div class="line">    &#125;);</div><div class="line">    sourceBuffer.appendBuffer(buf);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function fetchAB (url, cb) &#123;</div><div class="line">  console.log(url);</div><div class="line">  var xhr = new XMLHttpRequest;</div><div class="line">  xhr.open(&apos;get&apos;, url);</div><div class="line">  xhr.responseType = &apos;arraybuffer&apos;;</div><div class="line">  xhr.onload = function () &#123;</div><div class="line">    cb(xhr.response);</div><div class="line">  &#125;;</div><div class="line">  xhr.send();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="相关库"><a href="#相关库" class="headerlink" title="相关库"></a>相关库</h2><ul>
<li><p><a href="https://github.com/Dash-Industry-Forum/dash.js" target="_blank" rel="external">dash.js</a></p>
</li>
<li><p><a href="https://github.com/video-dev/hls.js/" target="_blank" rel="external">hls.js</a></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/abu.jpg"
                alt="cauil" />
            
              <p class="site-author-name" itemprop="name">cauil</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/cauil" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/cauil" target="_blank" title="Weibo">
                    
                      <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://douban.com/people/cauil" target="_blank" title="DouBan">
                    
                      <i class="fa fa-fw fa-douban"></i>DouBan</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cauil</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
