<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Cauil&#39;s Blog">
<meta property="og:url" content="http://cauil.github.io/index.html">
<meta property="og:site_name" content="Cauil&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cauil&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://cauil.github.io/"/>





  <title>Cauil's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cauil's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">陌上花开，可缓缓归矣</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2018/01/13/2018-01-13-JS模式之工厂模式和迭代器模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/13/2018-01-13-JS模式之工厂模式和迭代器模式/" itemprop="url">JS模式之工厂模式和迭代器模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-13T00:00:00+08:00">
                2018-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>设计工厂模式的目的是为了创建对象。它通常在类或者类的静态方法中实现，具有下列目标：</p>
<ul>
<li>当创建相识对象时执行重复操作</li>
<li>在编译时不知道具体类型的情况下，为工厂客户提供一种创建对象的接口</li>
</ul>
<p>通过工厂方法创建的对象在设计上都继承了相同的父对象这个思想，它们都是实现专门功能的特定子类。有时候公共父类是一个包含了工厂方法的同一个类。</p>
<p>看一个汽车工厂实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function CarMaker() &#123;&#125;</div><div class="line"></div><div class="line">CarMaker.prototype.drive = function() &#123;</div><div class="line">  return &quot;Vroom, I have &quot; + this.doors + &quot; doors&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">CarMaker.factory = function(type) &#123;</div><div class="line">  var constr = type, newcar;</div><div class="line">  if(typeof CarMaker[constr] !== &quot;function&quot;) &#123;</div><div class="line">    throw &#123;</div><div class="line">      name: &quot;Error&quot;,</div><div class="line">      message: constr + &quot; doesn&apos;t exist&quot;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  if(typeof CarMaker[constr].prototype.drive !== &quot;function&quot;) &#123;</div><div class="line">    CarMaker[constr].prototype = new CarMaker();</div><div class="line">  &#125;</div><div class="line">  newcar = new CarMaker[constr]();</div><div class="line">  return newcar;</div><div class="line">&#125;</div><div class="line"></div><div class="line">CarMaker.Compact = function() &#123;this.doors = 4&#125;</div><div class="line">CarMaker.Convertible = function() &#123;this.doors = 2&#125;</div><div class="line">CarMaker.SUV = function() &#123;this.doors = 24;&#125;</div></pre></td></tr></table></figure>
<p>再看看使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var corolla = CarMaker.factory(&apos;Compact&apos;);</div><div class="line">var solstice = CarMaker.factory(&apos;Convertible&apos;);</div><div class="line">var cherokee = CarMaker.factory(&apos;SUV&apos;);</div><div class="line">corolla.drive()</div><div class="line">solstice.drive()</div><div class="line">chrokee.drive()</div></pre></td></tr></table></figure></p>
<p>实现该工厂模式并没有特别的困难，所有需要做的就是寻找能够创建所需类型对象的构造函数。</p>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>提起迭代器就会联想起ES6新支持的迭代协议，迭代器，可迭代对象；其实迭代器模式就是跟ES6的迭代器类似；</p>
<p>通常的迭代器模式中，有一个包含各种数据集合的对象。该数据可能存储在一个复杂数据结构内部，而要提供一种简单的方法能够访问数据结构中每个元素。对象的消费者并不需要知道如何组织数据，所有需要做的就是取出单个数据进行工作。</p>
<p>在迭代器模式中，需要提供一个next方法，还可以提供一个较为方便的hasNext方法，看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var agg = (functiono() &#123;</div><div class="line">  var index = 0,</div><div class="line">  data = [1, 2, 3, 4, 5],</div><div class="line">  length = data.length;</div><div class="line">  </div><div class="line">  return &#123;</div><div class="line">    next: function() &#123;</div><div class="line">      var element;</div><div class="line">      if(!this.hasNext()) &#123;</div><div class="line">        return null;</div><div class="line">      &#125;</div><div class="line">      element = data[index];</div><div class="line">      index = index +2;</div><div class="line">      return element;</div><div class="line">    &#125;,</div><div class="line">    hasNext: function() &#123;</div><div class="line">      return index &lt; length;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>除了上面的两个方法，还可以提供更简单的访问方式及多次迭代数据的能力，你的对象可以提供额外的便利方法：</p>
<p>rewind()：重置指针到初始位置。<br>current(): 返回当前元素，因为不可能在不前进指针的情况下使用next()执行该操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var agg = (function() &#123;</div><div class="line">  // ...</div><div class="line">  return &#123;</div><div class="line">    // ...</div><div class="line">    rewind: function() &#123;</div><div class="line">      index = 0;</div><div class="line">    &#125;,</div><div class="line">    current: function() &#123;</div><div class="line">      return data[index]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)()</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2018/01/13/2018-01-13-JS模式之策略模式和外观模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/13/2018-01-13-JS模式之策略模式和外观模式/" itemprop="url">JS模式之策略模式和外观模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-13T00:00:00+08:00">
                2018-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>在开发中，表单验证经常会碰到，而且会需要验证不同的值，不同的匹配条件；这时候可以采用策略模式来统一起来处理，策略模式支持在运行时选择算法。</p>
<p>我们可以创建一个具有validate方法的验证器对象。无论表单的具体类型是什么，该方法都将会被调用，并且总是返回相同的结果；</p>
<p>验证器实现：</p>
<h4 id="要验证的数据："><a href="#要验证的数据：" class="headerlink" title="要验证的数据："></a>要验证的数据：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var data = &#123;</div><div class="line">  first_name = &quot;Super&quot;,</div><div class="line">  last_name = &quot;Man&quot;,</div><div class="line">  age: &quot;unknown&quot;,</div><div class="line">  username: &quot;o_O&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="配置不同数据采用不同的验证方法："><a href="#配置不同数据采用不同的验证方法：" class="headerlink" title="配置不同数据采用不同的验证方法："></a>配置不同数据采用不同的验证方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">validator.config = &#123;</div><div class="line">  first_name: &apos;isNonEmpty&apos;,</div><div class="line">  age: &apos;isNumber&apos;,</div><div class="line">  username: &apos;isAlphaNum&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">validator.validate(data);</div><div class="line">if(validator.hasErrors()) &#123;</div><div class="line">  console.log(validator.messages.join(&quot;\n&quot;))</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h4 id="验证器算法"><a href="#验证器算法" class="headerlink" title="验证器算法"></a>验证器算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">validator.types = &#123;</div><div class="line">  isNonEmpty: &#123;</div><div class="line">    validate(value) &#123;</div><div class="line">      return value !== &apos;&apos;;</div><div class="line">    &#125;,</div><div class="line">    instructions: &apos;the value cannot be empty&apos;</div><div class="line">  &#125;,</div><div class="line">  isNumber: &#123;</div><div class="line">    validate(value) &#123;</div><div class="line">      return !isNaN(value);</div><div class="line">    &#125;,</div><div class="line">    instructions: &apos;the value can only be a valid number, e.g. 1, 3.24, or 2010&apos;</div><div class="line">  &#125;,</div><div class="line">  isAlphaNum: &#123;</div><div class="line">    validate(value) &#123;</div><div class="line">      return !/[^a-z0-9]/i.test(value);</div><div class="line">    &#125;,</div><div class="line">    instructions: &apos;the value can only contain characters and numbers, no special symbols&apos;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="验证器本身"><a href="#验证器本身" class="headerlink" title="验证器本身"></a>验证器本身</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">var validator = &#123;</div><div class="line">  types: &#123;&#125;,</div><div class="line">  messages: [],</div><div class="line">  config: &#123;&#125;,</div><div class="line">  validate: function(data) &#123;</div><div class="line">    var i, msg, type, checker, result_ok;</div><div class="line">    </div><div class="line">    this.messages = [];</div><div class="line">    for(i in data) &#123;</div><div class="line">      if(data.hasOwnProperty(i)) &#123;</div><div class="line">        type = this.config[i];</div><div class="line">        checker = this.types[type];</div><div class="line">        </div><div class="line">        if(!type) &#123;</div><div class="line">          continue;</div><div class="line">        &#125;</div><div class="line">        if(!checker) &#123;</div><div class="line">          throw &#123;</div><div class="line">            name: &apos;VAlidationError&apos;,</div><div class="line">            message: &apos;No handler to validate type&apos; + type</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        result_ok = checker.validate(data[i])</div><div class="line">        if(!result_ok) &#123;</div><div class="line">          msg = &apos;invalid value for *&apos; + i + &apos;*, &apos; + checker.instructions;</div><div class="line">          this.message.push(msg)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    return this.hasErrors()</div><div class="line">  &#125;,</div><div class="line">  hasErrors: function() &#123;</div><div class="line">    return this.message.length !== 0;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，我们就实现了策略模式的关于表单验证的一个实例。</p>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式是一种简单的模式，它为对象提供了一个可供选择的接口。这是一种非常好的实践，可保持方法的简洁性并且不会使他们处理过多的工作。如果原来有许多接受多个参数的uber方法，相比而言，按照本实现方法，最终将会创建更多数量的方法。有时候两个或更多的方法可能普遍的被一起调用。在这种情况下，创建另一个方法包装重复的方法调用是非常有意义的。</p>
<p>看个实践场景：</p>
<p>当处理浏览器事件时，你有以下方法：</p>
<ul>
<li>stopPropagation 中止事件以避免其冒泡上升到父节点</li>
<li>preventDefault 阻止浏览器执行默认动作</li>
</ul>
<p>并不需要在程序中到处复制者两个方法，可以创建一个外观方法从而同时调用者两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var myevent = &#123;</div><div class="line">  // ...</div><div class="line">  stop: function(e) &#123;</div><div class="line">    // 其他</div><div class="line">    if(typeof e.preventDefault === &apos;function&apos;) &#123;</div><div class="line">      e.preventDefault()</div><div class="line">    &#125;</div><div class="line">    if(typeof e.stopPropagation === &apos;function&apos;) &#123;</div><div class="line">      e.stopPropagation();</div><div class="line">    &#125;</div><div class="line">    if(typeof e.returnValue === &apos;boolean&apos;) &#123;</div><div class="line">      e.returnValue = false;</div><div class="line">    &#125;</div><div class="line">    if(typeof e.cancelBubble === &apos;boolean&apos;) &#123;</div><div class="line">      e.cancelBubble = true;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2018/01/13/2018-01-13-JS模式之装饰器模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/13/2018-01-13-JS模式之装饰器模式/" itemprop="url">JS模式之装饰器模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-13T00:00:00+08:00">
                2018-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>在装饰器模式中，可以在运行时动态添加附加功能到对象中。当处理静态类，这可能是一个挑战。在JS中，由于对象是可变的，因此，添加功能到对象中的过程本身并不是问题。</p>
<p>装饰者模式的一个比较方便的特征在于其预期行为的可定制和可配置特性。可以从仅具有一些基本功能的普通对象开始，然后从可用装饰资源池中选择需要用于增加普通对象的那些功能，并且按照顺序进行装饰；</p>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p>如果实现一个销售商品的价格，有原始价格、国税、地税以及币种的转换；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var sale = new Sale(100);</div><div class="line">sale.decorate(&apos;fedax&apos;);</div><div class="line">sale.decorate(&apos;quebec&apos;);</div><div class="line">sale.decorate(&apos;money&apos;);</div><div class="line">sale.getPrice()</div></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">function Sale(price) &#123;</div><div class="line">  this.price = (price &gt; 0) || 100;</div><div class="line">  this.decorators_list = [];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Sale.decorators = &#123;&#125;;</div><div class="line">Sale.decorators.fedtax = &#123;</div><div class="line">  getPrice: function(price) &#123;</div><div class="line">    return price + price*5/100;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">Sale.decorators.quebec = &#123;</div><div class="line">  getPrice: function(price) &#123;</div><div class="line">    return price + price*7.5/100;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">Sale.decorators.money = &#123;</div><div class="line">  getPrice: function(price) &#123;</div><div class="line">    return &quot;$&quot; + price.toFixed(2);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Sale.prototype.decorate = function(decorator) &#123;</div><div class="line">  this.decorators_list.push(decorator);</div><div class="line">&#125;</div><div class="line">Sale.prototype.getPrice = function() &#123;</div><div class="line">  var price = this.price,</div><div class="line">  i,</div><div class="line">  max = this.decorators_list.length,</div><div class="line">  name;</div><div class="line">  </div><div class="line">  for(i = 0; i &lt; max; i += 1) &#123;</div><div class="line">    name = this.decorators_list[i];</div><div class="line">    price = Sale.decorators[name].getPrice(price);</div><div class="line">  &#125;</div><div class="line">  return price;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="ECMASCRIPT装饰器"><a href="#ECMASCRIPT装饰器" class="headerlink" title="ECMASCRIPT装饰器"></a>ECMASCRIPT装饰器</h4><p>在ES8中，将会添加新的语言功能-装饰器；</p>
<p>新的功能目前已经处于stage2阶段，目前只可作用于class和class属性；</p>
<p><strong>class member decorator</strong></p>
<p>装饰器函数接受三个参数：</p>
<ul>
<li>target - 所属的class</li>
<li>name - member的名字</li>
<li>descriptor - member的描述对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function readonly(target, name, descriptor) &#123;</div><div class="line">  descriptor.writable = false;</div><div class="line">  return descriptor;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Example &#123;</div><div class="line">  a() &#123;&#125;</div><div class="line">  @readonly</div><div class="line">  b() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const e = new Example();</div><div class="line">e.a = 1;</div><div class="line">e.b = 2; // TypeError: Cannot assign to read only property &apos;b&apos; of object &apos;#</div></pre></td></tr></table></figure>
<p>目前这个装饰器使用需要用babel插件才可以使用，浏览器都没有支持；</p>
<p><strong>class decorator</strong></p>
<p>直接看使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function log(Class) &#123;</div><div class="line">  return (...args) =&gt; &#123;</div><div class="line">    console.log(args);</div><div class="line">    return new Class(...args);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@log</div><div class="line">class Example &#123;</div><div class="line">  constructor(name, age) &#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const e = new Example(&apos;Graham&apos;, 34); // [ &apos;Graham&apos;, 34 ]</div><div class="line">console.log(e); // Example &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>其实新的装饰器跟python有点类似，有点区别；类装饰器跟python装饰器思路是一致，只有类属性装饰器是是通过重新定义属性描述器中的值来装饰的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2018/01/13/2018-01-13-JS模式之代理模式和中介者模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/13/2018-01-13-JS模式之代理模式和中介者模式/" itemprop="url">JS模式之代理模式和中介者模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-13T00:00:00+08:00">
                2018-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>在代理模式中，一个对象充当另一个对象的借口。它与外观模式的区别之处在于，在外观模式中你所拥有的是多个方法调用的便利方法。代理则介于对象的客户端和对象本身之间，并且对该对象的访问进行保护。</p>
<p>这种模式可能看起来像是额外的开销，但是出于性能因素的考虑它却非常有用。代理充当了某个对象的守护对象，并且试图使本体对象做尽可能少的工作。</p>
<h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><p>在有视频服务器与客户端的通信之间，可以设置一个代理，进行合并多个请求，或者进行缓存，这样可以省去有些额外的开销；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">var proxy = &#123;</div><div class="line">  ids: [],</div><div class="line">  delay: 50,</div><div class="line">  timeout: null,</div><div class="line">  callback: null,</div><div class="line">  context: null,</div><div class="line">  makeRequest: function(id, callback, context) &#123;</div><div class="line">    this.ids.push(id);</div><div class="line">    </div><div class="line">    this.callback = callback;</div><div class="line">    this.context = context;</div><div class="line">    </div><div class="line">    if(!this.timeout) &#123;</div><div class="line">      this.timeout = setTimeout(function() &#123;</div><div class="line">      proxy.flush();</div><div class="line">      &#125;, this.delay)</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  flush: function() &#123;</div><div class="line">    http.makeRequest(this.ids, &apos;proxy.handler&apos;);</div><div class="line">    </div><div class="line">    this.timeout = null;</div><div class="line">    this.ids = [];</div><div class="line">  &#125;,</div><div class="line">  handler: function(data) &#123;</div><div class="line">    var i, max;</div><div class="line">    </div><div class="line">    if(parseInt(data.query.count, 10) === 1) &#123;</div><div class="line">      proxy.callback.call(proxy.context, data.query.results.Video);</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line">    for(i = 0, max = data.query.results.Video.length; i &lt; max; i += 1) &#123;</div><div class="line">      proxy.callback.call(proxy.context, data.query.results.Video[i]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在代理中还可以设置缓存，这样当相同的请求来临时，可以进一步保护对本体对象的http的访问。那么，如果videos对象恰好再一次请求同一个视频，proxy可以从缓存中取出该信息，从而节省了该网络的往返信息。</p>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>应用程序中，无论大小都是由一些单个的对象所组成。所有这些对象需要一种方式来实现相互通信，而这种通信方式在一定程度上不降低可维护性，也不损害那种安全的改变部分应用程序儿不会破坏其余部分的能力。随着应用程序的增长，将添加越来越多的对象。然后在代码重构阶段，对象将被删除或重新整理。对对象互相知道太多信息并且直接通信（调用对方的方法并改变属性），这将导致产生不良的紧耦合问题。党对象间紧密耦合时，很难在改变单个对象的同时不影响其他多个对象。因而，即使对应用程序进行最简单的修改也变的不再容易，而且几乎无法估计修改可能话费的时间。</p>
<p><strong>中介者模式缓解了该问题并促进形成松耦合，而且还有助于提高可维护性。在这种模式中，独立的对象之间并不直接通信，而是通过mediator对象。当其中的一个colleague对象改变状态以后，它将会通知该mediator，而mediator将会把该变化传达到任意其他应该知道此变化的colleague对象。</strong></p>
<p>看一个按键游戏，两个玩家看谁按键得分多；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">function Player(name)&#123;</div><div class="line">  this.points = 0;</div><div class="line">  this.name = name;</div><div class="line">&#125;</div><div class="line">Player.prototype.play = function() &#123;</div><div class="line">  this.points += 1;</div><div class="line">  mediator.played();</div><div class="line">&#125;</div><div class="line"></div><div class="line">var coreboard = &#123;</div><div class="line">  update(score) &#123;</div><div class="line">    var i, msg = &apos;&apos;;</div><div class="line">    for(i in score) &#123;</div><div class="line">      msg += `&lt;p&gt;&lt;strong&gt;$&#123;i&#125;&lt;/strong&gt;: $&#123;score[i]&#125;&lt;/p&gt;`</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var mediator = &#123;</div><div class="line">  palyers: &#123;&#125;,</div><div class="line">  setup: function() &#123;</div><div class="line">    var players = this.players;</div><div class="line">    players.home = new Player(&apos;Home&apos;);</div><div class="line">    players.guest = new Player(&apos;Guest&apos;);</div><div class="line">  &#125;,</div><div class="line">  played: function(e) &#123;</div><div class="line">    var players = this.players,</div><div class="line">    score = &#123;</div><div class="line">      Home: players.home.points,</div><div class="line">      Guest: players.guest.points</div><div class="line">    &#125;;</div><div class="line">    scoreboard.update(score);</div><div class="line">  &#125;,</div><div class="line">  keypress: function(e) &#123;</div><div class="line">    e = e || window.event;</div><div class="line">    if(e.which === 49) &#123;</div><div class="line">      mediator.players.home.play();</div><div class="line">      return</div><div class="line">    &#125; </div><div class="line">    if(e.which === 48) &#123;</div><div class="line">      mediator.players.guest.play();</div><div class="line">      return</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 最后建立以及拆除该游戏</div><div class="line">mediator.setup();;</div><div class="line">window.onkeypress = mediator.keypress;</div><div class="line"></div><div class="line">setTimeout(function() &#123;</div><div class="line">  window.onkeypress = null;</div><div class="line">  alert(&apos;Game Over&apos;)</div><div class="line">&#125;, 30000)</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2018/01/08/2018-01-08-JS模式之单体模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/08/2018-01-08-JS模式之单体模式/" itemprop="url">JS设计模式之单体模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-08T00:00:00+08:00">
                2018-01-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>单体模式的思想在于保证一个特定类仅有一个实例。这意味着当您第二次使用同一个类床创建新对象的时候，应该得到与第一次创建对象完全相同对象。</p>
<h2 id="ES5之前"><a href="#ES5之前" class="headerlink" title="ES5之前"></a>ES5之前</h2><p>在ES5之前是没有类这种概念，只有对象。当创建一个新对象时，实际上没有其他对象与其类似，因此新对象已经是单体了。使用对象字面量创建一个简单的对象也是一个单体的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">  myprop: &apos;my value&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在JS中，对象之间永远不会完全相等，除非它们是同一个对象，因此即使创建一个具有完全相同成员的同类对象，它也不会与第一个对象完全相等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var obj2 = &#123;</div><div class="line">  myprop: &apos;my value&apos;</div><div class="line">&#125;</div><div class="line">obj1 === obj2; // false</div><div class="line">obj1 == obj2; // false</div></pre></td></tr></table></figure>
<p>因此可以认为每次在使用对象字面量创建对象的时候，实际上就正在创建一个单体，并且并不涉及任何特殊语法。</p>
<h2 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h2><p>使用new可以创建对象，有时可能需要使用此方法的单体实现。这种思想在于当使用同一个构造函数以new操作符来创建多个对象时，应该仅获得指向完全相同的对象的新指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var uni = new Universe()</div><div class="line">var uni2 = new Universe()</div><div class="line">uni1 === uni2 // true</div></pre></td></tr></table></figure>
<p>怎么实现上面的单体模式呢？</p>
<p>可能会想到使用缓存该对象实例this，以便当第二次调用该构造函数时能够创建并返回同一个对象。实现方式有多种：</p>
<ul>
<li>使用全局变量来缓存；但是不推荐，一般原则下，全局变量是有缺点的。</li>
<li>可以在构造函数的静态属性中缓存该变量。唯一缺点是函数属性是公开访问的属性，在外部代码中可能会修改该属性，以至于让您丢失了该实例。</li>
<li>将实例包装在闭包中。这样可以保证该实例的私有性并且保证该实例不会被构造函数之外的代码所修改。代价是带来了额外的闭包开销。</li>
</ul>
<h4 id="第二种实现"><a href="#第二种实现" class="headerlink" title="第二种实现"></a>第二种实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Universe() &#123;</div><div class="line">  if(typeof Universe.instance === &apos;object&apos;) &#123;</div><div class="line">    return Universe.instance</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  this.start_time = 0;</div><div class="line">  this.bang = &quot;big&quot;;</div><div class="line">  </div><div class="line">  Universe.instance = this;</div><div class="line">  </div><div class="line">  //return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="第三种实现"><a href="#第三种实现" class="headerlink" title="第三种实现"></a>第三种实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Universe() &#123;</div><div class="line">  var instance = this;</div><div class="line">  </div><div class="line">  this.start_time = 0;</div><div class="line">  this.bang = &quot;big&quot;;</div><div class="line">  </div><div class="line">  Universe = function() &#123;</div><div class="line">    return instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种实现有一些缺点，在于重写函数时会丢失所有在初始定义和重定义时刻之间添加到它里面的属性；在这里的特定情况下，任何添加到Universe()的原型中的对象都不会存在指向由原始实现所创建实例的活动链接。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Universe.prototype.nothing = true;</div><div class="line">var uni = new Universe()</div><div class="line">Universe.prototype.everything = true;</div><div class="line">var uni2 = new Universe();</div><div class="line"></div><div class="line">uni.nothing  // true</div><div class="line">uni2.nothing // true</div><div class="line"></div><div class="line">uni.everything // undefined</div><div class="line">uni2.everything // undefined</div><div class="line"></div><div class="line">uni.constructor.name // Universe</div><div class="line">uni.constructor === Universe; // false</div></pre></td></tr></table></figure>
<h4 id="改进1"><a href="#改进1" class="headerlink" title="改进1"></a>改进1</h4><p>可以把第一次就返回改写Universe函数调用得到的实例，并链接原型链</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Universe() &#123;</div><div class="line">  var instance;</div><div class="line">  </div><div class="line">  Universe = function() &#123;</div><div class="line">    return instance;</div><div class="line">  &#125;</div><div class="line">  Universe.prototype = this;</div><div class="line">  instance = new Universe();</div><div class="line">  instance.constuctor = Universe;</div><div class="line">  </div><div class="line">  instance.start_time = 0;</div><div class="line">  instance.bang = &quot;big&quot;;</div><div class="line">  </div><div class="line">  return instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试得到预期结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Universe.prototype.nothing = true;</div><div class="line">var uni = new Universe()</div><div class="line">Universe.prototype.everything = true;</div><div class="line">var uni2 = new Universe();</div><div class="line"></div><div class="line">uni.nothing  // true</div><div class="line">uni2.nothing // true</div><div class="line"></div><div class="line">uni.everything //true</div><div class="line">uni2.everything // true</div><div class="line"></div><div class="line">uni.constructor.name // Universe </div><div class="line">uni.constructor === Universe; // true</div></pre></td></tr></table></figure>
<h4 id="改进2-立即执行函数"><a href="#改进2-立即执行函数" class="headerlink" title="改进2-立即执行函数"></a>改进2-立即执行函数</h4><p>利用立即执行函数进行改写Universe，并在闭包里面封装一个实例，每次调用构造函数都返回这个实例；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var Universe;</div><div class="line">(function() &#123;</div><div class="line">  var instance;</div><div class="line">  Universe = function() &#123;</div><div class="line">    if(instance) &#123;</div><div class="line">      return instance</div><div class="line">    &#125;</div><div class="line">    instance = this;</div><div class="line">    </div><div class="line">    this.start_time = 0;</div><div class="line">    this.bang = &apos;Big&apos;;</div><div class="line">  &#125;</div><div class="line">&#125;())</div></pre></td></tr></table></figure>
<h2 id="ES6实现方法"><a href="#ES6实现方法" class="headerlink" title="ES6实现方法"></a>ES6实现方法</h2><p>ES6实现原理其实跟ES5一样，只不过语法不一样而与；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Universe &#123;</div><div class="line">  constructor() &#123;</div><div class="line">    if(!Universe.instance) &#123;</div><div class="line">      this.start_time = 0;</div><div class="line">      this.bang = &quot;Big&quot;;</div><div class="line">      Universe.instance = this;</div><div class="line">    &#125;</div><div class="line">    return Universe.instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/12/27/2017-12-27-koa2探秘/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/27/2017-12-27-koa2探秘/" itemprop="url">koa2探秘</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-27T00:00:00+08:00">
                2017-12-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/node/" itemprop="url" rel="index">
                    <span itemprop="name">node</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>阅读背景：</p>
<ul>
<li>已经读过上一篇koa1的文章</li>
<li>async await</li>
<li>class</li>
</ul>
<p>还是跟前面koa1文章类似，先看看koa2的使用方法；</p>
<h2 id="koa2使用方法"><a href="#koa2使用方法" class="headerlink" title="koa2使用方法"></a>koa2使用方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const Koa = require(&apos;koa&apos;);</div><div class="line">const app = new Koa();</div><div class="line"></div><div class="line">app.use(async (ctx, next) =&gt; &#123;</div><div class="line">  const start = Date.now();</div><div class="line">  await next();</div><div class="line">  const ms = Date.now() - start;</div><div class="line">  console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;ms`);</div><div class="line">&#125;);`</div><div class="line">app.listen(8888);</div></pre></td></tr></table></figure>
<h2 id="koa2原理"><a href="#koa2原理" class="headerlink" title="koa2原理"></a>koa2原理</h2><p>从上面代码可以看出，koa2中间件函数使用了异步函数、关键字async await;</p>
<p>使用async与await带来了什么呢？</p>
<h4 id="async-await-class"><a href="#async-await-class" class="headerlink" title="async await class"></a>async await class</h4><p>熟悉async与await的童鞋一定会知道这是JS最新处理异步的关键字；</p>
<p>async会把正常函数转化为async函数，执行后会返回promise；async 函数中可能会有 await 表达式，这将会使 async 函数暂停执行，等待 Promise 正常解决后继续执行 async 函数并返回解决结果。</p>
<p>async/await的目的是简化同步使用 promises 的做法，并对一组Promises执行一些操作。正如Promises类似于结构化回调，async/await类似于组合生成器和 promises。</p>
<p>先看看koa现在主体代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Application extends Emitter &#123;</div><div class="line">  constructor() &#123;</div><div class="line">    super();</div><div class="line"></div><div class="line">    this.proxy = false;</div><div class="line">    this.middleware = [];</div><div class="line">    this.subdomainOffset = 2;</div><div class="line">    this.env = process.env.NODE_ENV || &apos;development&apos;;</div><div class="line">    this.context = Object.create(context);</div><div class="line">    this.request = Object.create(request);</div><div class="line">    this.response = Object.create(response);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  listen(...args) &#123;</div><div class="line">    debug(&apos;listen&apos;);</div><div class="line">    const server = http.createServer(this.callback());</div><div class="line">    return server.listen(...args);</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面看出现在koa主体代码使用了最新es6中的class、解构与展开. 这样带来一个限制，<strong>只能使用new关键字来生成实例，不然报错</strong>.</p>
<h4 id="app-callback"><a href="#app-callback" class="headerlink" title="app.callback"></a>app.callback</h4><p>下面是callback源码以及req来临的处理代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">callback() &#123;</div><div class="line">  const fn = compose(this.middleware);</div><div class="line"></div><div class="line">  if (!this.listeners(&apos;error&apos;).length) this.on(&apos;error&apos;, this.onerror);</div><div class="line"></div><div class="line">  const handleRequest = (req, res) =&gt; &#123;</div><div class="line">    const ctx = this.createContext(req, res);</div><div class="line">    return this.handleRequest(ctx, fn);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  return handleRequest;</div><div class="line">&#125;</div><div class="line"></div><div class="line">handleRequest(ctx, fnMiddleware) &#123;</div><div class="line">  const res = ctx.res;</div><div class="line">  res.statusCode = 404;</div><div class="line">  const onerror = err =&gt; ctx.onerror(err);</div><div class="line">  const handleResponse = () =&gt; respond(ctx);</div><div class="line">  onFinished(res, onerror);</div><div class="line">  return fnMiddleware(ctx).then(handleResponse).catch(onerror);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码与koa1最大不同的是中间件函数的处理，之前是co.wrap(compose(this.middleware)), 现在是compose(this.middleware); 这个到最后执行的关键函数是什么，怎么调用参数来执行；</p>
<h4 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h4><p>先看看现在的compose代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function compose (middleware) &#123;</div><div class="line">  if (!Array.isArray(middleware)) throw new TypeError(&apos;Middleware stack must be an array!&apos;)</div><div class="line">  for (const fn of middleware) &#123;</div><div class="line">    if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;Middleware must be composed of functions!&apos;)</div><div class="line">  &#125;</div><div class="line">  return function (context, next) &#123;</div><div class="line">    // last called middleware #</div><div class="line">    let index = -1</div><div class="line">    return dispatch(0)</div><div class="line">    function dispatch (i) &#123;</div><div class="line">      if (i &lt;= index) return Promise.reject(new Error(&apos;next() called multiple times&apos;))</div><div class="line">      index = i</div><div class="line">      let fn = middleware[i]</div><div class="line">      if (i === middleware.length) fn = next</div><div class="line">      if (!fn) return Promise.resolve()</div><div class="line">      try &#123;</div><div class="line">        return Promise.resolve(fn(context, function next () &#123;</div><div class="line">          return dispatch(i + 1)</div><div class="line">        &#125;))</div><div class="line">      &#125; catch (err) &#123;</div><div class="line">        return Promise.reject(err)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>中间件处理之后生成函数其实就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function(context, next) &#123;</div><div class="line">    return Promise resolve(fn(context, function next() &#123;</div><div class="line">        return dispatch(i+1)</div><div class="line">    &#125;))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="koa2执行流程"><a href="#koa2执行流程" class="headerlink" title="koa2执行流程"></a>koa2执行流程</h4><ol>
<li>请求到来</li>
<li>执行fnMiddleware(ctx), 也就是上面的compose处理中间件得到的函数</li>
<li>执行dispatch(0)</li>
<li>其实就是执行中间件数组第一个中间件，直到await next()停止;</li>
<li>而next实际就是传递给第一个函数的第二个参数<code>function next() {return dispatch(i+1)}</code></li>
<li>执行next函数，也就是执行dispatch(1), 从而进入到第二个中间件；</li>
<li>依次往复，直到执行到最后一个中间件next</li>
<li>当执行dispatch(n+1)时，n+1取到fn为空，则<code>return Promise.resolve()</code>, 接着执行最后一个中间件await后面的内容, 并返回一个resolve的Promise</li>
<li>然后返回到上一个中间件，执行await后面的内容，依次返回, 直到第一个中间件返回resolve了的promise</li>
<li>最后执行<code>return fnMiddleware(ctx).then(handleResponse).catch(onerror);</code>语句then后面的handleResponse</li>
<li>至此整个请求执行完所有中间件，并返回结果;</li>
</ol>
<h4 id="dispatch注意点"><a href="#dispatch注意点" class="headerlink" title="dispatch注意点"></a>dispatch注意点</h4><p>dispatch函数中有个需要注意的地方：</p>
<p>第一句<code>if (i &lt;= index) return Promise.reject(new Error(&#39;next() called multiple times&#39;))</code></p>
<p>这个异常什么时候会执行呢， 当一个中间件中有多次await next()的时候，由于执行某一个中间件的时候根据闭包原理会存储一个i值，而多个await意味着多次执行next函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function next() &#123;return dispatch(i+1)&#125;</div></pre></td></tr></table></figure>
<p><strong>第一次执行上面的函数返回后index就会等于i+1，当第二次执行到dispatch(i+1)里面，i值没变，就会得到<code>i+1 === index</code>, 报错。</strong>这也是koa1与koa2的不同点，也是解决在上一篇koa1文章结尾的问题.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，就完成了koa2原理的核心部分，其余部分都是小变化。</p>
<p>也可以看出await与async简化了koa的实现，并且代码比koa1中的多次封装中间件、co函数的协助、委托生成器与迭代器好理解多了.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/12/25/2017-12-25-koa1探秘/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/25/2017-12-25-koa1探秘/" itemprop="url">koa1探秘</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-25T00:00:00+08:00">
                2017-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/node/" itemprop="url" rel="index">
                    <span itemprop="name">node</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>掌握这些背景知识对理解koa1源码有帮助：</p>
<ul>
<li>原型链查找 闭包 高阶函数(返回函数的函数) getter/setter call/apply</li>
<li>代理委托</li>
<li>promise 异步函数 迭代器 委托生成器(yield *)</li>
<li>co模块处理</li>
<li>node http模块</li>
</ul>
<h2 id="koa使用"><a href="#koa使用" class="headerlink" title="koa使用"></a>koa使用</h2><p>先从koa1开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">const Koa = require(&apos;koa&apos;);</div><div class="line">const app = new Koa();</div><div class="line"></div><div class="line">// response</div><div class="line">app.use(function *() &#123;</div><div class="line">  console.log(&apos;1-1&apos;);</div><div class="line">  yield next;</div><div class="line">  console.log(&apos;1-2&apos;);</div><div class="line">&#125;);</div><div class="line">app.use(function *() &#123;</div><div class="line">  console.log(&apos;2-1&apos;);</div><div class="line">  yield next;</div><div class="line">  console.log(&apos;2-2&apos;);</div><div class="line">&#125;);</div><div class="line">app.listen(3000);</div><div class="line"></div><div class="line">// 1-1</div><div class="line">// 2-1</div><div class="line">// 2-2</div><div class="line">// 1-2</div></pre></td></tr></table></figure>
<p>上面代码加了两个中间件，执行过程是：</p>
<p>每一个请求到达服务器后初始化请求上下文对象，然后按照中间件添加的顺序，一个一个执行：</p>
<ul>
<li>执行中间件1，next之前的逻辑</li>
<li><p>next</p>
<ul>
<li>执行中间2的逻辑</li>
</ul>
</li>
<li><p>执行中间件1，next之后的逻辑</p>
</li>
</ul>
<p>其他的过程都是模拟上面的流程。</p>
<h2 id="koa的方法"><a href="#koa的方法" class="headerlink" title="koa的方法"></a>koa的方法</h2><p>koa有公共方法use／listen，私有方法callback等；</p>
<p>其中use是添加中间件，listen是创建服务、监听端口，callback初始化中间件形成闭包并返回网络请求到达时的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">app.use = function(fn)&#123;</div><div class="line">  this.middleware.push(fn);</div><div class="line">  return this;</div><div class="line">&#125;;</div><div class="line">app.listen = function() &#123;</div><div class="line">  var server = http.createServer(this.callback());</div><div class="line">  return server.listen.apply(server, arguments);</div><div class="line">&#125;;</div><div class="line">app.callback = function()&#123;</div><div class="line">  var fn = co.wrap(compose(this.middleware))</div><div class="line">  var self = this;</div><div class="line">  </div><div class="line">  return function handleRequest(req, res)&#123;</div><div class="line">    res.statusCode = 404;</div><div class="line">    var ctx = self.createContext(req, res);</div><div class="line">    onFinished(res, ctx.onerror);</div><div class="line">    fn.call(ctx).then(function handleResponse() &#123;</div><div class="line">      respond.call(ctx);</div><div class="line">    &#125;).catch(ctx.onerror);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="koa实现原理"><a href="#koa实现原理" class="headerlink" title="koa实现原理"></a>koa实现原理</h2><p>其实koa中间件调用过程实现原理就是根据之前写过一篇文章<a href="http://cauil.github.io/2017/10/29/2017-10-19-JS%E4%B9%8B%E5%BC%82%E6%AD%A51/">JS之异步1</a>中讲述的异步生成器。</p>
<p>但是koa实现有所不同，koa采用的是根据promise来实现；一步一步看看上面关键<code>callback</code>做了什么工作；</p>
<h4 id="co-wrap"><a href="#co-wrap" class="headerlink" title="co.wrap"></a>co.wrap</h4><p>上面关键代码<code>var fn = co.wrap(compose(this.middleware))</code>实现中间件的封装，其中<code>co.warp</code>其实就是返回一个函数，这个返回函数的函数体是把fn执行得到的结果作为参数传入co并执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">co.wrap = function (fn) &#123;</div><div class="line">  return createPromise;</div><div class="line">  function createPromise() &#123;</div><div class="line">    return co.call(this, fn.apply(this, arguments));</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h4><p>其中<code>compose(this.middleware)</code>实现的是一个迭代器的嵌套调用（这里有个背景知识，生成器函数执行是生成一个迭代器，也就是就是<code>middleware[i].call</code>的结果）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function compose(middleware)&#123;</div><div class="line">  return function *(next)&#123;</div><div class="line">    if (!next) next = noop();</div><div class="line"></div><div class="line">    var i = middleware.length;</div><div class="line"></div><div class="line">    while (i--) &#123;</div><div class="line">      next = middleware[i].call(this, next);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return yield *next;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行compose实际生成的可以看作返回了一个异步函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">*function() &#123;</div><div class="line">  return yield * itor1(itor2(itor3))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个异步函数其实就是传入到co.wrap中的参数fn</p>
<h4 id="再看最后一个关键函数co"><a href="#再看最后一个关键函数co" class="headerlink" title="再看最后一个关键函数co"></a>再看最后一个关键函数co</h4><p>co其实就是实现koa’剥洋葱’执行流程的执行体；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">function co(gen) &#123;</div><div class="line">  var ctx = this;</div><div class="line">  var args = slice.call(arguments, 1)</div><div class="line"></div><div class="line">  return new Promise(function(resolve, reject) &#123;</div><div class="line">    if (typeof gen === &apos;function&apos;) gen = gen.apply(ctx, args);</div><div class="line">    if (!gen || typeof gen.next !== &apos;function&apos;) return resolve(gen);</div><div class="line"></div><div class="line">    onFulfilled();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param &#123;Mixed&#125; res</div><div class="line">     * @return &#123;Promise&#125;</div><div class="line">     * @api private</div><div class="line">     */</div><div class="line"></div><div class="line">    function onFulfilled(res) &#123;</div><div class="line">      var ret;</div><div class="line">      try &#123;</div><div class="line">        ret = gen.next(res);</div><div class="line">      &#125; catch (e) &#123;</div><div class="line">        return reject(e);</div><div class="line">      &#125;</div><div class="line">      next(ret);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param &#123;Error&#125; err</div><div class="line">     * @return &#123;Promise&#125;</div><div class="line">     * @api private</div><div class="line">     */</div><div class="line"></div><div class="line">    function onRejected(err) &#123;</div><div class="line">      var ret;</div><div class="line">      try &#123;</div><div class="line">        ret = gen.throw(err);</div><div class="line">      &#125; catch (e) &#123;</div><div class="line">        return reject(e);</div><div class="line">      &#125;</div><div class="line">      next(ret);</div><div class="line">    &#125;</div><div class="line">    function next(ret) &#123;</div><div class="line">      if (ret.done) return resolve(ret.value);</div><div class="line">      var value = toPromise.call(ctx, ret.value);</div><div class="line">      if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);</div><div class="line">      return onRejected(new TypeError(&apos;You may only yield a function, promise, generator, array, or object, &apos;</div><div class="line">        + &apos;but the following object was passed: &quot;&apos; + String(ret.value) + &apos;&quot;&apos;));</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当co执行的时候，迭代器gen被传入，gen的值为上面compose生成的异步函数执行得到的迭代器，为啥是迭代器，因为co执行的时候，传入的是fn.call(…); </p>
<p>再回顾一下compose生成的异步函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">\*function() &#123;</div><div class="line">  return yield * itor1(itor2(itor3))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>co执行过程：</p>
<ol>
<li>返回一个promise，promise中包括的执行流程是：</li>
<li>如果gen是普通函数，直接执行；如果gen是不为空的值并且gen.next不为function也就是说gen不是迭代器，直接返回resolve(), 这个实际是co返回promise的resolve，也就是总的出口；</li>
<li>gen是迭代器，执行gen.next()，也就是会执行<code>yield * itor1(itor2(noop_itor))</code>，<strong>yield *实际上是委托生成器; 会直接执行到itor1第一个yield next处</strong>；并且此时gen.next()得到ret；<strong>并且ret.value就是next的值，也就是itor1的传入的实参itor2(itor3);</strong></li>
<li>我们快要接近剥洋葱的流程了，只要itor2重复前面的流程，怎么实现呢，实际就是toPromise的工作了，且看next(ret)；</li>
<li>next函数中：如果ret.done === true, 直接退出, 这也是一个出口；否则把ret.value转换为promise对象，当ret.value是一个迭代器的时候，toPromise主要工作是重复co.call(this, ret.value); <strong> 这样就重复的执行每个中间件的yield next前面的代码，直到执行到noop并层层返回；这实际有点类似二叉树的先序遍历过程；</strong></li>
<li>最后会回到第一次返回promise的函数中，并且resolve，这样就可以执行<code>fn.call(ctx).then(function handleResponse() {respond.call(ctx);}).catch(ctx.onerror);</code>的then处理了，否则catch处理；</li>
<li>自此一个网络请求后的中间件处理完毕；</li>
</ol>
<h4 id="总执行过程"><a href="#总执行过程" class="headerlink" title="总执行过程"></a>总执行过程</h4><ul>
<li>请求到来</li>
<li>…</li>
<li>执行fn.call(ctx)，实际上就是执行<code>co.wrap(compose(this.middleware)).call(ctx)</code>, 而<code>co.wrap(...).call(ctx)</code>实际就是上面的co函数的执行过程；</li>
<li>中间件处理完毕, 然后执行respond.call(ctx);</li>
</ul>
<h2 id="koa的上下文"><a href="#koa的上下文" class="headerlink" title="koa的上下文"></a>koa的上下文</h2><p>koa服务每当一个新的网络请求来临的时候会生成一个新的上下文，也就是代码中的多次出现的ctx；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var ctx = self.createContext(req, res);</div><div class="line">app.createContext = function(req, res)&#123;</div><div class="line">  var context = Object.create(this.context);</div><div class="line">  var request = context.request = Object.create(this.request);</div><div class="line">  var response = context.response = Object.create(this.response);</div><div class="line">  context.app = request.app = response.app = this;</div><div class="line">  context.req = request.req = response.req = req;</div><div class="line">  context.res = request.res = response.res = res;</div><div class="line">  request.ctx = response.ctx = context;</div><div class="line">  request.response = response;</div><div class="line">  response.request = request;</div><div class="line">  context.onerror = context.onerror.bind(context);</div><div class="line">  context.originalUrl = request.originalUrl = req.url;</div><div class="line">  context.cookies = new Cookies(req, res, &#123;</div><div class="line">    keys: this.keys,</div><div class="line">    secure: request.secure</div><div class="line">  &#125;);</div><div class="line">  context.accept = request.accept = accepts(req);</div><div class="line">  context.state = &#123;&#125;;</div><div class="line">  return context;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个context是以koa的实例服务app.context为原型，并且对ctx(即context)的属性request、response也设计了原型，这有什么用处呢？</p>
<p>实际上我们获取ctx.header、ctx.method或者设置ctx.method等的值，就是通过这里来的；举一个例子，获取ctx.header</p>
<ul>
<li>1 ctx中没有，从原型app.context中寻找</li>
<li><p>2 app.context从静态类context中寻找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Application() &#123;</div><div class="line">  if (!(this instanceof Application)) return new Application;</div><div class="line">  ...</div><div class="line">  **this.context = Object.create(context);**</div><div class="line">  this.request = Object.create(request);</div><div class="line">  this.response = Object.create(response);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>3 context中的header代理了request静态类的属性header；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">delegate(proto, &apos;request&apos;)</div><div class="line">  .method(&apos;acceptsLanguages&apos;)</div><div class="line">  ... // 省略</div><div class="line">  .getter(&apos;header&apos;)</div><div class="line">  ...</div><div class="line">  .getter(&apos;ip&apos;);</div><div class="line"></div><div class="line">Delegator.prototype.getter = function(name)&#123;</div><div class="line">  var proto = this.proto;</div><div class="line">  var target = this.target;</div><div class="line">  this.getters.push(name);</div><div class="line"></div><div class="line">  proto.__defineGetter__(name, function()&#123;</div><div class="line">    return this[target][name];</div><div class="line">  &#125;);</div><div class="line">  return this;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>4 也就是ctx[‘request’][‘header’]</p>
</li>
<li><p>5 寻找ctx[‘request’][‘header’]也就是从ctx[‘request’]的原型app.request寻找，接着到静态类request中寻找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">get header() &#123;</div><div class="line">  return this.req.headers;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
</li>
<li><p>6 也就是return ctx.request.req.headers, 其中ctx.request.req实际就是网络请求传入的req对象</p>
</li>
<li>7 获取header成功</li>
</ul>
<p>koa利用原型链查找、委托代理等手段，设置了很多方面快捷的属性获取、属性设置和方法调用；</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文讲述了下面几方面内容：</p>
<ul>
<li>koa简单使用</li>
<li>koa中间件执行过程</li>
<li>koa中间件执行原理</li>
<li>koa上下文ctx</li>
<li>koa快捷过程</li>
</ul>
<p>不过koa也有不足之处，如果上层中间件设置了多次yield next，虽然后面的迭代器已经执行到<code>done:true</code>，但每次重新到下层中间件也是一种不必要的开销；koa1的代码也比较繁杂，理解起来比较困难；不过这些koa2都有所改善，koa2见。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/12/01/2017-12-01-vue之mergeOptions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/01/2017-12-01-vue之mergeOptions/" itemprop="url">Vue之mergeOptions</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-01T00:00:00+08:00">
                2017-12-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>new Vue(options)</code>中首先处理的是下面一段代码, 这次就剖析这一段代码;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">if (options &amp;&amp; options._isComponent) &#123;</div><div class="line">  // optimize internal component instantiation</div><div class="line">  // since dynamic options merging is pretty slow, and none of the</div><div class="line">  // internal component options needs special treatment.</div><div class="line">  initInternalComponent(vm, options)</div><div class="line">&#125; else &#123;</div><div class="line">  vm.$options = mergeOptions(</div><div class="line">    resolveConstructorOptions(vm.constructor),</div><div class="line">    options || &#123;&#125;,</div><div class="line">    vm</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="初始化vm-option"><a href="#初始化vm-option" class="headerlink" title="初始化vm.$option"></a>初始化vm.$option</h2><p>上面代码主要目的就是初始化vm.$option. 其中逻辑很简单，如果传入的option是一个组件，执行initInternalComponent, 否则执行mergeOptions;</p>
<h3 id="initInternalComponent"><a href="#initInternalComponent" class="headerlink" title="initInternalComponent"></a>initInternalComponent</h3><p>initInternalComponent非常简单，就是以Vue.options为原型创建vm.$options, 并把options中的属性复制到vm.$options;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">const opts = vm.$options = Object.create(vm.constructor.options)</div><div class="line">// doing this because it&apos;s faster than dynamic enumeration.</div><div class="line">opts.parent = options.parent</div><div class="line">opts.propsData = options.propsData</div><div class="line">opts._parentVnode = options._parentVnode</div><div class="line">opts._parentListeners = options._parentListeners</div><div class="line">opts._renderChildren = options._renderChildren</div><div class="line">opts._componentTag = options._componentTag</div><div class="line">opts._parentElm = options._parentElm</div><div class="line">opts._refElm = options._refElm</div><div class="line">if (options.render) &#123;</div><div class="line">  opts.render = options.render</div><div class="line">  opts.staticRenderFns = options.staticRenderFns</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="mergeOptions"><a href="#mergeOptions" class="headerlink" title="mergeOptions"></a>mergeOptions</h3><p>mergeOptions接受三个参数，这个方法比较复杂; 首先接受三个参数</p>
<p><code>[parent, child, vm] = [resolveConstructorOptions(vm.constructor), options || {}, vm]</code></p>
<p>其中parent为resolveConstructorOptions(vm.constructor), 得到结果为Vue.options;child跟vm没什么说的；我们来看看mergeOptions做了什么；</p>
<p>具体代码在<a href="https://github.com/vuejs/vue/blob/94512f3e8cee4030a1096121700ed49afab48073/src/core/util/options.js#L300" target="_blank" rel="external">github这里</a>; 主要逻辑是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">normalizeProps(child)</div><div class="line">normalizeInject(child)</div><div class="line">normalizeDirectives(child)</div><div class="line">const extendsFrom = child.extends</div><div class="line">if (extendsFrom) &#123;</div><div class="line">  parent = mergeOptions(parent, extendsFrom, vm)</div><div class="line">&#125;</div><div class="line">if (child.mixins) &#123;</div><div class="line">  for (let i = 0, l = child.mixins.length; i &lt; l; i++) &#123;</div><div class="line">    parent = mergeOptions(parent, child.mixins[i], vm)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">const options = &#123;&#125;</div><div class="line">let key</div><div class="line">for (key in parent) &#123;</div><div class="line">  mergeField(key)</div><div class="line">&#125;</div><div class="line">for (key in child) &#123;</div><div class="line">  if (!hasOwn(parent, key)) &#123;</div><div class="line">    mergeField(key)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="其中normalizeProps-normalizeInject-normalizeDirectives主要是格式化对象；"><a href="#其中normalizeProps-normalizeInject-normalizeDirectives主要是格式化对象；" class="headerlink" title="其中normalizeProps/normalizeInject/normalizeDirectives主要是格式化对象；"></a>其中normalizeProps/normalizeInject/normalizeDirectives主要是格式化对象；</h4><p>normalizeProps主要是把options中的props格式化为如下对象 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[&apos;bad-name&apos;, &apos;goodName&apos;]                                         // Array</div><div class="line">// =&gt;</div><div class="line">&#123;badName: &#123;type: null&#125;, goodName: &#123;type: null&#125;&#125;</div><div class="line"></div><div class="line">&#123;badName: &#123;type: &apos;String&apos;, default: &apos;hi&apos;&#125;, &apos;good-name&apos;: &apos;String&apos;&#125;  // Object</div><div class="line">// =&gt;</div><div class="line">&#123;badName: &#123;type: &quot;String&quot;, default: &quot;hi&quot;&#125;, goodName: &#123;type: &quot;String&quot;&#125;&#125;</div></pre></td></tr></table></figure>
<p>normalizeProps主要是把options中的inject格式化为如下对象:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[&apos;test&apos;, &apos;test1&apos;]</div><div class="line">// =&gt; </div><div class="line">&#123;test: &#123;from: &apos;test&apos;&#125;, test1: &#123;from: &apos;test1&apos;&#125;&#125;</div><div class="line"></div><div class="line">&#123;test: &apos;hello&apos;, test1: &#123;name: &apos;hi&apos;&#125;&#125;</div><div class="line">// =&gt;</div><div class="line">&#123;test: &#123;from: &quot;hello&quot;&#125;, test1: &#123;from: &quot;test1&quot;, name: &quot;hi&quot;&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>normalizeDirectives主要是把options中的directives格式化为如下对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">directives: &#123;</div><div class="line">    hello: function() &#123;console.log(&apos;hi&apos;)&#125;, // function</div><div class="line">    hi: &apos;test&apos;</div><div class="line">&#125;</div><div class="line">// =&gt;</div><div class="line">directives: &#123;</div><div class="line">    hello: &#123;bind: function() &#123;console.log(&apos;hi&apos;)&#125;, update: function() &#123;console.log(&apos;hi&apos;)&#125; &#125;,</div><div class="line">    hi: &apos;test&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="extend与mixins"><a href="#extend与mixins" class="headerlink" title="extend与mixins"></a>extend与mixins</h4><p>接下来的代码其实是vue的混合用法，这里有<a href="https://cn.vuejs.org/v2/guide/mixins.html#全局混合" target="_blank" rel="external">官方文档-混合</a>描述;<br>由于mixins与extend用法一致，只对mixins讲述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (child.mixins) &#123;</div><div class="line">  for (let i = 0, l = child.mixins.length; i &lt; l; i++) &#123;</div><div class="line">    parent = mergeOptions(parent, child.mixins[i], vm)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码其实是递归调用mergeOptions, 并把mixins的内容递归处理到parent对象中；</p>
<p>接着初始化一个空对象{}这里我们记做obj, 并遍历parent里的key，mergeField到options中;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function mergeField (key) &#123;</div><div class="line">  var strat = strats[key] || defaultStrat;</div><div class="line">  options[key] = strat(parent[key], child[key], vm, key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>mergeField是一个多态函数，根据传递的key值不同，parent与child合并的方式不同：</p>
<ul>
<li>如果key是<code>el</code>或者<code>propsData</code>时:  <code>obj[key] = child[key] === undefined ? parent[key] : child[key]</code></li>
<li>如果key是<code>data</code>, 则递归的一层一层把所有的parent不存在的数据复制到child</li>
<li><p>如果key是vue实例的生命周期, 则<code>obj[key] = parent[key].concat(child[key])</code></p>
<p><code>beforeCreate, created, beforeMount, mounted, beforeUpdate, updated, beforeDestroy, destroyed, activated, deactivated</code></p>
</li>
<li><p>如果key是<code>components, directives, filters</code>这些key值，则</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const res = Object.create(parent[ke] || null)</div><div class="line">return child[key] ? extend(res, child[ke]) : res</div></pre></td></tr></table></figure>
</li>
<li><p>如果key是watch,与生命周期类似</p>
</li>
<li>如果key是<code>prosp/methods/inject/computed</code>时，与componets类似；</li>
</ul>
<p>也即：</p>
<ol>
<li>key值为生命周期或者watch时，同名钩子函数将混合为一个数组，因此都将被调用。另外，混合对象的钩子将在组件自身钩子之前调用. </li>
<li>当为<code>prosp/methods/inject/computed/components/directives/filters</code>时，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。</li>
</ol>
<p>如下面一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">var mixin = &#123;</div><div class="line">  created: function () &#123;</div><div class="line">    console.log(&apos;混合对象的钩子被调用&apos;)</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    foo: function () &#123;</div><div class="line">      console.log(&apos;foo&apos;)</div><div class="line">    &#125;,</div><div class="line">    conflicting: function () &#123;</div><div class="line">      console.log(&apos;from mixin&apos;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">var vm = new Vue(&#123;</div><div class="line">  mixins: [mixin],</div><div class="line">  created: function () &#123;</div><div class="line">    console.log(&apos;组件钩子被调用&apos;)</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    bar: function () &#123;</div><div class="line">      console.log(&apos;bar&apos;)</div><div class="line">    &#125;,</div><div class="line">    conflicting: function () &#123;</div><div class="line">      console.log(&apos;from self&apos;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// =&gt; &quot;混合对象的钩子被调用&quot;</div><div class="line">// =&gt; &quot;组件钩子被调用&quot;</div><div class="line"></div><div class="line">vm.foo() // =&gt; &quot;foo&quot;</div><div class="line">vm.bar() // =&gt; &quot;bar&quot;</div><div class="line">vm.conflicting() // =&gt; &quot;from self&quot;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面的所有步骤就是初始化传入的options中的一些对象, 并把混合的mixins和extend合并起来，最后赋值给vue实例的$options.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/30/2017-11-30-Vue之实例化流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/30/2017-11-30-Vue之实例化流程/" itemprop="url">Vue实例化过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-30T00:00:00+08:00">
                2017-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>vue是一个灵活渐进的mvvm框架，其实际内容可以用 <code>UI=f(State)</code>这个公式来表示。</p>
<p>今天第一篇关于vue的剖析，从其实例化的过程来展开。</p>
<h2 id="vue实例化"><a href="#vue实例化" class="headerlink" title="vue实例化"></a>vue实例化</h2><p>vue核心是声明式渲染，其初始化的实例为后面的过程准备了各种条件，看下面一段简单的vue例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">  &#123;&#123; message &#125;&#125;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">var app = new Vue(&#123;</div><div class="line">  el: &apos;#app&apos;,</div><div class="line">  data: &#123;</div><div class="line">    message: &apos;Hello Vue!&apos;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>第一段代码是要初始化的template，第二段是实例的真正初始化内容，最终template会被渲染成<code>Hello Vue!</code>；</p>
<p>那当执行<code>new Vue(options)</code>时里面到底执行了什么？</p>
<h2 id="实例化流程"><a href="#实例化流程" class="headerlink" title="实例化流程"></a>实例化流程</h2><p>实际<code>new Vue(options)</code>是调用了<code>Vue.prototype._init</code>方法:</p>
<p>主要流程有：</p>
<h4 id="merge-options"><a href="#merge-options" class="headerlink" title="merge options"></a>merge options</h4><p>第一个流程先简单剖析下，流程过程主要是初始化实例vm的$options, 把构造函数<code>Vue.options({components:..., directives:..., filters:..., _base:...})</code>和options合并赋值给vm.$options;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">if (options &amp;&amp; options._isComponent) &#123;</div><div class="line">  // optimize internal component instantiation</div><div class="line">  // since dynamic options merging is pretty slow, and none of the</div><div class="line">  // internal component options needs special treatment.</div><div class="line">  initInternalComponent(vm, options);</div><div class="line">&#125; else &#123;</div><div class="line">  vm.$options = mergeOptions(</div><div class="line">    resolveConstructorOptions(vm.constructor),</div><div class="line">    options || &#123;&#125;,</div><div class="line">    vm</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="设置代理initProxy-vm"><a href="#设置代理initProxy-vm" class="headerlink" title="设置代理initProxy(vm)"></a>设置代理initProxy(vm)</h4><h4 id="初始化声明周期initLifecycle-vm"><a href="#初始化声明周期initLifecycle-vm" class="headerlink" title="初始化声明周期initLifecycle(vm)"></a>初始化声明周期initLifecycle(vm)</h4><p>主要是初始化与vm声明周期有关的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">vm.$parent = parent;</div><div class="line">vm.$root = parent ? parent.$root : vm;</div><div class="line"></div><div class="line">vm.$children = [];</div><div class="line">vm.$refs = &#123;&#125;;</div><div class="line"></div><div class="line">vm._watcher = null;</div><div class="line">vm._inactive = null;</div><div class="line">vm._directInactive = false;</div><div class="line">vm._isMounted = false;</div><div class="line">vm._isDestroyed = false;</div><div class="line">vm._isBeingDestroyed = false;</div></pre></td></tr></table></figure>
<h4 id="initEvents-vm"><a href="#initEvents-vm" class="headerlink" title="initEvents(vm)"></a>initEvents(vm)</h4><p>初始化事件属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vm._events = Object.create(null);</div><div class="line">vm._hasHookEvent = false;</div></pre></td></tr></table></figure>
<h4 id="initRender-vm"><a href="#initRender-vm" class="headerlink" title="initRender(vm)"></a>initRender(vm)</h4><p>初始化render的时候需要的一些属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">vm._vnode = null; // the root of the child tree</div><div class="line">vm._staticTrees = null; // v-once cached trees</div><div class="line">var options = vm.$options;</div><div class="line">var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree</div><div class="line">var renderContext = parentVnode &amp;&amp; parentVnode.context;</div><div class="line">vm.$slots = resolveSlots(options._renderChildren, renderContext);</div><div class="line">vm.$scopedSlots = emptyObject;</div><div class="line">// bind the createElement fn to this instance</div><div class="line">// so that we get proper render context inside it.</div><div class="line">// args order: tag, data, children, normalizationType, alwaysNormalize</div><div class="line">// internal version is used by render functions compiled from templates</div><div class="line">vm._c = function (a, b, c, d) &#123; return createElement(vm, a, b, c, d, false); &#125;;</div><div class="line">// normalization is always applied for the public version, used in</div><div class="line">// user-written render functions.</div><div class="line">vm.$createElement = function (a, b, c, d) &#123; return createElement(vm, a, b, c, d, true); &#125;;</div></pre></td></tr></table></figure>
<h4 id="callHook-vm-‘beforeCreate’"><a href="#callHook-vm-‘beforeCreate’" class="headerlink" title="callHook(vm, ‘beforeCreate’)"></a>callHook(vm, ‘beforeCreate’)</h4><p>调用‘beforeCreate’的hook函数<code>var handlers = vm.$options[hook];</code></p>
<h4 id="initInjections-vm"><a href="#initInjections-vm" class="headerlink" title="initInjections(vm)"></a>initInjections(vm)</h4><p>对vm.$options中的injections处理</p>
<h4 id="initState-vm"><a href="#initState-vm" class="headerlink" title="initState(vm)"></a>initState(vm)</h4><p>这个过程非常重要，里面吹了props／methods／data／computed等数据并初始化了依赖、watchers、deps等，是整个vm实例能够渲染并且监听数据变化的关键；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">vm._watchers = [];</div><div class="line">var opts = vm.$options;</div><div class="line">if (opts.props) &#123; initProps(vm, opts.props); &#125;</div><div class="line">if (opts.methods) &#123; initMethods(vm, opts.methods); &#125;</div><div class="line">if (opts.data) &#123;</div><div class="line">  initData(vm);</div><div class="line">&#125; else &#123;</div><div class="line">  observe(vm._data = &#123;&#125;, true /* asRootData */);</div><div class="line">&#125;</div><div class="line">if (opts.computed) &#123; initComputed(vm, opts.computed); &#125;</div><div class="line">if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</div><div class="line">  initWatch(vm, opts.watch);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="initProvide-vm"><a href="#initProvide-vm" class="headerlink" title="initProvide(vm)"></a>initProvide(vm)</h4><p><code>var provide = vm.$options.provide;</code></p>
<h4 id="callHook-vm-‘created’"><a href="#callHook-vm-‘created’" class="headerlink" title="callHook(vm, ‘created’)"></a>callHook(vm, ‘created’)</h4><p>调用‘created’的hook函数<code>var handlers = vm.$options[hook];</code></p>
<h4 id="vm-mount-vm-options-el"><a href="#vm-mount-vm-options-el" class="headerlink" title="vm.$mount(vm.$options.el)"></a>vm.$mount(vm.$options.el)</h4><p>这个是初始化vue实例的最后一步，把虚拟dom挂载到option.el(即’#app’)中；</p>
<p><strong>以上就是vue实例化的所有流程，本文并没有介绍各个流程的详细处理过程，在后续文章中会一一展开。</strong></p>
<h2 id="vue实例生命周期"><a href="#vue实例生命周期" class="headerlink" title="vue实例生命周期"></a>vue实例生命周期</h2><p>从上面流程中，其实可以看出一些实例生命周期的过程：</p>
<p><img src="/images/vuelifecycle.png" alt="声明周期"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/27/2017-11-26-ES之Promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/27/2017-11-26-ES之Promise/" itemprop="url">ES6之Promise</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-27T00:00:00+08:00">
                2017-11-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Promise基础知识"><a href="#Promise基础知识" class="headerlink" title="Promise基础知识"></a>Promise基础知识</h2><p>Promise相当于异步操作结果的占位符，它不会去订阅一个事件，也不会传递一个回调函数给目标函数，而是让函数返回一个Promise：</p>
<p><code>let promise = readFile(&#39;example.txt&#39;)</code></p>
<p> 上例子中，readFile不会立即开始读取文件，函数会返回一个表示异步读取操作的Promise对象，未来对这个对象的操作完全取决于Promise的声明周期。</p>
<h4 id="Promise生命周期"><a href="#Promise生命周期" class="headerlink" title="Promise生命周期"></a>Promise生命周期</h4><p> 生命周期有三个：pending、fullfilled、rejected</p>
<p> 所有promise都有then方法，它接受两个参数：第一个当Promise的状态变为fullfilled时要调用的函数，与异步操作相关的附加数据都会传递给这个完成函数；第二个是当Promise的状态变为rejected时要调用的函数，其与完成时调用的函数类似，所有与失败相关的附加数据都会传递这个拒绝函数；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let promise = readFile(&quot;example.txt&quot;);</div><div class="line">promise.then(function(contents) &#123;</div><div class="line">    // fulfillment</div><div class="line">    console.log(contents);</div><div class="line">&#125;, function(err) &#123;</div><div class="line">// rejection</div><div class="line">    console.error(err.message);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>如果一个对象实现了上面的then方法，那这个对象我们称之为thenable对象。所有的Promise对象都是thenable对象，但并非所有thenable对象都是Promise。</strong></p>
<p>Promise被解决（resolved）时执行，这些任务最终会被加入到一个为Promise量身定制的独立队列中，而不会立即执行，当前面的任务完成后其才被调用；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var p = new Promise(function(resolve, reject)&#123;resolve()&#125;);</div><div class="line">p.then(function()&#123;console.log(&apos;do&apos;)&#125;);</div><div class="line">console.log(&apos;do1&apos;);</div><div class="line">// do1</div><div class="line">// do</div></pre></td></tr></table></figure>
<h4 id="创建未完成的Promise"><a href="#创建未完成的Promise" class="headerlink" title="创建未完成的Promise"></a>创建未完成的Promise</h4><p>Promise的执行器会立即执行，然后执行后续流程中的代码;当Promise resolved之后会把任务加入到任务队列尾部，即调用resolve()后出触发一个异步操作，传入then和catch方法的函数会被添加到任务队列中并异步执行；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let promise = new Promise(function(resolve, reject) &#123;</div><div class="line">  console.log(&apos;Promise&apos;);</div><div class="line">  resolve();</div><div class="line">&#125;);</div><div class="line">promise.then(function() &#123;</div><div class="line">    console.log(&quot;Resolved.&quot;);</div><div class="line">&#125;);</div><div class="line">console.log(&quot;HI!&quot;);</div><div class="line">// &apos;Promise&apos;</div><div class="line">// HI!</div><div class="line">// Resolved</div></pre></td></tr></table></figure>
<h4 id="创建已处理的Promise"><a href="#创建已处理的Promise" class="headerlink" title="创建已处理的Promise"></a>创建已处理的Promise</h4><p>Promise.resolve() / Promise.reject()</p>
<p>除了上面的方法直接创建已处理的Promise；Promise的resolve和reject方法还可以接受非Promise的Thenable对象作为参数。如果传入非Promise的Thenable对象，则这些方法会创建一个新的Promise，并在then函数中被调用；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let thenable = &#123;</div><div class="line">    then: function(resolve, reject) &#123;</div><div class="line">        resolve(42);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">let p1 = Promise.resolve(thenable);</div><div class="line">p1.then(function(value) &#123;</div><div class="line">    console.log(value);     // 42</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="全局的Promise拒绝处理"><a href="#全局的Promise拒绝处理" class="headerlink" title="全局的Promise拒绝处理"></a>全局的Promise拒绝处理</h2><p>为了防止有些没有拒绝处理的promise的错误被忽略掉，可以用全局的Promise拒绝处理。</p>
<h4 id="浏览器环境的拒绝处理"><a href="#浏览器环境的拒绝处理" class="headerlink" title="浏览器环境的拒绝处理"></a>浏览器环境的拒绝处理</h4><p>浏览器有两个事件来识别未处理的拒绝的；</p>
<ul>
<li>unhandledrejection 在一个事件循环中，当Promise被拒绝，并且没有提供拒绝处理程序时，触发该事件</li>
<li>rejecttionhandled 在一个事件循环后，当Promise被拒绝时，若拒绝处理程序被调用，触发该事件；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let rejected;</div><div class="line">window.onunhandledrejection = function(event) &#123;</div><div class="line">    console.log(event.type); // &quot;unhandledrejection&quot;</div><div class="line">    console.log(event.reason.message); // &quot;Explosion!&quot;</div><div class="line">    console.log(rejected === event.promise); // true</div><div class="line">&#125;;</div><div class="line">window.onrejectionhandled = function(event) &#123;</div><div class="line">    console.log(event.type); // &quot;rejectionhandled&quot;</div><div class="line">    console.log(event.reason.message); // &quot;Explosion!&quot;</div><div class="line">    console.log(rejected === event.promise); // true</div><div class="line">&#125;;</div><div class="line">rejected = Promise.reject(new Error(&quot;Explosion!&quot;));</div></pre></td></tr></table></figure>
<h2 id="串联Promise"><a href="#串联Promise" class="headerlink" title="串联Promise"></a>串联Promise</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let p1 = new Promise(function(resolve, reject) &#123;</div><div class="line">                 resolve(42);</div><div class="line">&#125;);</div><div class="line">p1.then(function(value) &#123;</div><div class="line">    console.log(value);</div><div class="line">&#125;).then(function() &#123;</div><div class="line">    console.log(&quot;Finished&quot;);</div><div class="line">&#125;);</div><div class="line">// 42</div><div class="line">// Finished</div></pre></td></tr></table></figure>
<p><strong>务必在Promise链的末尾留一个有拒绝处理程序保证能够正确处理所有可能发生的错误。</strong></p>
<h4 id="Promise链的返回值"><a href="#Promise链的返回值" class="headerlink" title="Promise链的返回值"></a>Promise链的返回值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let p1 = new Promise(function(resolve, reject) &#123;</div><div class="line">    resolve(42);</div><div class="line"> &#125;);</div><div class="line">p1.then(function(value) &#123;</div><div class="line">    console.log(value); // 42</div><div class="line">    return value + 1;</div><div class="line">&#125;).then(function(value) &#123;</div><div class="line">    console.log(value); // 43</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="在Promise链中返回Promise"><a href="#在Promise链中返回Promise" class="headerlink" title="在Promise链中返回Promise"></a>在Promise链中返回Promise</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let p1 = new Promise(function(resolve, reject) &#123;</div><div class="line">    resolve(42);</div><div class="line">&#125;);</div><div class="line">let p2 = new Promise(function(resolve, reject) &#123;</div><div class="line">    resolve(43);</div><div class="line">&#125;);</div><div class="line">p1.then(function(value) &#123;</div><div class="line">    // first fulfillment handler</div><div class="line">    console.log(value);     // 42</div><div class="line">    return p2;</div><div class="line">&#125;).then(function(value) &#123;</div><div class="line">    // second fulfillment handler</div><div class="line">    console.log(value);     // 43</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="响应多个Promise"><a href="#响应多个Promise" class="headerlink" title="响应多个Promise"></a>响应多个Promise</h2><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let p1 = new Promise(function(resolve, reject) &#123;</div><div class="line">    resolve(42);</div><div class="line">&#125;);</div><div class="line">let p2 = new Promise(function(resolve, reject) &#123;</div><div class="line">    resolve(43);</div><div class="line">&#125;);</div><div class="line">let p3 = new Promise(function(resolve, reject) &#123;</div><div class="line">    resolve(44);</div><div class="line">&#125;);</div><div class="line">let p4 = Promise.all([p1, p2, p3]);</div><div class="line">p4.then(function(value) &#123;</div><div class="line">    console.log(Array.isArray(value));  // true</div><div class="line">    console.log(value[0]); // 42</div><div class="line">    console.log(value[1]); // 43</div><div class="line">    console.log(value[2]); // 44</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
<p>拒绝处理程序总是接受一个值而非数组，改值来自被拒绝Promise的拒绝值；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let p1 = new Promise(function(resolve, reject) &#123;</div><div class="line">    resolve(42);</div><div class="line">&#125;);</div><div class="line">let p2 = new Promise(function(resolve, reject) &#123;</div><div class="line">    reject(43);</div><div class="line">&#125;);</div><div class="line">let p3 = new Promise(function(resolve, reject) &#123;</div><div class="line">    resolve(44);</div><div class="line">&#125;);</div><div class="line">let p4 = Promise.all([p1, p2, p3]);</div><div class="line">p4.catch(function(value) &#123;</div><div class="line">    console.log(Array.isArray(value))   // false</div><div class="line">    console.log(value);                 // 43</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>race方法监听多个Promise，只要有一个Promise被解决，整个race就被解决；如果选解决的是已完成Promise，则返回已完成Promise，如果被解决的是已拒绝Promise，返回的是已拒绝Promise：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let p1 = new Promise(function(resolve, reject) &#123;</div><div class="line">    resolve(42);</div><div class="line">&#125;);</div><div class="line">let p2 = Promise.reject(43);</div><div class="line">let p3 = new Promise(function(resolve, reject) &#123;</div><div class="line">    resolve(44);</div><div class="line">&#125;);</div><div class="line">let p4 = Promise.race([p1, p2, p3]);</div><div class="line">p4.catch(function(value) &#123;</div><div class="line">    console.log(value);     // 43</div><div class="line">&#125;);</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/abu.jpg"
                alt="cauil" />
            
              <p class="site-author-name" itemprop="name">cauil</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/cauil" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/cauil" target="_blank" title="Weibo">
                    
                      <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://douban.com/people/cauil" target="_blank" title="DouBan">
                    
                      <i class="fa fa-fw fa-douban"></i>DouBan</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cauil</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
