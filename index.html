<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Cauil&#39;s Blog">
<meta property="og:url" content="http://cauil.github.io/index.html">
<meta property="og:site_name" content="Cauil&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cauil&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://cauil.github.io/"/>





  <title>Cauil's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cauil's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">陌上花开，可缓缓归矣</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/12/25/2017-12-25-koa1探秘/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/25/2017-12-25-koa1探秘/" itemprop="url">koa1探秘</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-25T00:00:00+08:00">
                2017-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/node/" itemprop="url" rel="index">
                    <span itemprop="name">node</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>掌握这些背景知识对理解koa1源码有帮助：</p>
<ul>
<li>原型链查找 闭包 高阶函数(返回函数的函数) getter/setter call/apply</li>
<li>代理委托</li>
<li>promise 异步函数 迭代器 委托生成器(yield *)</li>
<li>co模块处理</li>
<li>node http模块</li>
</ul>
<h2 id="koa使用"><a href="#koa使用" class="headerlink" title="koa使用"></a>koa使用</h2><p>先从koa1开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">const Koa = require(&apos;koa&apos;);</div><div class="line">const app = new Koa();</div><div class="line"></div><div class="line">// response</div><div class="line">app.use(function *() &#123;</div><div class="line">  console.log(&apos;1-1&apos;);</div><div class="line">  yield next;</div><div class="line">  console.log(&apos;1-2&apos;);</div><div class="line">&#125;);</div><div class="line">app.use(function *() &#123;</div><div class="line">  console.log(&apos;2-1&apos;);</div><div class="line">  yield next;</div><div class="line">  console.log(&apos;2-2&apos;);</div><div class="line">&#125;);</div><div class="line">app.listen(3000);</div><div class="line"></div><div class="line">// 1-1</div><div class="line">// 2-1</div><div class="line">// 2-2</div><div class="line">// 1-2</div></pre></td></tr></table></figure>
<p>上面代码加了两个中间件，执行过程是：</p>
<p>每一个请求到达服务器后初始化请求上下文对象，然后按照中间件添加的顺序，一个一个执行：</p>
<ul>
<li>执行中间件1，next之前的逻辑</li>
<li><p>next</p>
<ul>
<li>执行中间2的逻辑</li>
</ul>
</li>
<li><p>执行中间件1，next之后的逻辑</p>
</li>
</ul>
<p>其他的过程都是模拟上面的流程。</p>
<h2 id="koa的方法"><a href="#koa的方法" class="headerlink" title="koa的方法"></a>koa的方法</h2><p>koa有公共方法use／listen，私有方法callback等；</p>
<p>其中use是添加中间件，listen是创建服务、监听端口，callback初始化中间件形成闭包并返回网络请求到达时的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">app.use = function(fn)&#123;</div><div class="line">  this.middleware.push(fn);</div><div class="line">  return this;</div><div class="line">&#125;;</div><div class="line">app.listen = function() &#123;</div><div class="line">  var server = http.createServer(this.callback());</div><div class="line">  return server.listen.apply(server, arguments);</div><div class="line">&#125;;</div><div class="line">app.callback = function()&#123;</div><div class="line">  var fn = co.wrap(compose(this.middleware))</div><div class="line">  var self = this;</div><div class="line">  </div><div class="line">  return function handleRequest(req, res)&#123;</div><div class="line">    res.statusCode = 404;</div><div class="line">    var ctx = self.createContext(req, res);</div><div class="line">    onFinished(res, ctx.onerror);</div><div class="line">    fn.call(ctx).then(function handleResponse() &#123;</div><div class="line">      respond.call(ctx);</div><div class="line">    &#125;).catch(ctx.onerror);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="koa实现原理"><a href="#koa实现原理" class="headerlink" title="koa实现原理"></a>koa实现原理</h2><p>其实koa中间件调用过程实现原理就是根据之前写过一篇文章<a href="http://cauil.github.io/2017/10/29/2017-10-19-JS%E4%B9%8B%E5%BC%82%E6%AD%A51/">JS之异步1</a>中讲述的异步生成器。</p>
<p>但是koa实现有所不同，koa采用的是根据promise来实现；一步一步看看上面关键<code>callback</code>做了什么工作；</p>
<h4 id="co-wrap"><a href="#co-wrap" class="headerlink" title="co.wrap"></a>co.wrap</h4><p>上面关键代码<code>var fn = co.wrap(compose(this.middleware))</code>实现中间件的封装，其中<code>co.warp</code>其实就是返回一个函数，这个返回函数的函数体是把fn执行得到的结果作为参数传入co并执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">co.wrap = function (fn) &#123;</div><div class="line">  return createPromise;</div><div class="line">  function createPromise() &#123;</div><div class="line">    return co.call(this, fn.apply(this, arguments));</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h4><p>其中<code>compose(this.middleware)</code>实现的是一个迭代器的嵌套调用（这里有个背景知识，生成器函数执行是生成一个迭代器，也就是就是<code>middleware[i].call</code>的结果）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function compose(middleware)&#123;</div><div class="line">  return function *(next)&#123;</div><div class="line">    if (!next) next = noop();</div><div class="line"></div><div class="line">    var i = middleware.length;</div><div class="line"></div><div class="line">    while (i--) &#123;</div><div class="line">      next = middleware[i].call(this, next);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return yield *next;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行compose实际生成的可以看作返回了一个异步函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">*function() &#123;</div><div class="line">  return yield * itor1(itor2(itor3))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个异步函数其实就是传入到co.wrap中的参数fn</p>
<h4 id="再看最后一个关键函数co"><a href="#再看最后一个关键函数co" class="headerlink" title="再看最后一个关键函数co"></a>再看最后一个关键函数co</h4><p>co其实就是实现koa’剥洋葱’执行流程的执行体；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">function co(gen) &#123;</div><div class="line">  var ctx = this;</div><div class="line">  var args = slice.call(arguments, 1)</div><div class="line"></div><div class="line">  return new Promise(function(resolve, reject) &#123;</div><div class="line">    if (typeof gen === &apos;function&apos;) gen = gen.apply(ctx, args);</div><div class="line">    if (!gen || typeof gen.next !== &apos;function&apos;) return resolve(gen);</div><div class="line"></div><div class="line">    onFulfilled();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param &#123;Mixed&#125; res</div><div class="line">     * @return &#123;Promise&#125;</div><div class="line">     * @api private</div><div class="line">     */</div><div class="line"></div><div class="line">    function onFulfilled(res) &#123;</div><div class="line">      var ret;</div><div class="line">      try &#123;</div><div class="line">        ret = gen.next(res);</div><div class="line">      &#125; catch (e) &#123;</div><div class="line">        return reject(e);</div><div class="line">      &#125;</div><div class="line">      next(ret);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param &#123;Error&#125; err</div><div class="line">     * @return &#123;Promise&#125;</div><div class="line">     * @api private</div><div class="line">     */</div><div class="line"></div><div class="line">    function onRejected(err) &#123;</div><div class="line">      var ret;</div><div class="line">      try &#123;</div><div class="line">        ret = gen.throw(err);</div><div class="line">      &#125; catch (e) &#123;</div><div class="line">        return reject(e);</div><div class="line">      &#125;</div><div class="line">      next(ret);</div><div class="line">    &#125;</div><div class="line">    function next(ret) &#123;</div><div class="line">      if (ret.done) return resolve(ret.value);</div><div class="line">      var value = toPromise.call(ctx, ret.value);</div><div class="line">      if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);</div><div class="line">      return onRejected(new TypeError(&apos;You may only yield a function, promise, generator, array, or object, &apos;</div><div class="line">        + &apos;but the following object was passed: &quot;&apos; + String(ret.value) + &apos;&quot;&apos;));</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当co执行的时候，迭代器gen被传入，gen的值为上面compose生成的异步函数执行得到的迭代器，为啥是迭代器，因为co执行的时候，传入的是fn.call(…); </p>
<p>再回顾一下compose生成的异步函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">\*function() &#123;</div><div class="line">  return yield * itor1(itor2(itor3))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>co执行过程：</p>
<ol>
<li>返回一个promise，promise中包括的执行流程是：</li>
<li>如果gen是普通函数，直接执行；如果gen是不为空的值并且gen.next不为function也就是说gen不是迭代器，直接返回resolve(), 这个实际是co返回promise的resolve，也就是总的出口；</li>
<li>gen是迭代器，执行gen.next()，也就是会执行<code>yield * itor1(itor2(noop_itor))</code>，<strong>yield *实际上是委托生成器; 会直接执行到itor1第一个yield next处</strong>；并且此时gen.next()得到ret；<strong>并且ret.value就是next的值，也就是itor1的传入的实参itor2(itor3);</strong></li>
<li>我们快要接近剥洋葱的流程了，只要itor2重复前面的流程，怎么实现呢，实际就是toPromise的工作了，且看next(ret)；</li>
<li>next函数中：如果ret.done === true, 直接退出, 这也是一个出口；否则把ret.value转换为promise对象，当ret.value是一个迭代器的时候，toPromise主要工作是重复co.call(this, ret.value); <strong> 这样就重复的执行每个中间件的yield next前面的代码，直到执行到noop并层层返回；这实际有点类似二叉树的先序遍历过程；</strong></li>
<li>最后会回到第一次返回promise的函数中，并且resolve，这样就可以执行<code>fn.call(ctx).then(function handleResponse() {respond.call(ctx);}).catch(ctx.onerror);</code>的then处理了，否则catch处理；</li>
<li>自此一个网络请求后的中间件处理完毕；</li>
</ol>
<h4 id="总执行过程"><a href="#总执行过程" class="headerlink" title="总执行过程"></a>总执行过程</h4><ul>
<li>请求到来</li>
<li>…</li>
<li>执行fn.call(ctx)，实际上就是执行<code>co.wrap(compose(this.middleware)).call(ctx)</code>, 而<code>co.wrap(...).call(ctx)</code>实际就是上面的co函数的执行过程；</li>
<li>中间件处理完毕, 然后执行respond.call(ctx);</li>
</ul>
<h2 id="koa的上下文"><a href="#koa的上下文" class="headerlink" title="koa的上下文"></a>koa的上下文</h2><p>koa服务每当一个新的网络请求来临的时候会生成一个新的上下文，也就是代码中的多次出现的ctx；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var ctx = self.createContext(req, res);</div><div class="line">app.createContext = function(req, res)&#123;</div><div class="line">  var context = Object.create(this.context);</div><div class="line">  var request = context.request = Object.create(this.request);</div><div class="line">  var response = context.response = Object.create(this.response);</div><div class="line">  context.app = request.app = response.app = this;</div><div class="line">  context.req = request.req = response.req = req;</div><div class="line">  context.res = request.res = response.res = res;</div><div class="line">  request.ctx = response.ctx = context;</div><div class="line">  request.response = response;</div><div class="line">  response.request = request;</div><div class="line">  context.onerror = context.onerror.bind(context);</div><div class="line">  context.originalUrl = request.originalUrl = req.url;</div><div class="line">  context.cookies = new Cookies(req, res, &#123;</div><div class="line">    keys: this.keys,</div><div class="line">    secure: request.secure</div><div class="line">  &#125;);</div><div class="line">  context.accept = request.accept = accepts(req);</div><div class="line">  context.state = &#123;&#125;;</div><div class="line">  return context;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个context是以koa的实例服务app.context为原型，并且对ctx(即context)的属性request、response也设计了原型，这有什么用处呢？</p>
<p>实际上我们获取ctx.header、ctx.method或者设置ctx.method等的值，就是通过这里来的；举一个例子，获取ctx.header</p>
<ul>
<li>1 ctx中没有，从原型app.context中寻找</li>
<li><p>2 app.context从静态类context中寻找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Application() &#123;</div><div class="line">  if (!(this instanceof Application)) return new Application;</div><div class="line">  ...</div><div class="line">  **this.context = Object.create(context);**</div><div class="line">  this.request = Object.create(request);</div><div class="line">  this.response = Object.create(response);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>3 context中的header代理了request静态类的属性header；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">delegate(proto, &apos;request&apos;)</div><div class="line">  .method(&apos;acceptsLanguages&apos;)</div><div class="line">  ... // 省略</div><div class="line">  .getter(&apos;header&apos;)</div><div class="line">  ...</div><div class="line">  .getter(&apos;ip&apos;);</div><div class="line"></div><div class="line">Delegator.prototype.getter = function(name)&#123;</div><div class="line">  var proto = this.proto;</div><div class="line">  var target = this.target;</div><div class="line">  this.getters.push(name);</div><div class="line"></div><div class="line">  proto.__defineGetter__(name, function()&#123;</div><div class="line">    return this[target][name];</div><div class="line">  &#125;);</div><div class="line">  return this;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>4 也就是ctx[‘request’][‘header’]</p>
</li>
<li><p>5 寻找ctx[‘request’][‘header’]也就是从ctx[‘request’]的原型app.request寻找，接着到静态类request中寻找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">get header() &#123;</div><div class="line">  return this.req.headers;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
</li>
<li><p>6 也就是return ctx.request.req.headers, 其中ctx.request.req实际就是网络请求传入的req对象</p>
</li>
<li>7 获取header成功</li>
</ul>
<p>koa利用原型链查找、委托代理等手段，设置了很多方面快捷的属性获取、属性设置和方法调用；</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文讲述了下面几方面内容：</p>
<ul>
<li>koa简单使用</li>
<li>koa中间件执行过程</li>
<li>koa中间件执行原理</li>
<li>koa上下文ctx</li>
<li>koa快捷过程</li>
</ul>
<p>不过koa也有不足之处，如果上层中间件设置了多次yield next，虽然后面的迭代器已经执行到<code>done:true</code>，但每次重新到下层中间件也是一种不必要的开销；koa1的代码也比较繁杂，理解起来比较困难；不过这些koa2都有所改善，koa2见。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/30/2017-11-30-Vue之实例化流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/30/2017-11-30-Vue之实例化流程/" itemprop="url">Vue实例化过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-30T00:00:00+08:00">
                2017-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>vue是一个灵活渐进的mvvm框架，其实际内容可以用 <code>UI=f(State)</code>这个公式来表示。</p>
<p>今天第一篇关于vue的剖析，从其实例化的过程来展开。</p>
<h2 id="vue实例化"><a href="#vue实例化" class="headerlink" title="vue实例化"></a>vue实例化</h2><p>vue核心是声明式渲染，其初始化的实例为后面的过程准备了各种条件，看下面一段简单的vue例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">  &#123;&#123; message &#125;&#125;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">var app = new Vue(&#123;</div><div class="line">  el: &apos;#app&apos;,</div><div class="line">  data: &#123;</div><div class="line">    message: &apos;Hello Vue!&apos;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>第一段代码是要初始化的template，第二段是实例的真正初始化内容，最终template会被渲染成<code>Hello Vue!</code>；</p>
<p>那当执行<code>new Vue(options)</code>时里面到底执行了什么？</p>
<h2 id="实例化流程"><a href="#实例化流程" class="headerlink" title="实例化流程"></a>实例化流程</h2><p>实际<code>new Vue(options)</code>是调用了<code>Vue.prototype._init</code>方法:</p>
<p>主要流程有：</p>
<h4 id="merge-options"><a href="#merge-options" class="headerlink" title="merge options"></a>merge options</h4><p>第一个流程先简单剖析下，流程过程主要是初始化实例vm的$options, 把构造函数<code>Vue.options({components:..., directives:..., filters:..., _base:...})</code>和options合并赋值给vm.$options;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">if (options &amp;&amp; options._isComponent) &#123;</div><div class="line">  // optimize internal component instantiation</div><div class="line">  // since dynamic options merging is pretty slow, and none of the</div><div class="line">  // internal component options needs special treatment.</div><div class="line">  initInternalComponent(vm, options);</div><div class="line">&#125; else &#123;</div><div class="line">  vm.$options = mergeOptions(</div><div class="line">    resolveConstructorOptions(vm.constructor),</div><div class="line">    options || &#123;&#125;,</div><div class="line">    vm</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="设置代理initProxy-vm"><a href="#设置代理initProxy-vm" class="headerlink" title="设置代理initProxy(vm)"></a>设置代理initProxy(vm)</h4><h4 id="初始化声明周期initLifecycle-vm"><a href="#初始化声明周期initLifecycle-vm" class="headerlink" title="初始化声明周期initLifecycle(vm)"></a>初始化声明周期initLifecycle(vm)</h4><p>主要是初始化与vm声明周期有关的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">vm.$parent = parent;</div><div class="line">vm.$root = parent ? parent.$root : vm;</div><div class="line"></div><div class="line">vm.$children = [];</div><div class="line">vm.$refs = &#123;&#125;;</div><div class="line"></div><div class="line">vm._watcher = null;</div><div class="line">vm._inactive = null;</div><div class="line">vm._directInactive = false;</div><div class="line">vm._isMounted = false;</div><div class="line">vm._isDestroyed = false;</div><div class="line">vm._isBeingDestroyed = false;</div></pre></td></tr></table></figure>
<h4 id="initEvents-vm"><a href="#initEvents-vm" class="headerlink" title="initEvents(vm)"></a>initEvents(vm)</h4><p>初始化事件属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vm._events = Object.create(null);</div><div class="line">vm._hasHookEvent = false;</div></pre></td></tr></table></figure>
<h4 id="initRender-vm"><a href="#initRender-vm" class="headerlink" title="initRender(vm)"></a>initRender(vm)</h4><p>初始化render的时候需要的一些属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">vm._vnode = null; // the root of the child tree</div><div class="line">vm._staticTrees = null; // v-once cached trees</div><div class="line">var options = vm.$options;</div><div class="line">var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree</div><div class="line">var renderContext = parentVnode &amp;&amp; parentVnode.context;</div><div class="line">vm.$slots = resolveSlots(options._renderChildren, renderContext);</div><div class="line">vm.$scopedSlots = emptyObject;</div><div class="line">// bind the createElement fn to this instance</div><div class="line">// so that we get proper render context inside it.</div><div class="line">// args order: tag, data, children, normalizationType, alwaysNormalize</div><div class="line">// internal version is used by render functions compiled from templates</div><div class="line">vm._c = function (a, b, c, d) &#123; return createElement(vm, a, b, c, d, false); &#125;;</div><div class="line">// normalization is always applied for the public version, used in</div><div class="line">// user-written render functions.</div><div class="line">vm.$createElement = function (a, b, c, d) &#123; return createElement(vm, a, b, c, d, true); &#125;;</div></pre></td></tr></table></figure>
<h4 id="callHook-vm-‘beforeCreate’"><a href="#callHook-vm-‘beforeCreate’" class="headerlink" title="callHook(vm, ‘beforeCreate’)"></a>callHook(vm, ‘beforeCreate’)</h4><p>调用‘beforeCreate’的hook函数<code>var handlers = vm.$options[hook];</code></p>
<h4 id="initInjections-vm"><a href="#initInjections-vm" class="headerlink" title="initInjections(vm)"></a>initInjections(vm)</h4><p>对vm.$options中的injections处理</p>
<h4 id="initState-vm"><a href="#initState-vm" class="headerlink" title="initState(vm)"></a>initState(vm)</h4><p>这个过程非常重要，里面吹了props／methods／data／computed等数据并初始化了依赖、watchers、deps等，是整个vm实例能够渲染并且监听数据变化的关键；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">vm._watchers = [];</div><div class="line">var opts = vm.$options;</div><div class="line">if (opts.props) &#123; initProps(vm, opts.props); &#125;</div><div class="line">if (opts.methods) &#123; initMethods(vm, opts.methods); &#125;</div><div class="line">if (opts.data) &#123;</div><div class="line">  initData(vm);</div><div class="line">&#125; else &#123;</div><div class="line">  observe(vm._data = &#123;&#125;, true /* asRootData */);</div><div class="line">&#125;</div><div class="line">if (opts.computed) &#123; initComputed(vm, opts.computed); &#125;</div><div class="line">if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</div><div class="line">  initWatch(vm, opts.watch);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="initProvide-vm"><a href="#initProvide-vm" class="headerlink" title="initProvide(vm)"></a>initProvide(vm)</h4><p><code>var provide = vm.$options.provide;</code></p>
<h4 id="callHook-vm-‘created’"><a href="#callHook-vm-‘created’" class="headerlink" title="callHook(vm, ‘created’)"></a>callHook(vm, ‘created’)</h4><p>调用‘created’的hook函数<code>var handlers = vm.$options[hook];</code></p>
<h4 id="vm-mount-vm-options-el"><a href="#vm-mount-vm-options-el" class="headerlink" title="vm.$mount(vm.$options.el)"></a>vm.$mount(vm.$options.el)</h4><p>这个是初始化vue实例的最后一步，把虚拟dom挂载到option.el(即’#app’)中；</p>
<p><strong>以上就是vue实例化的所有流程，本文并没有介绍各个流程的详细处理过程，在后续文章中会一一展开。</strong></p>
<h2 id="vue实例生命周期"><a href="#vue实例生命周期" class="headerlink" title="vue实例生命周期"></a>vue实例生命周期</h2><p>从上面流程中，其实可以看出一些实例生命周期的过程：</p>
<p><img src="/images/vuelifecycle.png" alt="声明周期"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/27/2017-11-27-ES6之Set与Map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/27/2017-11-27-ES6之Set与Map/" itemprop="url">ES6之Set与Map</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-27T00:00:00+08:00">
                2017-11-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为啥引入Set与Map"><a href="#为啥引入Set与Map" class="headerlink" title="为啥引入Set与Map"></a>为啥引入Set与Map</h2><p>在ES6之前，当想使用非数值型索引，就会用非数组对象创建所需的数据结构；</p>
<p>ES5中set集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var set = Object.create(null);</div><div class="line">set.foo = true;</div><div class="line">// checking for existence</div><div class="line">if (set.foo) &#123;</div><div class="line">    // code to execute</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Map集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var map = Object.create(null);</div><div class="line">map.foo = &quot;bar&quot;;</div><div class="line">// retrieving a value</div><div class="line">var value = map.foo;</div><div class="line">console.log(value);         // &quot;bar&quot;</div></pre></td></tr></table></figure>
<p>用这种方法的确可以模拟Set集合与Map集合，但这种<strong>所有对象的属性名必须是字符串类型，必须确保每个键名都是字符串类型且在对象中是唯一的</strong>。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var map = Object.create(null);</div><div class="line">map[5] = &quot;foo&quot;;</div><div class="line">console.log(map[&quot;5&quot;]);      // &quot;foo&quot;</div><div class="line"></div><div class="line">var map = Object.create(null),</div><div class="line">    key1 = &#123;&#125;,</div><div class="line">    key2 = &#123;&#125;;</div><div class="line">map[key1] = &quot;foo&quot;;</div><div class="line">console.log(map[key2]); // &quot;foo&quot;</div></pre></td></tr></table></figure>
<p>对于Map集合中，如果它的属性值是假值，则要求使用布尔值的情况下，会被自动转换成false。当在判断Map结合中是否有某些属性场景会有问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var map = Object.create(null);</div><div class="line">map.count = 0;</div><div class="line">// checking for the existence of &quot;count&quot; or for a nonzero value?</div><div class="line">if (map.count) &#123;</div><div class="line">   // code to execute</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ES6中Set"><a href="#ES6中Set" class="headerlink" title="ES6中Set"></a>ES6中Set</h2><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let set = new Set();</div><div class="line">set.add(5);</div><div class="line">set.add(&quot;5&quot;);</div><div class="line">console.log(set.size);</div></pre></td></tr></table></figure>
<h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let set = new Set();</div><div class="line">set.add(5);</div><div class="line">set.add(&quot;5&quot;);</div><div class="line">console.log(set.has(5)); // true</div><div class="line">set.delete(5);</div><div class="line">console.log(set.has(5)); // false</div><div class="line">console.log(set.size);   // 1</div><div class="line">set.clear();</div><div class="line">console.log(set.has(&quot;5&quot;));  // false</div><div class="line">console.log(set.size);      // 0</div></pre></td></tr></table></figure>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>需要注意的是回调函数中的前两个参数value与key是一样的；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let set = new Set([1, 2]);</div><div class="line">set.forEach(function(value, key, ownerSet) &#123;</div><div class="line">    console.log(key + &quot; &quot; + value);</div><div class="line">    console.log(ownerSet === set);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="转换为数组"><a href="#转换为数组" class="headerlink" title="转换为数组"></a>转换为数组</h4><p>在前面的迭代器中有讲到可迭代对象可以展开，同样Set可以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let set = new Set([1, 2, 3, 3, 3, 4, 5]),</div><div class="line">    array = [...set];</div><div class="line">console.log(array);  // [1, 2, 3, 4, 5]</div></pre></td></tr></table></figure>
<h4 id="Weak-Set集合"><a href="#Weak-Set集合" class="headerlink" title="Weak Set集合"></a>Weak Set集合</h4><p>为啥要引入Weak Set？先看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let set = new Set(),</div><div class="line">    key = &#123;&#125;;</div><div class="line">set.add(key);</div><div class="line">console.log(set.size);      // 1</div><div class="line">// eliminate original reference</div><div class="line">key = null;</div><div class="line">console.log(set.size);      // 1</div><div class="line">// get the original reference back</div><div class="line">key = [...set][0];</div></pre></td></tr></table></figure>
<p>上面例子将变量key设置null时消除了对初识对象的引用，但是Set集合却保留了这个引用；</p>
<p>有时我们希望当其他所有引用都不再存在时，让Set集合的这些引用随之消失；为了解决这个问题，ES6额外引入了一个类型：Weak Set集合（弱引用Set集合）。</p>
<p>Weak Set集合只存储对象的弱引用，并且不可以存储原始值；集合中的弱引用如果是对象唯一的引用，则会被回收并释放相应内存；</p>
<p>Weak Set支持add has和delete方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let set = new WeakSet(),</div><div class="line">    key = &#123;&#125;;</div><div class="line">// add the object to the set</div><div class="line">set.add(key);</div><div class="line">console.log(set.has(key));</div><div class="line">set.delete(key);</div><div class="line">console.log(set.has(key));</div></pre></td></tr></table></figure>
<p>Weak Set与Set区别：</p>
<ul>
<li>Weak Set实例中，只能含有对象参数；非对象参数会报错</li>
<li>Weak Set不可迭代；</li>
<li>Weak Set不暴露任何迭代器</li>
<li>Weak Set不支持forEach方法</li>
<li>Weak Set不支持size属性</li>
<li><strong>最大区别是Weak Set保存的是对象的弱引用</strong></li>
</ul>
<h2 id="ES6中Map"><a href="#ES6中Map" class="headerlink" title="ES6中Map"></a>ES6中Map</h2><h4 id="支持的方法has-delete-clear"><a href="#支持的方法has-delete-clear" class="headerlink" title="支持的方法has delete clear"></a>支持的方法has delete clear</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">let map = new Map();</div><div class="line">map.set(&quot;name&quot;, &quot;Nicholas&quot;);</div><div class="line">map.set(&quot;age&quot;, 25);</div><div class="line">console.log(map.size); // 2</div><div class="line">console.log(map.has(&quot;name&quot;)); // true</div><div class="line">console.log(map.get(&quot;name&quot;)); // &apos;Nicholas&apos;</div><div class="line">console.log(map.has(&quot;age&quot;)); // true</div><div class="line">console.log(map.get(&quot;age&quot;)); // 25</div><div class="line">map.delete(&quot;name&quot;);</div><div class="line">console.log(map.has(&quot;name&quot;)); // false</div><div class="line">console.log(map.get(&quot;name&quot;)); // undefined</div><div class="line">console.log(map.size); // 1</div><div class="line">map.clear();</div><div class="line">console.log(map.has(&quot;name&quot;)); // false</div><div class="line">console.log(map.get(&quot;name&quot;)); // undefined</div><div class="line">console.log(map.has(&quot;age&quot;)); // false</div><div class="line">console.log(map.get(&quot;age&quot;)); // undefined</div><div class="line">console.log(map.size); // 0</div></pre></td></tr></table></figure>
<h4 id="Map集合初始化"><a href="#Map集合初始化" class="headerlink" title="Map集合初始化"></a>Map集合初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let map = new Map([[&quot;name&quot;, &quot;Nicholas&quot;], [&quot;age&quot;, 25]]);</div><div class="line">console.log(map.has(&quot;name&quot;)); // true</div><div class="line">console.log(map.get(&quot;name&quot;)); // &apos;Nicholas&apos;</div><div class="line">console.log(map.has(&quot;age&quot;)); // true</div><div class="line">console.log(map.get(&quot;age&quot;)); // 25</div><div class="line">console.log(map.size); // 2</div></pre></td></tr></table></figure>
<h4 id="Map集合的forEach"><a href="#Map集合的forEach" class="headerlink" title="Map集合的forEach"></a>Map集合的forEach</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let map = new Map([[&quot;name&quot;, &quot;Nicholas&quot;], [&quot;age&quot;, 25]]);</div><div class="line">map.forEach(function(value, key, ownerMap) &#123;</div><div class="line">    console.log(key + &quot; &quot; + value);</div><div class="line">    console.log(ownerMap === map);</div><div class="line">&#125;);</div><div class="line">// name Nicholas</div><div class="line">// true</div><div class="line">// age 25</div><div class="line">// true</div></pre></td></tr></table></figure>
<h4 id="Weak-Map"><a href="#Weak-Map" class="headerlink" title="Weak Map"></a>Weak Map</h4><p>Weak Map与Map的不同之处和Weak Set与Set的不同类似</p>
<ul>
<li>Weak Map实例中，只能含有对象参数；非对象参数会报错</li>
<li>Weak Map不可迭代；</li>
<li>Weak Map不暴露任何迭代器</li>
<li>Weak Map不支持forEach方法</li>
<li>Weak Map不支持size属性,不支持clear</li>
<li><strong>最大区别是Weak Map保存的是对象的弱引用</strong></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/27/2017-11-26-ES之Promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/27/2017-11-26-ES之Promise/" itemprop="url">ES6之Promise</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-27T00:00:00+08:00">
                2017-11-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Promise基础知识"><a href="#Promise基础知识" class="headerlink" title="Promise基础知识"></a>Promise基础知识</h2><p>Promise相当于异步操作结果的占位符，它不会去订阅一个事件，也不会传递一个回调函数给目标函数，而是让函数返回一个Promise：</p>
<p><code>let promise = readFile(&#39;example.txt&#39;)</code></p>
<p> 上例子中，readFile不会立即开始读取文件，函数会返回一个表示异步读取操作的Promise对象，未来对这个对象的操作完全取决于Promise的声明周期。</p>
<h4 id="Promise生命周期"><a href="#Promise生命周期" class="headerlink" title="Promise生命周期"></a>Promise生命周期</h4><p> 生命周期有三个：pending、fullfilled、rejected</p>
<p> 所有promise都有then方法，它接受两个参数：第一个当Promise的状态变为fullfilled时要调用的函数，与异步操作相关的附加数据都会传递给这个完成函数；第二个是当Promise的状态变为rejected时要调用的函数，其与完成时调用的函数类似，所有与失败相关的附加数据都会传递这个拒绝函数；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let promise = readFile(&quot;example.txt&quot;);</div><div class="line">promise.then(function(contents) &#123;</div><div class="line">    // fulfillment</div><div class="line">    console.log(contents);</div><div class="line">&#125;, function(err) &#123;</div><div class="line">// rejection</div><div class="line">    console.error(err.message);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>如果一个对象实现了上面的then方法，那这个对象我们称之为thenable对象。所有的Promise对象都是thenable对象，但并非所有thenable对象都是Promise。</strong></p>
<p>Promise被解决（resolved）时执行，这些任务最终会被加入到一个为Promise量身定制的独立队列中，而不会立即执行，当前面的任务完成后其才被调用；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var p = new Promise(function(resolve, reject)&#123;resolve()&#125;);</div><div class="line">p.then(function()&#123;console.log(&apos;do&apos;)&#125;);</div><div class="line">console.log(&apos;do1&apos;);</div><div class="line">// do1</div><div class="line">// do</div></pre></td></tr></table></figure>
<h4 id="创建未完成的Promise"><a href="#创建未完成的Promise" class="headerlink" title="创建未完成的Promise"></a>创建未完成的Promise</h4><p>Promise的执行器会立即执行，然后执行后续流程中的代码;当Promise resolved之后会把任务加入到任务队列尾部，即调用resolve()后出触发一个异步操作，传入then和catch方法的函数会被添加到任务队列中并异步执行；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let promise = new Promise(function(resolve, reject) &#123;</div><div class="line">  console.log(&apos;Promise&apos;);</div><div class="line">  resolve();</div><div class="line">&#125;);</div><div class="line">promise.then(function() &#123;</div><div class="line">    console.log(&quot;Resolved.&quot;);</div><div class="line">&#125;);</div><div class="line">console.log(&quot;HI!&quot;);</div><div class="line">// &apos;Promise&apos;</div><div class="line">// HI!</div><div class="line">// Resolved</div></pre></td></tr></table></figure>
<h4 id="创建已处理的Promise"><a href="#创建已处理的Promise" class="headerlink" title="创建已处理的Promise"></a>创建已处理的Promise</h4><p>Promise.resolve() / Promise.reject()</p>
<p>除了上面的方法直接创建已处理的Promise；Promise的resolve和reject方法还可以接受非Promise的Thenable对象作为参数。如果传入非Promise的Thenable对象，则这些方法会创建一个新的Promise，并在then函数中被调用；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let thenable = &#123;</div><div class="line">    then: function(resolve, reject) &#123;</div><div class="line">        resolve(42);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">let p1 = Promise.resolve(thenable);</div><div class="line">p1.then(function(value) &#123;</div><div class="line">    console.log(value);     // 42</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="全局的Promise拒绝处理"><a href="#全局的Promise拒绝处理" class="headerlink" title="全局的Promise拒绝处理"></a>全局的Promise拒绝处理</h2><p>为了防止有些没有拒绝处理的promise的错误被忽略掉，可以用全局的Promise拒绝处理。</p>
<h4 id="浏览器环境的拒绝处理"><a href="#浏览器环境的拒绝处理" class="headerlink" title="浏览器环境的拒绝处理"></a>浏览器环境的拒绝处理</h4><p>浏览器有两个事件来识别未处理的拒绝的；</p>
<ul>
<li>unhandledrejection 在一个事件循环中，当Promise被拒绝，并且没有提供拒绝处理程序时，触发该事件</li>
<li>rejecttionhandled 在一个事件循环后，当Promise被拒绝时，若拒绝处理程序被调用，触发该事件；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let rejected;</div><div class="line">window.onunhandledrejection = function(event) &#123;</div><div class="line">    console.log(event.type); // &quot;unhandledrejection&quot;</div><div class="line">    console.log(event.reason.message); // &quot;Explosion!&quot;</div><div class="line">    console.log(rejected === event.promise); // true</div><div class="line">&#125;;</div><div class="line">window.onrejectionhandled = function(event) &#123;</div><div class="line">    console.log(event.type); // &quot;rejectionhandled&quot;</div><div class="line">    console.log(event.reason.message); // &quot;Explosion!&quot;</div><div class="line">    console.log(rejected === event.promise); // true</div><div class="line">&#125;;</div><div class="line">rejected = Promise.reject(new Error(&quot;Explosion!&quot;));</div></pre></td></tr></table></figure>
<h2 id="串联Promise"><a href="#串联Promise" class="headerlink" title="串联Promise"></a>串联Promise</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let p1 = new Promise(function(resolve, reject) &#123;</div><div class="line">                 resolve(42);</div><div class="line">&#125;);</div><div class="line">p1.then(function(value) &#123;</div><div class="line">    console.log(value);</div><div class="line">&#125;).then(function() &#123;</div><div class="line">    console.log(&quot;Finished&quot;);</div><div class="line">&#125;);</div><div class="line">// 42</div><div class="line">// Finished</div></pre></td></tr></table></figure>
<p><strong>务必在Promise链的末尾留一个有拒绝处理程序保证能够正确处理所有可能发生的错误。</strong></p>
<h4 id="Promise链的返回值"><a href="#Promise链的返回值" class="headerlink" title="Promise链的返回值"></a>Promise链的返回值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let p1 = new Promise(function(resolve, reject) &#123;</div><div class="line">    resolve(42);</div><div class="line"> &#125;);</div><div class="line">p1.then(function(value) &#123;</div><div class="line">    console.log(value); // 42</div><div class="line">    return value + 1;</div><div class="line">&#125;).then(function(value) &#123;</div><div class="line">    console.log(value); // 43</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="在Promise链中返回Promise"><a href="#在Promise链中返回Promise" class="headerlink" title="在Promise链中返回Promise"></a>在Promise链中返回Promise</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let p1 = new Promise(function(resolve, reject) &#123;</div><div class="line">    resolve(42);</div><div class="line">&#125;);</div><div class="line">let p2 = new Promise(function(resolve, reject) &#123;</div><div class="line">    resolve(43);</div><div class="line">&#125;);</div><div class="line">p1.then(function(value) &#123;</div><div class="line">    // first fulfillment handler</div><div class="line">    console.log(value);     // 42</div><div class="line">    return p2;</div><div class="line">&#125;).then(function(value) &#123;</div><div class="line">    // second fulfillment handler</div><div class="line">    console.log(value);     // 43</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="响应多个Promise"><a href="#响应多个Promise" class="headerlink" title="响应多个Promise"></a>响应多个Promise</h2><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let p1 = new Promise(function(resolve, reject) &#123;</div><div class="line">    resolve(42);</div><div class="line">&#125;);</div><div class="line">let p2 = new Promise(function(resolve, reject) &#123;</div><div class="line">    resolve(43);</div><div class="line">&#125;);</div><div class="line">let p3 = new Promise(function(resolve, reject) &#123;</div><div class="line">    resolve(44);</div><div class="line">&#125;);</div><div class="line">let p4 = Promise.all([p1, p2, p3]);</div><div class="line">p4.then(function(value) &#123;</div><div class="line">    console.log(Array.isArray(value));  // true</div><div class="line">    console.log(value[0]); // 42</div><div class="line">    console.log(value[1]); // 43</div><div class="line">    console.log(value[2]); // 44</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
<p>拒绝处理程序总是接受一个值而非数组，改值来自被拒绝Promise的拒绝值；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let p1 = new Promise(function(resolve, reject) &#123;</div><div class="line">    resolve(42);</div><div class="line">&#125;);</div><div class="line">let p2 = new Promise(function(resolve, reject) &#123;</div><div class="line">    reject(43);</div><div class="line">&#125;);</div><div class="line">let p3 = new Promise(function(resolve, reject) &#123;</div><div class="line">    resolve(44);</div><div class="line">&#125;);</div><div class="line">let p4 = Promise.all([p1, p2, p3]);</div><div class="line">p4.catch(function(value) &#123;</div><div class="line">    console.log(Array.isArray(value))   // false</div><div class="line">    console.log(value);                 // 43</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>race方法监听多个Promise，只要有一个Promise被解决，整个race就被解决；如果选解决的是已完成Promise，则返回已完成Promise，如果被解决的是已拒绝Promise，返回的是已拒绝Promise：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let p1 = new Promise(function(resolve, reject) &#123;</div><div class="line">    resolve(42);</div><div class="line">&#125;);</div><div class="line">let p2 = Promise.reject(43);</div><div class="line">let p3 = new Promise(function(resolve, reject) &#123;</div><div class="line">    resolve(44);</div><div class="line">&#125;);</div><div class="line">let p4 = Promise.race([p1, p2, p3]);</div><div class="line">p4.catch(function(value) &#123;</div><div class="line">    console.log(value);     // 43</div><div class="line">&#125;);</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/26/2017-11-26-ES6之迭代器与生成器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/26/2017-11-26-ES6之迭代器与生成器/" itemprop="url">ES6之迭代器与生成器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-26T00:00:00+08:00">
                2017-11-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>之前写过一篇文章关于可迭代对象-<a href="http://cauil.github.io/2017/09/07/2017-09-07-%E8%B0%88%E8%B0%88%E9%81%8D%E5%8E%86%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE/">谈谈遍历与迭代协议</a>， 并讲述了可迭代协议(iterable protocal);</p>
<p>还遗留了一个迭代器协议(iterator)没有讲述，这次我们就来说一说迭代器协议；</p>
<h4 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h4><p>MDN上是这样定义iterator protocal的：</p>
<p>The iterator protocol defines a standard way to produce a sequence of values (either finite or infinite).</p>
<p>An object is an iterator when it implements a next() method with the following semantics:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>next</td>
<td>A zero arguments function that returns an object with two properties:</td>
</tr>
</tbody>
</table>
<ul>
<li>done (boolean)<ul>
<li>Has the value true if the iterator is past the end of the iterated sequence. In this case value optionally specifies the return value of the iterator. The return values are explained here.</li>
<li>Has the value false if the iterator was able to produce the next value in the sequence. This is equivalent of not specifying the done property altogether.</li>
</ul>
</li>
<li>value - any JavaScript value returned by the iterator. Can be omitted when done is true.</li>
</ul>
<p>The next method always has to return an object with appropriate properties including done and value. If a non-object value gets returned (such as false or undefined), a TypeError (“iterator.next() returned a non-object value”) will be thrown. |</p>
<p>其实就是迭代器拥有一个next方法，每次调用返回含有value和done两个属性的对象，value表示下一个将要返回的值；done是一个布尔值，当没有更多返回数据时返回true；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var someArray = [1, 5];</div><div class="line">var someArrayEntries = someArray.entries();</div><div class="line"></div><div class="line">someArrayEntries.toString();   // &quot;[object Array Iterator]&quot;</div><div class="line">someArrayEntries === someArrayEntries[Symbol.iterator](); // true</div><div class="line">someArrayEntries.next(); // &#123;value: Array(2), done: false&#125;</div><div class="line">someArrayEntries.next(); // &#123;value: Array(2), done: false&#125;</div><div class="line">someArrayEntries.next(); // &#123;value: undefined, done: true&#125;</div></pre></td></tr></table></figure>
<p>上个例子中someArray.entries()生成了一个迭代器，每次调用next返回一个对象；当迭代到最后，返回{value: undefined, done: true}；<strong>并且特殊的是someArrayEntries也是一个符合iterable协议的可迭代对象，当调用<code>someArrayEntries[Symbol.iterator])</code>的时候返回一个迭代器对象就是其本身；</strong></p>
<h4 id="迭代器与可迭代对象的联系"><a href="#迭代器与可迭代对象的联系" class="headerlink" title="迭代器与可迭代对象的联系"></a>迭代器与可迭代对象的联系</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">iterableObj[Symbol.iterator]() ===&gt; iteratorObj;</div><div class="line">for （let v of iterableObj）&#123;</div><div class="line">  console.log(v);</div><div class="line">&#125;</div><div class="line">iteratorObj.next(); //&#123;value: v, done: false&#125;</div><div class="line">...</div><div class="line">iteratorObj.next(); //&#123;value: undefined, done: true&#125;</div></pre></td></tr></table></figure>
<p>以上介绍生成迭代器的方法还是针对具有Symbol.iterator属性的常见对象（如数组，map等）来的，怎么更通用的生成一个迭代器呢？</p>
<h4 id="内建迭代器"><a href="#内建迭代器" class="headerlink" title="内建迭代器"></a>内建迭代器</h4><p>1.集合对象迭代器</p>
<p>ES6中有三种类型集合对象： 数组、Map集合与Set集合。为了更好的访问对象中的内容，都内建了以下三种迭代器：</p>
<ul>
<li>entries() 返回一个迭代器，其值为多个键值对</li>
<li>values() 返回一个迭代器，其值为集合中的值</li>
<li>keys() 返回一个迭代器，其值为集合中的所有键名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</div><div class="line">for (let entry of colors.entries()) &#123;</div><div class="line">    console.log(entry);</div><div class="line">&#125;</div><div class="line">//[0, &quot;red&quot;]</div><div class="line">//[1, &quot;green&quot;]</div><div class="line">//[2, &quot;blue&quot;]</div><div class="line"></div><div class="line">let tracking = new Set([1234, 5678, 9012]);</div><div class="line">for (let value of tracking.values()) &#123;</div><div class="line">    console.log(value);</div><div class="line">&#125;</div><div class="line">// 1234</div><div class="line">// 5678</div><div class="line">// 9012</div><div class="line"></div><div class="line">let data = new Map();</div><div class="line">for (let key of data.keys()) &#123;</div><div class="line">    console.log(key);</div><div class="line">&#125;</div><div class="line">// &quot;title&quot;</div><div class="line">// &quot;format&quot;</div></pre></td></tr></table></figure>
<p>在for-of循环中，如果没有显式指定则使用默认的迭代器。数组和Set集合的默认迭代器是values()方法，Map默认迭代器是entries方法。</p>
<p>2.字符串迭代器和NodeList迭代器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var message = &quot;A 𠮷 B&quot;;</div><div class="line">for (let c of message) &#123;</div><div class="line">    console.log(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>NodeList迭代器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var divs = document.getElementsByTagName(&quot;div&quot;);</div><div class="line">    for (let div of divs) &#123;</div><div class="line">        console.log(div.id);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>上面的例子中生成迭代器的方法还是针对具有Symbol.iterator属性的常见对象（如数组，map等）来的，怎么更通用的生成一个迭代器呢？</p>
<p>ES6中引入了生成器；生成器是一种返回迭代器的函数，通过function关键字后的*号来表示，函数中会用到新的关键字yield。星号可以紧挨着function关键字，也可以在中间添加一个空格，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function *createIterator() &#123;</div><div class="line">    yield 1;</div><div class="line">    yield 2;</div><div class="line">    yield 3;</div><div class="line">&#125;</div><div class="line">// generators are called like regular functions but return an iterator</div><div class="line">let iterator = createIterator();</div><div class="line">console.log(iterator);              // [object Generator]</div><div class="line">console.log(iterator.next().value); // 1</div><div class="line">console.log(iterator.next().value); // 2</div><div class="line">console.log(iterator.next().value); // 3</div></pre></td></tr></table></figure>
<p>上面的例子createIterator就是一个生成器，生成器执行返回的是一个生成器对象，<strong>生成器对象既是一个迭代器也是一个可迭代对象。</strong></p>
<h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>生成器函数最有趣的部分是：每当执行完一条yield语句后函数就会自动停止执行。</p>
<p>**yield关键字只可以在生成器内部使用，在其他地方使用会导致程序抛出语法错误，即便在生成器内部的函数里使用也是如此：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function *createIterator(items) &#123;</div><div class="line">        items.forEach(function(item) &#123;</div><div class="line">            // syntax error</div><div class="line">            yield item + 1;</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从字面量上看，yield关键字确实在createIterator函数内部，但是它与return关键字一样，二者都不能穿透函数边界。嵌套函数中的return语句不能用做外部函数的返回语句，而此处嵌套函数中的yield语句会导致程序抛出语法错误。</p>
<h4 id="生成器函数表达式"><a href="#生成器函数表达式" class="headerlink" title="生成器函数表达式"></a>生成器函数表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let createIterator = function *(items) &#123;</div><div class="line">    for (let i = 0; i &lt; items.length; i++) &#123;</div><div class="line">        yield items[i];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">let iterator = createIterator([1, 2, 3]);</div><div class="line">console.log(iterator.next()); // &quot;&#123; value: 1, done: false &#125;&quot;</div><div class="line">console.log(iterator.next()); // &quot;&#123; value: 2, done: false &#125;&quot;</div><div class="line">console.log(iterator.next()); // &quot;&#123; value: 3, done: false &#125;&quot;</div><div class="line">console.log(iterator.next()); // &quot;&#123; value: undefined, done: true &#125;&quot;</div></pre></td></tr></table></figure>
<p><strong>不能用箭头函数来创建生成器</strong></p>
<h4 id="生成器对象的方法"><a href="#生成器对象的方法" class="headerlink" title="生成器对象的方法"></a>生成器对象的方法</h4><p>由于生成器对象本身就是函数，因而可以将她们添加到对象中。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let o = &#123;</div><div class="line">    createIterator: function *(items) &#123;</div><div class="line">        for (let i = 0; i &lt; items.length; i++) &#123;</div><div class="line">            yield items[i];</div><div class="line">        &#125;</div><div class="line">&#125; &#125;;</div><div class="line">let iterator = o.createIterator([1, 2, 3]);</div></pre></td></tr></table></figure>
<p>也可以用ES6对象方法的简写方式来创建生成器；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let o = &#123;</div><div class="line">    *createIterator(items) &#123;</div><div class="line">        for (let i = 0; i &lt; items.length; i++) &#123;</div><div class="line">            yield items[i];</div><div class="line">        &#125;</div><div class="line">&#125; &#125;;</div><div class="line">let iterator = o.createIterator([1, 2, 3]);</div></pre></td></tr></table></figure>
<h2 id="高级生成器"><a href="#高级生成器" class="headerlink" title="高级生成器"></a>高级生成器</h2><p>生成器根据需求计算它们的产出值，这使得它们能够有效地表示计算成本高的序列，或者甚至如上所述的无限序列。</p>
<h4 id="给迭代器传递参数"><a href="#给迭代器传递参数" class="headerlink" title="给迭代器传递参数"></a>给迭代器传递参数</h4><p>The next() 方法也接受可用于修改生成器内部状态的值。传递给next()的值将被视为暂停生成器的最后一个yield表达式的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">function* fibonacci() &#123;</div><div class="line">  var fn1 = 0;</div><div class="line">  var fn2 = 1;</div><div class="line">  while (true) &#123;  </div><div class="line">    var current = fn1;</div><div class="line">    fn1 = fn2;</div><div class="line">    fn2 = current + fn1;</div><div class="line">    var reset = yield current;</div><div class="line">    if (reset) &#123;</div><div class="line">        fn1 = 0;</div><div class="line">        fn2 = 1;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var sequence = fibonacci();</div><div class="line">console.log(sequence.next().value);     // 0</div><div class="line">console.log(sequence.next().value);     // 1</div><div class="line">console.log(sequence.next().value);     // 1</div><div class="line">console.log(sequence.next().value);     // 2</div><div class="line">console.log(sequence.next().value);     // 3</div><div class="line">console.log(sequence.next().value);     // 5</div><div class="line">console.log(sequence.next().value);     // 8</div><div class="line">console.log(sequence.next(true).value); // 0</div><div class="line">console.log(sequence.next().value);     // 1</div><div class="line">console.log(sequence.next().value);     // 1</div><div class="line">console.log(sequence.next().value);     // 2</div></pre></td></tr></table></figure>
<h4 id="在迭代器中抛出错误"><a href="#在迭代器中抛出错误" class="headerlink" title="在迭代器中抛出错误"></a>在迭代器中抛出错误</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function *createIterator() &#123;</div><div class="line">    let first = yield 1;</div><div class="line">    let second = yield first + 2;</div><div class="line">    yield second + 3;</div><div class="line">&#125;</div><div class="line">let iterator = createIterator();</div><div class="line">console.log(iterator.next()); // &#123;value: 1, done: false&#125;</div><div class="line">console.log(iterator.next(4)); // &#123;value: 6, done: false&#125;</div><div class="line">console.log(iterator.throw(new Error(&quot;Boom&quot;)));</div></pre></td></tr></table></figure>
<h4 id="生成器返回语句"><a href="#生成器返回语句" class="headerlink" title="生成器返回语句"></a>生成器返回语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function *createIterator() &#123;</div><div class="line">    yield 1;</div><div class="line">    return 42;</div><div class="line">&#125;</div><div class="line">let iterator = createIterator();</div><div class="line">console.log(iterator.next()); // &quot;&#123; value: 1, done: false &#125;&quot;</div><div class="line">console.log(iterator.next()); // &quot;&#123; value: 42, done: true &#125;&quot;</div><div class="line">console.log(iterator.next()); // &quot;&#123; value: undefined, done: true &#125;&quot;</div></pre></td></tr></table></figure>
<p>上面例子中return语句返回一个值，该值被赋值给返回对象的value属性，本来第二条是返回<code>{ value: undefined, done: true }</code>的最终返回<code>{ value: 42, done: true }</code></p>
<h4 id="委托生成器"><a href="#委托生成器" class="headerlink" title="委托生成器"></a>委托生成器</h4><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yield* [[expression]];</div><div class="line">expression</div><div class="line">  返回一个可迭代对象的表达式。</div></pre></td></tr></table></figure>
<p><code>yield*</code> 表达式迭代操作数，并产生它返回的每个值。<code>yield*</code> 表达式本身的值是当迭代器关闭时返回的值（即done为true时）;</p>
<p>1.委托给其他生成器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function* g1() &#123;</div><div class="line">  yield 2;</div><div class="line">  yield 3;</div><div class="line">  yield 4;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function* g2() &#123;</div><div class="line">  yield 1;</div><div class="line">  yield* g1();</div><div class="line">  yield 5;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var iterator = g2();</div><div class="line"></div><div class="line">console.log(iterator.next()); // &#123; value: 1, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: 2, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: 3, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: 4, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: 5, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure>
<p>2.委托给其他可迭代对象</p>
<p>除了生成器对象这一种可迭代对象，yield* 还可以 yield 其它任意的可迭代对象，比如说数组、字符串、arguments 对象等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function* g3() &#123;</div><div class="line">  yield* [1, 2];</div><div class="line">  yield* &quot;34&quot;;</div><div class="line">  yield* arguments;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var iterator = g3(5, 6);</div><div class="line"></div><div class="line">console.log(iterator.next()); // &#123; value: 1, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: 2, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: &quot;3&quot;, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: &quot;4&quot;, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: 5, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: 6, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure>
<p>3.<code>yield*</code> 表达式的值</p>
<p><code>yield*</code> 是一个表达式，不是语句，所以它会有自己的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function* g4() &#123;</div><div class="line">  yield* [1, 2, 3];</div><div class="line">  return &quot;foo&quot;;</div><div class="line">&#125;</div><div class="line">var result;</div><div class="line">function* g5() &#123;</div><div class="line">  result = yield* g4();</div><div class="line">&#125;</div><div class="line">var iterator = g5();</div><div class="line"></div><div class="line">console.log(iterator.next()); // &#123; value: 1, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: 2, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: 3, done: false &#125;</div><div class="line">console.log(iterator.next()); // &#123; value: undefined, done: true &#125;, 此时 g4() 返回了 &#123; value: &quot;foo&quot;, done: true &#125;</div><div class="line">console.log(result);          // &quot;foo&quot;</div></pre></td></tr></table></figure>
<p>koa1源码中就有用到委托生成器语法；</p>
<h2 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h2><p>ES6中，所有的集合对象（数组、Set集合、Map集合）和字符串都是可迭代对象，这些对象中都有默认的迭代器；</p>
<p>之前的文章谈过可迭代对象，这里就总结一下：</p>
<h4 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for-of循环"></a>for-of循环</h4><p>可迭代对象可用于for-of循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let values = [1, 2, 3];</div><div class="line">for (let num of values) &#123;</div><div class="line">    console.log(num);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="spread-syntax-…"><a href="#spread-syntax-…" class="headerlink" title="spread syntax (…)"></a>spread syntax (…)</h4><p>可迭代对象可用于…语法：</p>
<p><code>[...&#39;abc&#39;]; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></p>
<h4 id="用于yield"><a href="#用于yield" class="headerlink" title="用于yield *"></a>用于yield *</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function* gen() &#123;</div><div class="line">  yield* [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="用于解构"><a href="#用于解构" class="headerlink" title="用于解构"></a>用于解构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let [a, b, c] = new Set([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/24/2017-11-24-ES6之类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/24/2017-11-24-ES6之类/" itemprop="url">ES6之class</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-24T00:00:00+08:00">
                2017-11-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><p>cheat sheet:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class PersonClass &#123;</div><div class="line">    // equivalent of the PersonType constructor</div><div class="line">    constructor(name) &#123;</div><div class="line">        this.name = name;</div><div class="line">                 &#125;</div><div class="line">    // equivalent of PersonType.prototype.sayName</div><div class="line">    sayName() &#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let person = new PersonClass(&quot;Nicholas&quot;);</div><div class="line">person.sayName();   // outputs &quot;Nicholas&quot;</div><div class="line">console.log(person instanceof PersonClass); // true</div><div class="line">console.log(person instanceof Object);      // true</div><div class="line">console.log(typeof PersonClass);            // function</div><div class="line">console.log(typeof PersonClass.prototype.sayName); // function</div></pre></td></tr></table></figure></p>
<p>类属性不可被赋予新值，在之前的实例中，PersonClass.prototype就是这样一个只可读的类属性；</p>
<h2 id="类语法"><a href="#类语法" class="headerlink" title="类语法"></a>类语法</h2><p>类与ES5类型（new Person）之间有诸多相识之初，但也有差异：</p>
<ol>
<li>函数声明可以被提升，而类声明与let声明类似，不能被提升；真正执行声明语句之前，它们会一直存在于临时死区</li>
<li>类声明中的所有代码将自动运行在严格模式下，而且无法强行让代码脱离严格模式执行；</li>
<li>在自定义类型中，需要通过Object.defineProperty方法手工指定某个方法不可枚举；而在类中，所有方法都是不可枚举的；</li>
<li>每个类都有一个名为[[Construct]]内部方法，通过关键字new调用那些不含有[[Construct]]的方法会导致程序抛出错误；</li>
<li>使用除关键字new以外的方法调用类的构造函数会导致程序抛出错误；</li>
<li>在类中修改类名会导致程序报错；</li>
</ol>
<p>下面是ES5来实现上面例子类PersonClass的等价代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">let PersonType2 = (function() &#123; // 1 临时死区</div><div class="line">  &apos;use strict&apos;; // 2 严格模式</div><div class="line">  </div><div class="line">  const PersonType2 = function(name) &#123; // 6 内部类名不可修改</div><div class="line">    if(typeof new.target === &apos;undefined&apos;) &#123; // 5 只能使用new</div><div class="line">      throw new Error(&apos;必须通过关键字new来调用构造函数&apos;);</div><div class="line">    &#125;</div><div class="line">    this.name = name;</div><div class="line">  &#125;</div><div class="line">  Object.defineProperty(PersonType2.prototype, sayName, &#123;</div><div class="line">    value: function() &#123;</div><div class="line">      if(typeof new.target !== &apos;undefined&apos;) &#123; // 4 不能使用new</div><div class="line">        throw Error(&apos;不能使用关键字new来调用该方法&apos;);</div><div class="line">      &#125;</div><div class="line">      console.log(this.name);</div><div class="line">    &#125;,</div><div class="line">    enumerable: false,// 3 不可枚举</div><div class="line">    writable: true,</div><div class="line">    configurable: true,</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line">  return Persontype2;</div><div class="line">&#125;())</div></pre></td></tr></table></figure>
<p>上述1和6可以看下面这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Foo &#123;</div><div class="line">   constructor() &#123;</div><div class="line">Foo = &quot;bar&quot;;// throws an error when executed...</div><div class="line">&#125; &#125;</div><div class="line">// but this is okay after the class declaration</div><div class="line">Foo = &quot;baz&quot;;</div></pre></td></tr></table></figure></p>
<h2 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h2><h4 id="声明表达式"><a href="#声明表达式" class="headerlink" title="声明表达式"></a>声明表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let PersonClass = class &#123;</div><div class="line"> ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="命名表达式"><a href="#命名表达式" class="headerlink" title="命名表达式"></a>命名表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let PersonClass = class PersonClass2 &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在JS引擎中，类表达式的实现与类声明稍有不同。对于类声明来说，通过let定义的外部绑定与通过const定义的内部绑定具有相同的名称；而命名表达式通过const定义名称，从而PersonClass2只能在类的内部使用；</p>
<h2 id="一等公民的类"><a href="#一等公民的类" class="headerlink" title="一等公民的类"></a>一等公民的类</h2><p>在程序中，一等公民是指一个可以传入函数，可以从函数返回，并且可以复制给变量的值。JS函数是一等公民，ES6中把类也设计为一等公民。</p>
<p>作为参数传入函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function createObject(classDef) &#123;</div><div class="line">  return new classDef();</div><div class="line">&#125;</div><div class="line"></div><div class="line">let obj = createObject(class &#123;...&#125;);</div></pre></td></tr></table></figure>
<p>立即调用类构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let person = new class &#123;</div><div class="line">  ...</div><div class="line">&#125;(&apos;Hi&apos;);</div></pre></td></tr></table></figure></p>
<h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><p>类也支持直接在原型上定义访问器属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class CustomHTMLElement &#123;</div><div class="line">    constructor(element) &#123;</div><div class="line">        this.element = element;</div><div class="line">&#125;</div><div class="line">    get html() &#123;</div><div class="line">        return this.element.innerHTML;</div><div class="line">&#125;</div><div class="line">    set html(value) &#123;</div><div class="line">        this.element.innerHTML = value;</div><div class="line">&#125; &#125;</div><div class="line">var descriptor = Object.getOwnPropertyDescriptor(CustomHTMLElement.prototype, &quot;html&quot;);</div><div class="line">console.log(&quot;get&quot; in descriptor);</div><div class="line">console.log(&quot;set&quot; in descriptor);</div><div class="line">console.log(descriptor.enumerable);</div><div class="line">// true</div><div class="line">// true</div><div class="line">// false</div></pre></td></tr></table></figure></p>
<h2 id="可计算成员名称"><a href="#可计算成员名称" class="headerlink" title="可计算成员名称"></a>可计算成员名称</h2><p>类方法和访问器属性也支持使用可计算名称；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let methodName = &quot;sayName&quot;;</div><div class="line">class PersonClass &#123;</div><div class="line">    constructor(name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    [methodName]() &#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125; </div><div class="line">&#125;;</div><div class="line">let me = new PersonClass(&quot;Nicholas&quot;);</div><div class="line">me.sayName();           // &quot;Nicholas&quot;</div></pre></td></tr></table></figure></p>
<h2 id="生成器方法"><a href="#生成器方法" class="headerlink" title="生成器方法"></a>生成器方法</h2><p>在类中可以在方法名称前附加一个星号来定义生成器；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">    *createIterator() &#123;</div><div class="line">        yield 1;</div><div class="line">        yield 2;</div><div class="line">        yield 3;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let instance = new MyClass();</div><div class="line">let iterator = instance.createIterator();</div></pre></td></tr></table></figure>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>ES6中类简化了创建静态成员的工程，在方法或访问器属性前面使用正式的静态注释即可；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class PersonClass &#123;</div><div class="line">  constructor() &#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125;  </div><div class="line">  static create() &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不可在实例中访问静态成员，必须要直接在类中访问静态成员</p>
<h2 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h2><p>ES6中使用extends关键字可以创造继承类；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Rectangle &#123;</div><div class="line">    constructor(length, width) &#123;</div><div class="line">        this.length = length;</div><div class="line">        this.width = width;</div><div class="line">    &#125;</div><div class="line">    getArea() &#123;</div><div class="line">        return this.length * this.width;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Square extends Rectangle &#123;</div><div class="line">    constructor(length) &#123;</div><div class="line">        // equivalent of Rectangle.call(this, length, length)</div><div class="line">        super(length, length);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var square = new Square(3);</div><div class="line">console.log(square.getArea());// 9</div><div class="line">console.log(square instanceof Square);// true</div><div class="line">console.log(square instanceof Rectangle);// true</div></pre></td></tr></table></figure>
<p>上述代码创造了一个Square继承Rectangle类；Square被称为派生类；注意：<strong>如果在派生类中指定了构造函数则必须要调用super，如果不这样做程序就会报错；如果不使用构造函数，则当创建新的类实例时会自动调用super并传入所有参数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Square extends Rectangle &#123;</div><div class="line">    // no constructor</div><div class="line">&#125;</div><div class="line">// is equivalent to</div><div class="line">class Square extends Rectangle &#123;</div><div class="line">    constructor(...args) &#123;</div><div class="line">        super(...args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用super要注意：</p>
<ul>
<li>只可在派生类的构造函数中使用super(),如果尝试在非派生类或者函数中使用会抛出错误</li>
<li>在构造函数中访问this前一定要调用super，它负责初试化this，如果在调用super之前尝试访问this会报错</li>
<li>如果不想调用super()，则唯一的方法是让类的构造函数返回一个对象</li>
</ul>
<h4 id="类方法遮蔽"><a href="#类方法遮蔽" class="headerlink" title="类方法遮蔽"></a>类方法遮蔽</h4><p>派生类如果跟父类有同名函数，派生类的方法会覆盖父类的同名方法；如果想在派生类中调用父类的方法，可以<code>super.funcName()</code>这样来调用；</p>
<h4 id="静态成员继承"><a href="#静态成员继承" class="headerlink" title="静态成员继承"></a>静态成员继承</h4><p>如果基类有静态成员，那么这些静态成员在派生类中也可调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Rectangle &#123;</div><div class="line">    constructor(length, width) &#123;</div><div class="line">        this.length = length;</div><div class="line">        this.width = width;</div><div class="line">    &#125;</div><div class="line">    getArea() &#123;</div><div class="line">        return this.length * this.width;</div><div class="line">&#125;</div><div class="line">    static create(length, width) &#123;</div><div class="line">        return new Rectangle(length, width);</div><div class="line">&#125; &#125;</div><div class="line">class Square extends Rectangle &#123;</div><div class="line">    constructor(length) &#123;</div><div class="line">        // equivalent of Rectangle.call(this, length, length)</div><div class="line">         super(length, length);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var rect = Square.create(3, 4);</div><div class="line">console.log(rect instanceof Rectangle); // true</div><div class="line">console.log(rect.getArea());            // 12</div><div class="line">console.log(rect instanceof Square);    // false</div></pre></td></tr></table></figure></p>
<p>新的静态方法create被添加到Rectangle中，继承后的Square.create()与Rectangle.create()行为类似；</p>
<h4 id="派生自表达式的类"><a href="#派生自表达式的类" class="headerlink" title="派生自表达式的类"></a>派生自表达式的类</h4><p>ES6最强大的一面或许是从表达式导出类的功能了；只要表达式可以被解析为一个函数并且具有[[Construct]]属性和原型，那么就可以用extends进行派生；<strong>extends强大的功能使得类可以继承自任意类型的表达式，从而可以创造更多可能性</strong>，例如动态的确定类的继承目标：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">let SerializableMixin = &#123;</div><div class="line">    serialize() &#123;</div><div class="line">        return JSON.stringify(this);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">let AreaMixin = &#123;</div><div class="line">    getArea() &#123;</div><div class="line">        return this.length * this.width;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">function mixin(...mixins) &#123;</div><div class="line">    var base = function() &#123;&#125;;</div><div class="line">    Object.assign(base.prototype, ...mixins);</div><div class="line">    return base;</div><div class="line">&#125;</div><div class="line">class Square extends mixin(AreaMixin, SerializableMixin) &#123;</div><div class="line">    constructor(length) &#123;</div><div class="line">         super();</div><div class="line">        this.length = length;</div><div class="line">        this.width = length;</div><div class="line">&#125; &#125;</div><div class="line">var x = new Square(3);</div><div class="line">console.log(x.getArea());   // 9</div><div class="line">console.log(x.serialize()); // &quot;&#123;&quot;length&quot;:3,&quot;width&quot;:3&#125;&quot;</div></pre></td></tr></table></figure>
<h4 id="内建对象的继承"><a href="#内建对象的继承" class="headerlink" title="内建对象的继承"></a>内建对象的继承</h4><p>在ES6之前，几乎不可能通过继承方式创建属于自己的数组，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var colors = [];</div><div class="line">colors[0] = &quot;red&quot;;</div><div class="line">console.log(colors.length); // 1</div><div class="line">colors.length = 0;</div><div class="line">console.log(colors[0]);     // undefined</div><div class="line"></div><div class="line">// trying to inherit from array in ES5</div><div class="line">function MyArray() &#123;</div><div class="line">    Array.apply(this, arguments);</div><div class="line">&#125;</div><div class="line">MyArray.prototype = Object.create(Array.prototype, &#123;</div><div class="line">    constructor: &#123;</div><div class="line">        value: MyArray,</div><div class="line">        writable: true,</div><div class="line">        configurable: true,</div><div class="line">        enumerable: true</div><div class="line">&#125; &#125;);</div><div class="line">var colors = new MyArray();</div><div class="line">colors[0] = &quot;red&quot;;</div><div class="line">console.log(colors.length); // 0</div><div class="line">colors.length = 0;</div><div class="line">console.log(colors[0])      // red</div></pre></td></tr></table></figure>
<p>通过上面的代码，可以看出MyArray的行为与内建数组行为不一致；</p>
<p>ES6中可以通过extends来创建自定义数组；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class MyArray extends Array &#123;</div><div class="line">    // empty</div><div class="line">&#125;</div><div class="line">var colors = new MyArray();</div><div class="line">colors[0] = &quot;red&quot;;</div><div class="line">console.log(colors.length); // 1</div><div class="line">colors.length = 0;</div><div class="line">console.log(colors[0]);     // undefined</div></pre></td></tr></table></figure></p>
<h2 id="在类的构造函数中使用new-target"><a href="#在类的构造函数中使用new-target" class="headerlink" title="在类的构造函数中使用new.target"></a>在类的构造函数中使用new.target</h2><p>类中new.targe一般就等于类本身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Rectangle &#123;</div><div class="line">    constructor(length, width) &#123;</div><div class="line">        console.log(new.target === Rectangle);</div><div class="line">        this.length = length;</div><div class="line">        this.width = width;</div><div class="line"> &#125; &#125;</div><div class="line">// new.target is Rectangle</div><div class="line">var obj = new Rectangle(3, 4); // outputs true</div></pre></td></tr></table></figure>
<p>但有时其值会不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Rectangle &#123;</div><div class="line">    constructor(length, width) &#123;</div><div class="line">        console.log(new.target === Rectangle);</div><div class="line">        this.length = length;</div><div class="line">        this.width = width;</div><div class="line">&#125; &#125;</div><div class="line">class Square extends Rectangle &#123;</div><div class="line">    constructor(length) &#123;</div><div class="line">         super(length, length)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// new.target is Square</div><div class="line">var obj = new Square(3); // outputs false</div></pre></td></tr></table></figure>
<p>Square调用Rectangle的构造函数，所以当调用发生时new.target等于Square;每个构造函数都可以根据自身被调用的方式改变自己的行为；例如构造一个抽象基类；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Shape &#123;</div><div class="line">    constructor() &#123;</div><div class="line">        if (new.target === Shape) &#123;</div><div class="line">            throw new Error(&quot;This class cannot be instantiated directly.&quot;)</div><div class="line">        &#125;</div><div class="line"> &#125; &#125;</div><div class="line">class Rectangle extends Shape &#123;</div><div class="line">    constructor(length, width) &#123;</div><div class="line">        super();</div><div class="line">        this.length = length;</div><div class="line">        this.width = width;</div><div class="line">&#125; &#125;</div><div class="line">var x = new Shape(); // throws an error</div><div class="line">var y = new Rectangle(3, 4); // no error</div><div class="line">console.log(y instanceof Shape); // true</div></pre></td></tr></table></figure>
<p>上例子中抽象基类Shape不能直接被实例化，只能通过派生的类来继承；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/22/2017-11-22-ES6之Symbol/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/22/2017-11-22-ES6之Symbol/" itemprop="url">ES6之Symbol</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T00:00:00+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ES6引入了第6种原始类型：Symbol。起初，人们用它来创建对象的私有成员；在Symbol出现之前，人们一直通过属性名来访问所有属性，无论属性名由什么元素构成，全部通过一个字符串类型的名称来访问。</p>
<p>私有名称原本是为了让开发者<strong>创建非字符串属性名称而设计</strong>的，但是<strong>一般的技术无法检测这些属性的私有名称</strong>。</p>
<h2 id="创建Symbol"><a href="#创建Symbol" class="headerlink" title="创建Symbol"></a>创建Symbol</h2><p>可以通过全局的Symbol函数创建一个Symbol：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let firstName = Symbol();</div><div class="line">let person = &#123;&#125;;</div><div class="line">person[firstName] = &quot;Nicholas&quot;;</div><div class="line">console.log(person[firstName]);</div></pre></td></tr></table></figure>
<p>由于Symbol是原始值，因此调用new Symbol()会导致程序抛出错误。</p>
<p>Symbol接受一个可选参数，其可以添加一段文本描述即将创建的Symbol，这段描述不可以用作属性访问，只是为了便于阅读和调试Symbol程序；symbol的描述被存储在内部的[[Description]]属性中，只有当调用Symbol的toString()方法时才可以读取这个属性；</p>
<p>检测一个Symbol：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let name = Symbol(&apos;hi&apos;);</div><div class="line">console.log(typeof name); // symbol</div></pre></td></tr></table></figure></p>
<h2 id="Symbol的使用方法"><a href="#Symbol的使用方法" class="headerlink" title="Symbol的使用方法"></a>Symbol的使用方法</h2><p><strong>所有使用可计算属性名的地方，都可以使用Symbol</strong>。如Object.defineProperty等:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let firstName = Symbol(&quot;first name&quot;);</div><div class="line">// use a computed object literal property</div><div class="line">let person = &#123;</div><div class="line">    [firstName]: &quot;Nicholas&quot;</div><div class="line">&#125;;</div><div class="line">// make the property read only</div><div class="line">Object.defineProperty(person, firstName, &#123; writable: false &#125;);</div><div class="line">let lastName = Symbol(&quot;last name&quot;);</div><div class="line">Object.defineProperties(person, &#123;</div><div class="line">    [lastName]: &#123;</div><div class="line">        value: &quot;Zakas&quot;,</div><div class="line">        writable: false</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="Symbol共享体系"><a href="#Symbol共享体系" class="headerlink" title="Symbol共享体系"></a>Symbol共享体系</h2><p>在不同的代码中共享同一个Symbol，ES6提供了一个可以随时访问的全局Symbol注册表；如果要创建一个共享的Symbol，要使用Symbol.for方法，它只接受一个参数，也就是即将创建的Symbol的字符串标示，这个参数同样也被用作Symbol的描述；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let uid = Symbol.for(&quot;uid&quot;);</div><div class="line">let object = &#123;&#125;;</div><div class="line">object[uid] = &quot;12345&quot;;</div><div class="line">console.log(object[uid]); // &apos;12345&apos;</div><div class="line">console.log(uid);         // &apos;Symbol(uid)&apos;</div></pre></td></tr></table></figure>
<p>Symbol.for首先在全局Symbol注册表中搜索键为’uid’的Symbol，如果存在，直接返回已存在的，否则创建一个新的Symbol，并使用这个键在Symbol全局注册表中注册，随机返回新创建的Symbol。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let uid = Symbol.for(&quot;uid&quot;);</div><div class="line">let uid2 = Symbol.for(&quot;uid&quot;);</div><div class="line">console.log(uid === uid2); // true</div><div class="line">console.log(uid2);         // &apos;Symbol(uid)&apos;</div></pre></td></tr></table></figure>
<p>还有一个与Symbol共享有关的特性，Symbol.keyFor方法在Symbol全局注册表中检索与Symbol有关的键；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let uid = Symbol.for(&quot;uid&quot;);</div><div class="line">console.log(Symbol.keyFor(uid)); // uid</div><div class="line">let uid2 = Symbol.for(&quot;uid&quot;);</div><div class="line">console.log(Symbol.keyFor(uid2));// uid</div><div class="line">let uid3 = Symbol(&quot;uid&quot;);</div><div class="line">console.log(Symbol.keyFor(uid3));// undefined</div></pre></td></tr></table></figure>
<p>Symbol全局注册表中不存在uid3这个Symbol(没有通过Symbol.for注册)，返回undefined；</p>
<h2 id="Symbol与类型强制转换"><a href="#Symbol与类型强制转换" class="headerlink" title="Symbol与类型强制转换"></a>Symbol与类型强制转换</h2><p>不能将Symbol强制转换为字符串和数字类型；Symbol在需要逻辑判断表达式中为真；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var uid = Symbol.for(&quot;uid&quot;),</div><div class="line">          desc = uid + &quot;&quot;;  // Cannot convert a Symbol value to a string</div><div class="line">var sum = uid / 1; // Cannot convert a Symbol value to a number</div><div class="line">!!uid; // true</div></pre></td></tr></table></figure>
<h2 id="Symbol属性检索"><a href="#Symbol属性检索" class="headerlink" title="Symbol属性检索"></a>Symbol属性检索</h2><p>Object.keys和Object.getOwnpropertyNames不能检索出Symbol属性，ES6中Object.getOwnpropertySymbols来支持这个功能，返回对象中的所有Symbol属性的数组；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let uid = Symbol.for(&quot;uid&quot;);</div><div class="line">let object = &#123;</div><div class="line">    [uid]: &quot;12345&quot;</div><div class="line">&#125;;</div><div class="line">let symbols = Object.getOwnPropertySymbols(object);</div><div class="line">console.log(symbols.length); // 1</div><div class="line">console.log(symbols[0]);     // &apos;Symbol(uid)&apos;</div><div class="line">console.log(object[symbols[0]]);// &apos;12345&apos;</div></pre></td></tr></table></figure>
<h2 id="通过well-known-Symbol暴露内部操作"><a href="#通过well-known-Symbol暴露内部操作" class="headerlink" title="通过well-known Symbol暴露内部操作"></a>通过well-known Symbol暴露内部操作</h2><p>ES6通过在原型链上定义与Symbol相关的属性来暴露更多的语言内部逻辑；开放了以前JS中常见的内部操作，并通过预定义一些well-known Symbol来表示。每一个这类Symbol都是symbol对象的一个属性，例如Symbol.match</p>
<h4 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h4><p>一个在执行instanceof时调用的内部方法，用于检测对象的继承信息；</p>
<p>Function.prototype中有一个Symbol.hasInstance方法，每一个函数都继承了这个方法，用于确定对象是否是函数的实例。该方法被定义为不可写，不可配置并且不可枚举。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertyDescriptor(Function.prototype, Symbol.hasInstance); // &#123;writable: false, enumerable: false, configurable: false, value: ƒ&#125;</div></pre></td></tr></table></figure>
<p>看一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Array.hasOwnProperty(Symbol.hasInstance);              // false</div><div class="line">Function.prototype.hasOwnProperty(Symbol.hasInstance); // true</div><div class="line">Array instanceof Function;                             // true</div></pre></td></tr></table></figure></p>
<p>从上面可以看出Array是Function的实例；Function.prototype具有自有属性Symbol.hasInstance，Array没有Symbol.hasInstance;</p>
<p><code>obj instanceof Array</code>实际等价于<code>Array[Symbol.hasInstance](obj)</code>，由于Array没有<code>Symbol.hasInstance</code>，所以会从原型链中寻找，最终在<code>Function.prototype</code>中找到，最终实际执行的就是<code>Function.prototype[Symbol.hasInstance](obj)</code>。</p>
<p>明白了instanceof的实际调用过程，就可以按我们的意愿来定制一些内容，例如定义一个无实例的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function MyObject() &#123;</div><div class="line">    // empty</div><div class="line">&#125;</div><div class="line">Object.defineProperty(MyObject, Symbol.hasInstance, &#123;</div><div class="line">    value: function(v) &#123;</div><div class="line">             return false;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">let obj = new MyObject();</div><div class="line">console.log(obj instanceof MyObject); // false</div></pre></td></tr></table></figure>
<h4 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h4><p>concat元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let colors1 = [ &quot;red&quot;, &quot;green&quot; ],</div><div class="line">    colors2 = colors1.concat([ &quot;blue&quot;, &quot;black&quot; ]);</div><div class="line">console.log(colors2.length);    // 4</div><div class="line">console.log(colors2); [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;black&quot;]</div></pre></td></tr></table></figure></p>
<p>concat数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let colors1 = [ &quot;red&quot;, &quot;green&quot; ],</div><div class="line">    colors2 = colors1.concat([ &quot;blue&quot;, &quot;black&quot; ], &quot;brown&quot;);</div><div class="line">console.log(colors2.length);    // 5</div><div class="line">console.log(colors2);           // [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;black&quot;,&quot;brown&quot;]</div></pre></td></tr></table></figure></p>
<p>JS规范声明，concat凡是传入了数组参数，就会自动将它们分解成独立元素，在ES6之前，我们根本无法调整这个特性；</p>
<p>Symbol.isConcatSpreadable属性是一个布尔值，如果该属性为true，则表示对象由length属性和数字键，故它的数值型属性应该被独立添加到cancat()调用结果中；与其他well-known Symbol属性不同的是，这个Symbol属性默认情况下不会出现标准对象，它只是一个可选对象，用于增强作用于特定对象类型的concat()方法的功能，有效简化其默认特性；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">let collection = &#123;</div><div class="line">    0: &quot;Hello&quot;,</div><div class="line">    1: &quot;world&quot;,</div><div class="line">    length: 2,</div><div class="line">    [Symbol.isConcatSpreadable]: true</div><div class="line">&#125;;</div><div class="line">let messages = [ &quot;Hi&quot; ].concat(collection);</div><div class="line">console.log(messages.length);    // 3</div><div class="line">console.log(messages);           // [&quot;Hi&quot;,&quot;Hello&quot;,&quot;world&quot;]</div><div class="line"></div><div class="line">let collection1 = &#123;</div><div class="line">    0: &quot;Hello&quot;,</div><div class="line">    1: &quot;world&quot;,</div><div class="line">    length: 2,</div><div class="line">    [Symbol.isConcatSpreadable]: true</div><div class="line">&#125;;</div><div class="line">let messages = [ &quot;Hi&quot; ].concat(collection1);</div><div class="line">console.log(messages.length);    // 2</div><div class="line">console.log(messages);           // [&quot;Hi&quot;,&#123;...&#125;]</div></pre></td></tr></table></figure>
<h4 id="Symbol-match-Symbol-replace-Symbol-search-Symbol-split"><a href="#Symbol-match-Symbol-replace-Symbol-search-Symbol-split" class="headerlink" title="Symbol.match Symbol.replace Symbol.search Symbol.split"></a>Symbol.match Symbol.replace Symbol.search Symbol.split</h4><p>这四个Symbol用在String对应的四个方法String.match/replace/search/split中且当参数为正则表达式时。</p>
<p>可以定义一个对象的这四个Symbol属性方法，这对象就可以代替正则表达式来应用在上面的对应场景中；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">// effectively equivalent to /^.&#123;10&#125;$/ </div><div class="line">let hasLengthOf10 = &#123;</div><div class="line">  [Symbol.match]: function(value) &#123;</div><div class="line">    return value.length === 10 ? [value.substring(0, 10)] : null;</div><div class="line">  &#125;,</div><div class="line">  [Symbol.replace]: function(value, replacement) &#123;</div><div class="line">    return value.length === 10 ? replacement + value.substring(10) : value;</div><div class="line">  &#125;,</div><div class="line">  [Symbol.search]: function(value) &#123;</div><div class="line">    return value.length === 10 ? 0 : -1;</div><div class="line">  &#125;,</div><div class="line">  [Symbol.split]: function(value) &#123;</div><div class="line">    return value.length === 10 ? [&quot;&quot;, &quot;&quot;] : [value];</div><div class="line">  &#125; </div><div class="line">&#125;;</div><div class="line"></div><div class="line">let message1 = &quot;Hello world&quot;, // 11 characters </div><div class="line">message2 = &quot;Hello John&quot;; // 10 characters</div><div class="line">let match1 = message1.match(hasLengthOf10), </div><div class="line">match2 = message2.match(hasLengthOf10);</div><div class="line">console.log(match1); // null </div><div class="line">console.log(match2); // [&quot;Hello John&quot;]</div><div class="line">let replace1 = message1.replace(hasLengthOf10), </div><div class="line">replace2 = message2.replace(hasLengthOf10);</div><div class="line">console.log(replace1); // &quot;Hello world&quot; </div><div class="line">console.log(replace2); // &quot;Hello John&quot;</div><div class="line">let search1 = message1.search(hasLengthOf10), </div><div class="line">search2 = message2.search(hasLengthOf10);</div><div class="line">console.log(search1); // -1 </div><div class="line">console.log(search2); // 0</div><div class="line">let split1 = message1.split(hasLengthOf10), </div><div class="line">split2 = message2.split(hasLengthOf10);</div><div class="line">console.log(split1); // [&quot;Hello world&quot;] </div><div class="line">console.log(split2); // [&quot;&quot;, &quot;&quot;]</div></pre></td></tr></table></figure>
<h4 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h4><p>JS引擎中，经常会尝试将对象转换到相应的原始值，例如比较一个对象与字符串；对象被转换为原始值，会有三种选择：数字，字符串或无类型偏好的值。对于大多数标准对象，当对象被转换为数字时：</p>
<ol>
<li>调用valueOf方法，如果结果为原始值，则返回</li>
<li>否则，调用toString方法，如果结果值为原始值，则返回</li>
<li>如果再无可选值，则抛出异常</li>
</ol>
<p>当对象被转换为字符串时：</p>
<ol>
<li>调用toSring方法，如果结果为原始值，则返回</li>
<li>否则，调用valueOf方法，如果结果值为原始值，则返回</li>
<li>如果再无可选值，则抛出异常</li>
</ol>
<p><strong>大多数情况下，标准对象会将默认模式按数字模式处理（除了Date对象）；默认模式只用于==运算，+运算及给Date构造函数传递一个参数时。</strong></p>
<p>在ES6标准中，通过Symbol.toPrimitive方法可以更改那个暴露出来的原始值；Symbol.toPrimitive被定义在每一个标准类型的原型上，并且规定了当对象被转换为原始值时应该执行的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Temperature(degrees) &#123;</div><div class="line">              this.degrees = degrees;</div><div class="line">&#125;</div><div class="line">Temperature.prototype[Symbol.toPrimitive] = function(hint) &#123;</div><div class="line">switch (hint) &#123;</div><div class="line">    case &quot;string&quot;:</div><div class="line">        return this.degrees + &quot;\u00b0&quot;; // degrees symbol</div><div class="line">    case &quot;number&quot;:</div><div class="line">        return this.degrees;</div><div class="line">    case &quot;default&quot;:</div><div class="line">        return this.degrees + &quot; degrees&quot;;</div><div class="line">&#125; &#125;;</div><div class="line">var freezing = new Temperature(32);</div><div class="line">console.log(freezing + &quot;!&quot;);    // &quot;32 degrees!&quot;</div><div class="line">console.log(freezing / 2);      // 16</div><div class="line">console.log(String(freezing));  // &quot;32°&quot;</div></pre></td></tr></table></figure>
<h4 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h4><p>当检测一个数据的类型时，可能会用instanceof,这样在使用iframe标签情况下会有一定问题，不同的iframe代表不同的领域，不同领域的构造函数是不同的，当数据传递到不同的领域时，使用instanceof会得不到预期的结果；</p>
<p>这时我们可能会用Object.prototype.toString.call来处理；</p>
<p>如区分原生JSON对象和自建对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function supportsNativeJSON() &#123;</div><div class="line">    return typeof JSON !== &quot;undefined&quot; &amp;&amp;</div><div class="line">        Object.prototype.toString.call(JSON) === &quot;[object JSON]&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在ES6中重新定义了原生对象过去的状态，通过Symbol.toStringTag改变了调用Object.prototype.toString方法时返回的身份标示；这个Symbol所代表的属性在每一个对象中都存在，其定义了调用对象的Object.prototype.toString.call方法时返回的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line">Person.prototype[Symbol.toStringTag] = &quot;Person&quot;;</div><div class="line">var me = new Person(&quot;Nicholas&quot;);</div><div class="line">console.log(me.toString());                     // [object Person]</div><div class="line">console.log(Object.prototype.toString.call(me)); // [object Person]</div></pre></td></tr></table></figure>
<h4 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h4><p>The Symbol.unscopables well-known symbol is used to specify an object value of whose own and inherited property names are excluded from the with environment bindings of the associated object.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var keys = [];</div><div class="line"></div><div class="line">with (Array.prototype) &#123;</div><div class="line">  keys.push(&apos;something&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Object.keys(Array.prototype[Symbol.unscopables]); </div><div class="line">// [&quot;copyWithin&quot;, &quot;entries&quot;, &quot;fill&quot;, &quot;find&quot;, &quot;findIndex&quot;, &quot;includes&quot;, &quot;keys&quot;, &quot;values&quot;]</div></pre></td></tr></table></figure>
<p>也可以改变对象的Symbol.unscopables属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var obj = &#123; </div><div class="line">  foo: 1, </div><div class="line">  bar: 2 </div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj[Symbol.unscopables] = &#123; </div><div class="line">  foo: false, </div><div class="line">  bar: true </div><div class="line">&#125;;</div><div class="line"></div><div class="line">with (obj) &#123;</div><div class="line">  console.log(foo); // 1</div><div class="line">  console.log(bar); // ReferenceError: bar is not defined</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/21/2017-11-21-ES6之对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/21/2017-11-21-ES6之对象/" itemprop="url">ES6之对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-21T00:00:00+08:00">
                2017-11-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="对象字面量语法扩展"><a href="#对象字面量语法扩展" class="headerlink" title="对象字面量语法扩展"></a>对象字面量语法扩展</h2><h4 id="属性初始值的简写"><a href="#属性初始值的简写" class="headerlink" title="属性初始值的简写"></a>属性初始值的简写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function createPerson(name, age) &#123;</div><div class="line">  return &#123;</div><div class="line">    name: name,</div><div class="line">    age: age </div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>属性与为属性赋值的变量是重复的，可以简写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function createPerson(name, age) &#123;</div><div class="line">  return &#123;</div><div class="line">    name,</div><div class="line">    age </div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样可以避免命名错误以及不小心的拼写错误。</p>
<h4 id="对象方法的简写"><a href="#对象方法的简写" class="headerlink" title="对象方法的简写"></a>对象方法的简写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    sayName: function() &#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以简写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    sayName() &#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>简写方法sayName里面可以使用super关键字；</p>
<h4 id="可计算属性名"><a href="#可计算属性名" class="headerlink" title="可计算属性名"></a>可计算属性名</h4><p>ES5及早期版本的对象实例中，如果想要通过计算得到属性名，就需要用方括号代替点记法。并且有空格的字符串不能直接作为属性名，也需要方括号代替；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var person = &#123;&#125;,</div><div class="line">    lastName = &quot;last name&quot;;</div><div class="line">person[&quot;first name&quot;] = &quot;Nicholas&quot;;</div><div class="line">person[lastName] = &quot;Zakas&quot;;</div><div class="line">console.log(person[&quot;first name&quot;]);</div><div class="line">console.log(person[lastName]);</div></pre></td></tr></table></figure>
<p>ES6中，可在对象字面量中使用可计算属性名称，其语法与引用对象实例的可计算属性名称相同，也是使用方括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let lastName = &quot;last name&quot;;</div><div class="line">let person = &#123;</div><div class="line">    &quot;first name&quot;: &quot;Nicholas&quot;,</div><div class="line">    [lastName]: &quot;Zakas&quot;</div><div class="line">&#125;;</div><div class="line">console.log(person[&quot;first name&quot;]);</div><div class="line">console.log(person[lastName]);</div></pre></td></tr></table></figure>
<h2 id="新增方法"><a href="#新增方法" class="headerlink" title="新增方法"></a>新增方法</h2><h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a>Object.is</h4><p>在JS中比较两个值，使用===跟==比较多，但是===在有些情况也不完全准确；+0与-0在JS引擎中是两个完全不同的实体，<code>NaN === NaN</code> 返回值为false，需要用isNaN()才能检测出NaN;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">console.log(+0 == -0);              // true</div><div class="line">console.log(+0 === -0);             // true</div><div class="line">console.log(Object.is(+0, -0));     // false</div><div class="line">console.log(NaN == NaN);            // false</div><div class="line">console.log(NaN === NaN);           // false</div><div class="line">console.log(Object.is(NaN, NaN));   // true</div><div class="line">console.log(5 == 5);                // true</div><div class="line">console.log(5 == &quot;5&quot;);              // true</div><div class="line">console.log(5 === 5);               // true</div><div class="line">console.log(5 === &quot;5&quot;);             // false</div><div class="line">console.log(Object.is(5, 5));       // true</div><div class="line">console.log(Object.is(5, &quot;5&quot;));     // false</div></pre></td></tr></table></figure>
<h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var receiver = &#123;&#125;;</div><div class="line">var test = &#123;name: &apos;zakas&apos;&#125;;</div><div class="line">Object.assign(receiver,</div><div class="line">    &#123;</div><div class="line">      type: &quot;js&quot;,</div><div class="line">        name: &quot;file.js&quot;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      type: &quot;css&quot;,</div><div class="line">      data: test,</div><div class="line">    &#125; </div><div class="line">);</div><div class="line">console.log(receiver.type); // css</div><div class="line">console.log(receiver.name); // file.js</div><div class="line">console.log(receiver.data); // &#123;name: &apos;zakas&apos;&#125;</div><div class="line">test.name = &apos;hi&apos;;</div><div class="line">console.log(receiver.data); // &#123;name: &apos;hi&apos;&#125;</div></pre></td></tr></table></figure>
<p>Object.assign参数后面的对象会覆盖前面的对象，并且为浅复制；</p>
<p>Object.assign会把访问器属性复制为数据属性；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var receiver = &#123;&#125;,</div><div class="line">  supplier = &#123;</div><div class="line">    get name() &#123;</div><div class="line">      return &quot;file.js&quot;</div><div class="line">    &#125; </div><div class="line">  &#125;;</div><div class="line">Object.assign(receiver, supplier);</div><div class="line">var descriptor = Object.getOwnPropertyDescriptor(receiver, &quot;name&quot;);</div><div class="line">console.log(descriptor.value);      // &quot;file.js&quot;</div><div class="line">console.log(descriptor.get);        // undefined</div></pre></td></tr></table></figure>
<h2 id="重复的对象字面量属性"><a href="#重复的对象字面量属性" class="headerlink" title="重复的对象字面量属性"></a>重复的对象字面量属性</h2><p>ES5严格模式重复字面量属性会报错；ES6无论严格或者非严格模式下，重复属性都会选取最后一个取值；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line">var person = &#123;</div><div class="line">  name: &quot;Nicholas&quot;,</div><div class="line">  name: &quot;Greg&quot;        // no error in ES6 strict mode</div><div class="line">&#125;;</div><div class="line">console.log(person.name); // Greg</div></pre></td></tr></table></figure></p>
<h2 id="自有属性枚举顺序"><a href="#自有属性枚举顺序" class="headerlink" title="自有属性枚举顺序"></a>自有属性枚举顺序</h2><ol>
<li>所有数字键按升序排列</li>
<li>所有字符串键按照它们被加入对象的顺序排序</li>
<li>所有symbol按照它们被加入的顺序排序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">    a: 1,</div><div class="line">    0: 1,</div><div class="line">    c: 1,</div><div class="line">    2: 1,</div><div class="line">    b: 1,</div><div class="line">    1: 1</div><div class="line">&#125;;</div><div class="line">obj.d = 1;</div><div class="line">console.log(Object.getOwnPropertyNames(obj).join(&quot;&quot;));</div><div class="line">// 012acbd</div></pre></td></tr></table></figure>
<h2 id="增强对象原型"><a href="#增强对象原型" class="headerlink" title="增强对象原型"></a>增强对象原型</h2><h4 id="改变对象的原型setPrototypeOf"><a href="#改变对象的原型setPrototypeOf" class="headerlink" title="改变对象的原型setPrototypeOf"></a>改变对象的原型setPrototypeOf</h4><p>对象原型的真实值被储存在内部的专用属性[[Prototype]]中，调用Object.getPrototypeOf返回储存在其中的值，调用Object.setPrototypeOf方法改变其中的值；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">let person = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        return &quot;Hello&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">let dog = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        return &quot;Woof&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">// prototype is person</div><div class="line">let friend = Object.create(person);</div><div class="line">console.log(friend.getGreeting()); // Hello</div><div class="line">console.log(Object.getPrototypeOf(friend) === person); // true</div><div class="line">// set prototype to dog</div><div class="line">Object.setPrototypeOf(friend, dog);</div><div class="line">console.log(friend.getGreeting()); // &quot;Woof&quot;</div><div class="line">console.log(Object.getPrototypeOf(friend) === dog); // true</div></pre></td></tr></table></figure>
<h4 id="简化原型访问的Super引用"><a href="#简化原型访问的Super引用" class="headerlink" title="简化原型访问的Super引用"></a>简化原型访问的Super引用</h4><p>ES6引入了super关键字，super引用相当于指向对象原型的指针，实际上也就是Object.getPrototypeOf()的效果；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let friend = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        // in the previous example, this is the same as:</div><div class="line">        // Object.getPrototypeOf(this).getGreeting.call(this)</div><div class="line">        return super.getGreeting() + &quot;, hi!&quot;;</div><div class="line">&#125; &#125;;</div></pre></td></tr></table></figure>
<p>super关键字必须要在使用简写方法的对象中使用super引用，如果在其他方法声明中使用会导致语法错误；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let friend = &#123;</div><div class="line">    getGreeting: function() &#123;// syntax error</div><div class="line">        return super.getGreeting() + &quot;, hi!&quot;; // &apos;super&apos; keyword unexpected here</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="正式的方法定义"><a href="#正式的方法定义" class="headerlink" title="正式的方法定义"></a>正式的方法定义</h2><p>ES6正式将方法定义为一个函数，它会由一个内部的[[HomeObject]]属性来容纳这个方法从属的对象；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let person = &#123;</div><div class="line">    // method</div><div class="line">    getGreeting() &#123;</div><div class="line">        return &quot;Hello&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">// not a method</div><div class="line">function shareGreeting() &#123;</div><div class="line">    return &quot;Hi!&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上段代码的getGreeting方法的[[HomeObject]]属性值为person，而创建shareGreeting函数时，由于未将其赋值给一个对象，因为该方法没有明确定义[[HomeObject]]属性。</p>
<p>super的所有引用都通过[[HomeObject]]属性调用Object.getPrototypeOf方法来检索原型的引用；然后搜寻原型找到同名函数；最后，设置this绑定并且调用相应的方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let person = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        return &quot;Hello&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">// prototype is person</div><div class="line">let friend = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        return super.getGreeting() + &quot;, hi!&quot;;</div><div class="line">&#125; &#125;;</div><div class="line">Object.setPrototypeOf(friend, person);</div><div class="line">console.log(friend.getGreeting());</div></pre></td></tr></table></figure>
<p><code>friend.getGreeting()</code>方法的[[HomeObject]]的属性值时friend,friend的原型是person，所以<code>super.getGreeting()</code>等价于<code>person.getGreeting.call(this)</code>;</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/21/2017-11-21-ES6之解构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/21/2017-11-21-ES6之解构/" itemprop="url">ES6之解构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-21T00:00:00+08:00">
                2017-11-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为何使用解构功能"><a href="#为何使用解构功能" class="headerlink" title="为何使用解构功能"></a>为何使用解构功能</h2><p>在编码过程中，我们经常定义许多对象和数组，然后有组织地从中提取相关的信息片段；如果对象跟数组结构复杂，我们就需要深入挖掘整个数据结构才能找到所需数据。</p>
<p>所以ES6位对象与数组都添加了结构功能，将数据结构打散的过程变得更加简单；许多语言都通过极少量的语法实现了结构功能，以简化获取信息的过程；而ES6实际上利用了你早已熟悉的语法：对象和数组字面量的语法。</p>
<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>对象解构的语法形式是在一个赋值操作符左边放置一个对象字面量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;foo&quot;</div><div class="line">&#125;;</div><div class="line">let &#123; type, name &#125; = node;</div><div class="line">console.log(type);      // &quot;Identifier&quot;</div><div class="line">console.log(name);      // &quot;foo&quot;</div></pre></td></tr></table></figure>
<p>使用var let或const解构声明变量，必须要提供初始化程序。下面几行代码全部都会导致抛出语法错误，它们都缺少了初始化程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// syntax error!</div><div class="line">var &#123; type, name &#125;;</div><div class="line">// syntax error!</div><div class="line">let &#123; type, name &#125;;</div><div class="line">// syntax error!</div><div class="line">const &#123; type, name &#125;;</div></pre></td></tr></table></figure>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>如果在定义变量之后想要修改它们的值，需要用小括号包裹解构赋值语句，因为JS引擎将一对开放的花括号视为一个代码块，而语法规定，代码块语句不允许出现在赋值语句左侧，添加小括号后可以将块语句转化为一个表达式，从而实现解构赋值的过程。如下面的<code>({ type, name } = node)</code>语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;foo&quot;</div><div class="line">&#125;,</div><div class="line">type = &quot;Literal&quot;,</div><div class="line">name = 5;</div><div class="line">// assign different values using destructuring</div><div class="line">(&#123; type, name &#125; = node);</div><div class="line">console.log(type);      // &quot;Identifier&quot;</div><div class="line">console.log(name);</div></pre></td></tr></table></figure>
<p>解构赋值表达式（=号右侧）如果为null或者undefined会导致程序抛出错误；<code>let {hello} = null</code>会抛出错误<code>Cannot destructure property</code>hello<code>of &#39;undefined&#39; or &#39;null&#39;.</code></p>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>当指定的局部变量名称在对象中不存在的时候，会被赋值为undefined，我们可以设置一个默认值，来处理这种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;foo&quot;</div><div class="line">&#125;;</div><div class="line">let &#123; type, name, value = true &#125; = node;</div><div class="line">console.log(type); // &quot;Identifier&quot;</div><div class="line">console.log(name); // &quot;foo&quot;</div><div class="line">console.log(value);// true</div></pre></td></tr></table></figure>
<h4 id="为非同名局部变量赋值"><a href="#为非同名局部变量赋值" class="headerlink" title="为非同名局部变量赋值"></a>为非同名局部变量赋值</h4><p>也可以使用非同名的局部变量来解构对象，并且可以指定默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;foo&quot;</div><div class="line">&#125;;</div><div class="line">let &#123; type: localType, name: localName, first_name: firstName=&apos;hi&apos; &#125; = node;</div><div class="line">console.log(localType);     // &quot;Identifier&quot;</div><div class="line">console.log(localName);     // &quot;foo&quot;</div><div class="line">console.log(firstName);     // &quot;hi&quot;</div></pre></td></tr></table></figure>
<h4 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;foo&quot;,</div><div class="line">    loc: &#123;</div><div class="line">        start: &#123;</div><div class="line">            line: 1,</div><div class="line">column: 1 &#125;,</div><div class="line">        end: &#123;</div><div class="line">            line: 1,</div><div class="line">column: 4 &#125;</div><div class="line">&#125; &#125;;</div><div class="line">let &#123; loc: &#123; start &#125;&#125; = node;</div><div class="line">console.log(start.line);   // 1</div><div class="line">console.log(start.column); // 1</div></pre></td></tr></table></figure>
<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>数组解构语法比对象解构更简单，使用的是数组字面量，且解构操作全部在数组内完成，而不是像对象字面量语法一样使用对象的命名属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</div><div class="line">let [ firstColor, ,thirdColor ] = colors;</div><div class="line">console.log(firstColor);        // &quot;red&quot;</div><div class="line">console.log(thirdColor);        // &quot;blue&quot;</div></pre></td></tr></table></figure>
<p>当通过var let或者const声明数组解构的绑定时，必须要提供一个初始化程序；</p>
<h4 id="解构赋值-1"><a href="#解构赋值-1" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>数组解构也可用于赋值上下文，不需要用小括号包裹， 因为[]跟{}不一样，后者有块级的功能；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ],</div><div class="line">    firstColor = &quot;black&quot;,</div><div class="line">    secondColor = &quot;purple&quot;;</div><div class="line">[ firstColor, secondColor ] = colors;</div><div class="line">console.log(firstColor);        // &quot;red&quot;</div><div class="line">console.log(secondColor);       // &quot;green&quot;</div></pre></td></tr></table></figure>
<p>数组也可用来交换两个变量的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let a = 1,</div><div class="line">b = 2;</div><div class="line">[ a, b ] = [ b, a ];</div><div class="line">console.log(a);     // 2</div><div class="line">console.log(b);     // 1</div></pre></td></tr></table></figure>
<p>与对象解构一样，如果右侧为null或者undefined，抛出错误；</p>
<h4 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let colors = [ &quot;red&quot; ];</div><div class="line">let [ firstColor, secondColor = &quot;green&quot; ] = colors;</div><div class="line">console.log(firstColor);        // &quot;red&quot;</div><div class="line">console.log(secondColor);       // &quot;green&quot;</div></pre></td></tr></table></figure>
<h4 id="嵌套解构-1"><a href="#嵌套解构-1" class="headerlink" title="嵌套解构"></a>嵌套解构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let colors = [ &quot;red&quot;, [ &quot;green&quot;, &quot;lightgreen&quot; ], &quot;blue&quot; ];</div><div class="line">// later</div><div class="line">let [ firstColor, [ secondColor ] ] = colors;</div><div class="line">console.log(firstColor);        // &quot;red&quot;</div><div class="line">console.log(secondColor);       // &quot;green&quot;</div></pre></td></tr></table></figure>
<h4 id="不定元素"><a href="#不定元素" class="headerlink" title="不定元素"></a>不定元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</div><div class="line">let [ firstColor, ...restColors ] = colors;</div><div class="line">console.log(firstColor);        // &quot;red&quot;</div><div class="line">console.log(restColors.length); // 2</div><div class="line">console.log(restColors[0]);     // &quot;green&quot;</div><div class="line">console.log(restColors[1]);     // &quot;blue&quot;</div></pre></td></tr></table></figure>
<p>通过上面这个语法，可以用来实现生成数组的副本；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// cloning an array in ECMAScript 6</div><div class="line">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</div><div class="line">let [ ...clonedColors ] = colors;</div><div class="line">console.log(clonedColors);      // &quot;[red,green,blue]&quot;</div></pre></td></tr></table></figure>
<p><strong>被解构的数组中，不定元素必须为最后一个条目，在后面继续添加逗号会导致程序抛出语法错误</strong></p>
<h2 id="混合解构"><a href="#混合解构" class="headerlink" title="混合解构"></a>混合解构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">    type: &quot;Identifier&quot;,</div><div class="line">    name: &quot;foo&quot;,</div><div class="line">    loc: &#123;</div><div class="line">        start: &#123;</div><div class="line">            line: 1,</div><div class="line">column: 1 &#125;,</div><div class="line">        end: &#123;</div><div class="line">            line: 1,</div><div class="line">column: 4 &#125;</div><div class="line">&#125;,</div><div class="line">    range: [0, 3]</div><div class="line">&#125;;</div><div class="line">let &#123;</div><div class="line">    loc: &#123; start &#125;,</div><div class="line">    range: [ startIndex ]</div><div class="line">&#125; = node;</div><div class="line">console.log(start.line);   // 1</div><div class="line">console.log(start.column); // 1</div><div class="line">console.log(startIndex);   // 0</div></pre></td></tr></table></figure>
<h2 id="解构参数"><a href="#解构参数" class="headerlink" title="解构参数"></a>解构参数</h2><p>ES5解析参数可能会这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// properties on options represent additional parameters</div><div class="line">function setCookie(name, value, options) &#123;</div><div class="line">    options = options || &#123;&#125;;</div><div class="line">    let secure = options.secure,</div><div class="line">    path = options.path,</div><div class="line">    domain = options.domain,</div><div class="line">    expires = options.expires;</div><div class="line">    // code to set the cookie</div><div class="line">&#125;</div><div class="line">// third argument maps to options</div><div class="line">setCookie(&quot;type&quot;, &quot;js&quot;, &#123;</div><div class="line">    secure: true,</div><div class="line">    expires: 60000</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>利用解构我们可以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function setCookie(name, value, &#123; secure, path, domain, expires &#125;) &#123;</div><div class="line">    // code to set the cookie</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="必须传值的解构参数"><a href="#必须传值的解构参数" class="headerlink" title="必须传值的解构参数"></a>必须传值的解构参数</h4><p>解构参数在默认情况下，如果调用函数时不提供被解构的参数会导致程序抛出错误；如果这样调用上面的setCookie函数<code>setCookie(&#39;type&#39;, &#39;js&#39;)</code>会抛出错误；</p>
<p>实际上JS是这样解析的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function setCookie(name, value, options) &#123;</div><div class="line">    let &#123; secure, path, domain, expires &#125; = options;</div><div class="line">    // code to set the cookie</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当第三个参数不传值时，实际options被赋值为undefined，根据前面讨论过的解构赋值表达式=号右边的值不能为undefined或者null，所以第三个参数是必须传值的；</p>
<p>可以设置默认值来避免必须传值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function setCookie(name, value, &#123; secure, path, domain, expires &#125; = &#123;&#125;) &#123;</div><div class="line">// empty</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="解构参数默认值"><a href="#解构参数默认值" class="headerlink" title="解构参数默认值"></a>解构参数默认值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function setCookie(name, value,</div><div class="line">    &#123;</div><div class="line">        secure = false,</div><div class="line">        path = &quot;/&quot;,</div><div class="line">        domain = &quot;example.com&quot;,</div><div class="line">        expires = new Date(Date.now() + 360000000)</div><div class="line">&#125; = &#123;&#125; )&#123;</div><div class="line">// empty </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以为第三个参数设置一个默认对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">const cookieDefault = &#123;</div><div class="line">  secure: false,</div><div class="line">  path: &apos;/&apos;,</div><div class="line">  domain: &apos;example.com&apos;,</div><div class="line">  expires: new Date(Date.now() + 360000000)</div><div class="line">&#125;;</div><div class="line">function setCookie(name, value,</div><div class="line">    &#123;</div><div class="line">        secure = cookieDefault.secure,</div><div class="line">        path = cookieDefault.path,</div><div class="line">        domain = cookieDefault.domain,</div><div class="line">        expires = cookieDefault.expires</div><div class="line">&#125; = cookieDefault )&#123;</div><div class="line">// empty </div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cauil.github.io/2017/11/19/2017-11-19-ES6之函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cauil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/abu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cauil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/19/2017-11-19-ES6之函数/" itemprop="url">ES6之函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-19T00:00:00+08:00">
                2017-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="函数形参默认值"><a href="#函数形参默认值" class="headerlink" title="函数形参默认值"></a>函数形参默认值</h2><h4 id="ES5默认形参"><a href="#ES5默认形参" class="headerlink" title="ES5默认形参"></a>ES5默认形参</h4><p>ES5中模拟默认形参<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function makeRequest(url, timeout, callback) &#123;</div><div class="line">  timeout = timeout || 2000;</div><div class="line">  callback = callback || function() &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是这种方法也有缺陷，如果第二个值我们传0，会被视为一个假值，函数timeout最后取值却为2000。</p>
<p>更好的做法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function makeRequest(url, timeout, callback) &#123;</div><div class="line">  timeout = typeof timeout !== undefined ? timeout : 2000;</div><div class="line">  callback = typeof callback !== undefined ? callback : function() &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="ES6默认形参"><a href="#ES6默认形参" class="headerlink" title="ES6默认形参"></a>ES6默认形参</h4><p>ES6做法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function makeRequest(url, timeout=2000, callback=function()&#123;&#125;) &#123;</div><div class="line">// do something</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>: 当timeout传值为undefined时，最终取值为默认值2000；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function makeRequest(url, timeout = 2000, callback) &#123;</div><div class="line">    console.log(timeout)</div><div class="line">&#125;</div><div class="line">makeRequest(&apos;/foo&apos;, undefined); // 2000</div></pre></td></tr></table></figure></p>
<h4 id="对arguments影响"><a href="#对arguments影响" class="headerlink" title="对arguments影响"></a>对arguments影响</h4><p>ES5非严格模式下，形参值被改变，arguments对应的也跟着改变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function mixArgs(first, second) &#123;</div><div class="line">    console.log(first === arguments[0]);</div><div class="line">    console.log(second === arguments[1]);</div><div class="line">    first = &quot;c&quot;;</div><div class="line">    second = &quot;d&quot;;</div><div class="line">    console.log(first === arguments[0]);</div><div class="line">    console.log(second === arguments[1]);</div><div class="line">&#125;</div><div class="line">mixArgs(&quot;a&quot;, &quot;b&quot;);</div><div class="line">// true</div><div class="line">// true</div><div class="line">// true</div><div class="line">// true</div></pre></td></tr></table></figure></p>
<p>严格模式下，无论形参如何被赋值，arguments不再跟着改变；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function mixArgs(first, second) &#123;</div><div class="line">    &apos;use strict&apos;;</div><div class="line">    console.log(first === arguments[0]);</div><div class="line">    console.log(second === arguments[1]);</div><div class="line">    first = &quot;c&quot;;</div><div class="line">    second = &quot;d&quot;;</div><div class="line">    console.log(first === arguments[0]);</div><div class="line">    console.log(second === arguments[1]);</div><div class="line">&#125;</div><div class="line">mixArgs(&quot;a&quot;, &quot;b&quot;);</div><div class="line">// true</div><div class="line">// true</div><div class="line">// false</div><div class="line">// false</div></pre></td></tr></table></figure></p>
<p>ES6中，如果使用了默认参数，则无论是否显式定义了严格模式，arguments行为与ES5严格模式下保持一致；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function mixArgs(first, second = &quot;b&quot;) &#123;</div><div class="line">    console.log(arguments.length);</div><div class="line">    console.log(first === arguments[0]);</div><div class="line">    console.log(second === arguments[1]);</div><div class="line">    first = &quot;c&quot;;</div><div class="line">    second = &quot;d&quot;</div><div class="line">    console.log(first === arguments[0]);</div><div class="line">    console.log(second === arguments[1]);</div><div class="line">&#125;</div><div class="line">mixArgs(&quot;a&quot;);</div><div class="line">// 1</div><div class="line">// true</div><div class="line">// false</div><div class="line">// false</div><div class="line">// false</div></pre></td></tr></table></figure></p>
<h4 id="默认参数表达式"><a href="#默认参数表达式" class="headerlink" title="默认参数表达式"></a>默认参数表达式</h4><p>默认参数也可以使用表达式；</p>
<p>默认参数表达式求值条件：当调用函数不传入默认参数对应位置的值时才会调用；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let value = 5;</div><div class="line">function getValue() &#123;</div><div class="line">    return value++;</div><div class="line">&#125;</div><div class="line">function add(first, second = getValue()) &#123;</div><div class="line">    return first + second;</div><div class="line">   &#125;</div><div class="line">console.log(add(1, 1)); // 2</div><div class="line">console.log(add(1)); // 6</div><div class="line">console.log(add(1)); // 7</div></pre></td></tr></table></figure>
<h4 id="默认参数临时死区（TDZ）"><a href="#默认参数临时死区（TDZ）" class="headerlink" title="默认参数临时死区（TDZ）"></a>默认参数临时死区（TDZ）</h4><p>默认参数也类似let有默认死区，后面的参数不能用在之前参数的默认值上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function add(first = second, second) &#123;</div><div class="line">    return first + second;</div><div class="line">&#125;</div><div class="line">console.log(add(1, 1));         // 2</div><div class="line">console.log(add(undefined, 1)); // Uncaught ReferenceError: second is not defined</div></pre></td></tr></table></figure></p>
<h2 id="无命名参数"><a href="#无命名参数" class="headerlink" title="无命名参数"></a>无命名参数</h2><p>由于之前当有多个无命名参数时，我们需要利用arguments参数来处理，有一个问题是需要记录从哪个索引开始，比较麻烦；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function pick(object) &#123;</div><div class="line">                 let result = Object.create(null);</div><div class="line">                 // start at the second parameter</div><div class="line">                 for (let i = 2, len = arguments.length; i &lt; len; i++) &#123;</div><div class="line">                     result[arguments[i]] = object[arguments[i]];</div><div class="line">                 &#125;</div><div class="line">                 return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ES6做法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function pick(object, ...keys) &#123;</div><div class="line">                 let result = Object.create(null);</div><div class="line">                 // start at the second parameter</div><div class="line">                 for (let i = 0, len = keys.length; i &lt; len; i++) &#123;</div><div class="line">                     result[keys[i]] = object[keys[i]];</div><div class="line">                 &#125;</div><div class="line">                 return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不定参数使用限制：<strong>最多只能一个不定参数，而且一定要放在所有参数的最后；</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function pick(object, ...keys, last) &#123;</div><div class="line">    let result = Object.create(null);</div><div class="line">    for (let i = 0, len = keys.length; i &lt; len; i++) &#123;</div><div class="line">        result[keys[i]] = object[keys[i]];</div><div class="line">&#125;</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line">pick() // error</div></pre></td></tr></table></figure>
<h2 id="增强的Function构造函数"><a href="#增强的Function构造函数" class="headerlink" title="增强的Function构造函数"></a>增强的Function构造函数</h2><p>Function构造函数也可以使用默认参数和无命名参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var add = new Function(&quot;first&quot;, &quot;second = first&quot;, &quot;...rest&quot;, &quot;return first + second&quot;);</div></pre></td></tr></table></figure>
<h2 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let values = [-25, -50, -75, -100];</div><div class="line">console.log(Math.max(...values, 0));</div></pre></td></tr></table></figure>
<h2 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var doSomething = function doSomethingElse() &#123;</div><div class="line">    // empty</div><div class="line">&#125;;</div><div class="line">var person = &#123;</div><div class="line">    get firstName() &#123;</div><div class="line">        return &quot;Nicholas&quot;</div><div class="line">    &#125;,</div><div class="line">    sayName: function() &#123;</div><div class="line">        console.log(this.name);</div><div class="line">&#125; &#125;</div><div class="line">console.log(doSomething.name); // doSomethingElse</div><div class="line">console.log(person.sayName.name); // sayName</div><div class="line">console.log(person.firstName.name); // get firstName</div><div class="line">console.log(doSomething.bind().name); // bound doSomethingElse</div><div class="line">console.log((new Function()).name); // anonymous</div></pre></td></tr></table></figure>
<p>注意:</p>
<ol>
<li>命名函数(doSomethingElse)并且赋值了一个变量(doSomething)，取命名的名字doSomethingElse;</li>
<li>get属性的函数前面会有一个get； // chrome是返回undefined，需要确认是不是实现不一致;</li>
<li>利用bind生成的新函数前面有一个bound</li>
<li>Function构造函数生成的函数为anonymous</li>
</ol>
<h2 id="明确函数的多重用途"><a href="#明确函数的多重用途" class="headerlink" title="明确函数的多重用途"></a>明确函数的多重用途</h2><p>JS函数有两个不同的内部方法： [[Call]]和[[Construct]]。当通过new关键字调用函数时，执行的是[[Construct]]，它负责创建一个通常被称为实例的新对象，然后再执行函数体，将this绑定到新实例上；如果不通过new关键字调用函数，则执行[[Call]]函数，从而直接执行代码中的函数体。具有[[Construct]]方法的函数被统称为构造函数。</p>
<p>注意：<strong>不是所有的函数都有[[Construct]]方法，例如箭头函数就没有[[Construct]]方法，所以箭头函数不能使用new关键字调用；</strong></p>
<p>之前ES5判断一个函数是不是通过’new’调用会判断this的原型, 但是这也有问题，函数执行没有用new但使用call来改变this同样可以不报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">    if (this instanceof Person) &#123;</div><div class="line">        this.name = name;   // using new</div><div class="line">    &#125; else &#123;</div><div class="line">        throw new Error(&quot;You must use new with Person.&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var person = new Person(&quot;Nicholas&quot;);</div><div class="line">var notAPerson = Person(&quot;Nicholas&quot;);</div><div class="line">var notAPerson = Person.call(person, &quot;Michael&quot;); // works</div></pre></td></tr></table></figure></p>
<h4 id="元属性new-target"><a href="#元属性new-target" class="headerlink" title="元属性new.target"></a>元属性new.target</h4><p>为了解决判断函数是否通过new关键字调用的问题，ES6引入了new.target这个元属性；</p>
<p>元属性是指非对象的属性，其可以提供非对象目标的补充信息；当调用函数的[[Construct]]方法时，new.target被赋值为new操作符的目标，通常是新创建对象实例，也就是函数体内this的构造函数，如果调用[[Call]]方法，则new.target的值为undefined。则判断一个函数是否是通过new关键字调用的，可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">    if (new.target === Person) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125; else &#123;</div><div class="line">        throw new Error(&quot;You must use new with Person.&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">function AnotherPerson(name) &#123;</div><div class="line">    Person.call(this, name);</div><div class="line">&#125;</div><div class="line">var person = new Person(&quot;Nicholas&quot;);</div><div class="line">var person = Person(&quot;Zakas&quot;); //Uncaught Error: You must use new with Person.</div><div class="line">var anotherPerson = new AnotherPerson(&quot;Nicholas&quot;);// Uncaught Error: You must use new with Person.</div></pre></td></tr></table></figure>
<p><strong>在函数体外使用new.target是一个语法错误</strong></p>
<h2 id="块级函数"><a href="#块级函数" class="headerlink" title="块级函数"></a>块级函数</h2><p>ES5严格模式下声明块级函数会抛出错误；ES6中，会将块级函数视作一个块级声明，从而在代码块内可以访问和调用；<strong>但是块级函数会被提升至顶部；</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">    console.log(typeof doSomething);</div><div class="line">    function doSomething() &#123;</div><div class="line">        // empty</div><div class="line">    &#125;</div><div class="line">    doSomething();</div><div class="line">&#125;</div><div class="line">console.log(typeof doSomething); // function</div></pre></td></tr></table></figure>
<p>如果要真正的定义块级函数，可以使用let表达式，这样函数表达式就不会提升了；并且有临时死区的情况，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">    console.log(typeof doSomething); // error</div><div class="line">    let doSomething = function () &#123;</div><div class="line">        // empty</div><div class="line">    &#125;</div><div class="line">    doSomething();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ol>
<li>无this super arguments和new.target绑定</li>
</ol>
<p>这些值由外围最近一层非箭头函数决定；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let PageHandler = &#123;</div><div class="line">    id: &quot;123456&quot;,</div><div class="line">    init: function() &#123;</div><div class="line">        document.addEventListener(&quot;click&quot;,</div><div class="line">                event =&gt; this.doSomething(event.type), false);</div><div class="line">    &#125;,</div><div class="line">    doSomething: function(type) &#123;</div><div class="line">        console.log(&quot;Handling &quot; + type  + &quot; for &quot; + this.id);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<ol>
<li>不能通过new关键字调用</li>
</ol>
<p>正如之前提到过的箭头函数没有[[Constructor]]方法，不能通过new关键字调用，；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var MyType = () =&gt; &#123;&#125;,</div><div class="line">object = new MyType(); // MyType is not a constructor</div></pre></td></tr></table></figure>
<ol>
<li>没有原型</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var MyType = () =&gt; &#123;&#125;;</div><div class="line">var test = function() &#123;&#125;;</div><div class="line">console.log(MyType.prototype); // undefined</div><div class="line">console.log(test.prototype.toString()); // [object Object]</div></pre></td></tr></table></figure>
<ol>
<li>不可以改变this的绑定</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var MyType = () =&gt; &#123;console.log(this)&#125;;</div><div class="line">MyType.bind(&#123;name: &apos;hi&apos;&#125;)(); // Window</div><div class="line">var test = function() &#123;console.log(this)&#125;;</div><div class="line">test.bind(&#123;name: &apos;hi&apos;&#125;)(); // &#123;name: &apos;hi&apos;&#125;</div></pre></td></tr></table></figure>
<ol>
<li>不支持arguments对象<br>绑定的arguments是外围非箭头函数的arguments</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function createArrowFunctionReturningFirstArg() &#123;</div><div class="line">    return () =&gt; arguments[0];</div><div class="line">&#125;</div><div class="line">var arrowFunction = createArrowFunctionReturningFirstArg(5);</div><div class="line">console.log(arrowFunction());</div></pre></td></tr></table></figure>
<ol>
<li>不支持重复的命名参数</li>
</ol>
<p>传统函数，只有严格模式不能使用重名的参数；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function test(name, name)&#123;&#125;;</div><div class="line">&apos;use strict&apos;;</div><div class="line">function test(name, name)&#123;&#125;; //Duplicate parameter name not allowed in this context</div></pre></td></tr></table></figure></p>
<p>箭头函数中，不支持重复的命名参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var test = (name, name) =&gt; &#123;console.log(this)&#125; // Duplicate parameter name not allowed in this context</div></pre></td></tr></table></figure></p>
<h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>ES6缩减了严格模式下尾调用栈的大小（非严格模式下不影响），如果满足以下条件，尾调用不再创建新的栈帧，而是清楚并重用当前栈帧：</p>
<ul>
<li>尾调用不访问当前栈帧的变量；（函数不是一个闭包）</li>
<li>在函数内部，尾调用是最后一条语句；</li>
<li>尾调用的结果作为函数值返回；</li>
</ul>
<p>满足条件的尾调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line">function doSomething() &#123;</div><div class="line">    // optimized</div><div class="line">    return doSomethingElse();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不满足第一个条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line">function doSomething() &#123;</div><div class="line">    var num = 1,</div><div class="line">        func = () =&gt; num;</div><div class="line">    // not optimized - function is a closure</div><div class="line">    return func();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不满足第二个条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line">function doSomething() &#123;</div><div class="line">    // not optimized - call isn&apos;t in tail position</div><div class="line">    var result = doSomethingElse();</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不满足第三个条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line">function doSomething() &#123;</div><div class="line">    // not optimized - must add after returning</div><div class="line">    return 1 + doSomethingElse();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/abu.jpg"
                alt="cauil" />
            
              <p class="site-author-name" itemprop="name">cauil</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/cauil" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/cauil" target="_blank" title="Weibo">
                    
                      <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://douban.com/people/cauil" target="_blank" title="DouBan">
                    
                      <i class="fa fa-fw fa-douban"></i>DouBan</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cauil</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
